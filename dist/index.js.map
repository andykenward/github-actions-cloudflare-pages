{
  "version": 3,
  "sources": ["../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js", "../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js", "../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js", "../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js", "../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js", "../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js", "../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js", "../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js", "../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js", "../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js", "../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js", "../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js", "../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js", "../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js", "../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js", "../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js", "../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js", "../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js", "../node_modules/.pnpm/@octokit+plugin-paginate-rest@8.0.0_@octokit+core@5.0.0/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/variables.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/lib/command.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/lib/utils.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/lib/file-command.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/types.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/errors.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/logging.ts", "../node_modules/.pnpm/@unlike+github-actions-core@0.1.0/node_modules/@unlike/github-actions-core/src/lib/summary.ts", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/index.js", "../node_modules/.pnpm/strip-final-newline@3.0.0/node_modules/strip-final-newline/index.js", "../node_modules/.pnpm/npm-run-path@5.1.0/node_modules/npm-run-path/index.js", "../node_modules/.pnpm/path-key@4.0.0/node_modules/path-key/index.js", "../node_modules/.pnpm/mimic-fn@4.0.0/node_modules/mimic-fn/index.js", "../node_modules/.pnpm/onetime@6.0.0/node_modules/onetime/index.js", "../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/main.js", "../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/realtime.js", "../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/signals.js", "../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/core.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/error.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/stdio.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/kill.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/pipe.js", "../node_modules/.pnpm/is-stream@3.0.0/node_modules/is-stream/index.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/stream.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/promise.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/command.js", "../node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/verbose.js", "../src/constants.ts", "../src/utils.ts", "../src/github/workflow-event/workflow-event.ts", "../__generated__/types/github/workflow-events.ts", "../src/github/context.ts", "../src/cloudflare/api/endpoints.ts", "../src/cloudflare/api/parse-error.ts", "../src/cloudflare/api/fetch-error.ts", "../src/cloudflare/api/fetch-result.ts", "../src/cloudflare/deployments.ts", "../src/cloudflare/project/get-project.ts", "../__generated__/gql/graphql.ts", "../__generated__/gql/gql.ts", "../src/github/api/client.ts", "../src/github/comment.ts", "../src/github/environment.ts", "../src/github/deployment.ts", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/lowercase-keys.js", "../node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/merge-deep.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/remove-undefined-properties.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/merge.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/add-query-parameters.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/extract-url-variable-names.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/omit.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/util/url-template.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/parse.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/endpoint-with-defaults.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/with-defaults.js", "../node_modules/.pnpm/universal-user-agent@7.0.1/node_modules/universal-user-agent/index.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/version.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/lib/defaults.js", "../node_modules/.pnpm/@octokit-next+endpoint@2.7.0/node_modules/@octokit-next/endpoint/index.js", "../node_modules/.pnpm/@octokit-next+request@2.7.0/node_modules/@octokit-next/request/lib/version.js", "../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs", "../node_modules/.pnpm/@octokit-next+request-error@2.7.0/node_modules/@octokit-next/request-error/index.js", "../node_modules/.pnpm/@octokit-next+request@2.7.0/node_modules/@octokit-next/request/lib/get-buffer-response.js", "../node_modules/.pnpm/@octokit-next+request@2.7.0/node_modules/@octokit-next/request/lib/fetch-wrapper.js", "../node_modules/.pnpm/@octokit-next+request@2.7.0/node_modules/@octokit-next/request/lib/with-defaults.js", "../node_modules/.pnpm/@octokit-next+request@2.7.0/node_modules/@octokit-next/request/index.js", "../node_modules/.pnpm/@octokit-next+auth-token@2.7.0/node_modules/@octokit-next/auth-token/lib/auth.js", "../node_modules/.pnpm/@octokit-next+auth-token@2.7.0/node_modules/@octokit-next/auth-token/lib/with-authorization-prefix.js", "../node_modules/.pnpm/@octokit-next+auth-token@2.7.0/node_modules/@octokit-next/auth-token/lib/hook.js", "../node_modules/.pnpm/@octokit-next+auth-token@2.7.0/node_modules/@octokit-next/auth-token/index.js", "../node_modules/.pnpm/@octokit-next+graphql@2.7.0/node_modules/@octokit-next/graphql/lib/version.js", "../node_modules/.pnpm/@octokit-next+graphql@2.7.0/node_modules/@octokit-next/graphql/lib/error.js", "../node_modules/.pnpm/@octokit-next+graphql@2.7.0/node_modules/@octokit-next/graphql/lib/graphql.js", "../node_modules/.pnpm/@octokit-next+graphql@2.7.0/node_modules/@octokit-next/graphql/lib/with-defaults.js", "../node_modules/.pnpm/@octokit-next+graphql@2.7.0/node_modules/@octokit-next/graphql/index.js", "../node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/register.js", "../node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/add.js", "../node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/remove.js", "../node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/index.js", "../node_modules/.pnpm/@octokit-next+core@2.7.0/node_modules/@octokit-next/core/lib/version.js", "../node_modules/.pnpm/@octokit-next+core@2.7.0/node_modules/@octokit-next/core/index.js", "../src/github/api/paginate.ts", "../src/github/deployments.ts", "../src/delete.ts", "../src/main.ts", "../src/index.ts"],
  "sourcesContent": ["module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n", "module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n", "var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n", "const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n", "'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n", "'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n", "'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n", "'use strict';\nmodule.exports = /^#!(.*)/;\n", "'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n", "'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n", "'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n", "'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n", "'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n", "// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n", "// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n}\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {}\n  }\n} else {\n  var assert = require('assert')\n  var signals = require('./signals.js')\n  var isWin = /^win/i.test(process.platform)\n\n  var EE = require('events')\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter\n  }\n\n  var emitter\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE()\n    emitter.count = 0\n    emitter.emitted = {}\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity)\n    emitter.infinite = true\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {}\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n    if (loaded === false) {\n      load()\n    }\n\n    var ev = 'exit'\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit'\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb)\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload()\n      }\n    }\n    emitter.on(ev, cb)\n\n    return remove\n  }\n\n  var unload = function unload () {\n    if (!loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = false\n\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    })\n    process.emit = originalProcessEmit\n    process.reallyExit = originalProcessReallyExit\n    emitter.count -= 1\n  }\n  module.exports.unload = unload\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true\n    emitter.emit(event, code, signal)\n  }\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {}\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig)\n      if (listeners.length === emitter.count) {\n        unload()\n        emit('exit', null, sig)\n        /* istanbul ignore next */\n        emit('afterexit', null, sig)\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT'\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig)\n      }\n    }\n  })\n\n  module.exports.signals = function () {\n    return signals\n  }\n\n  var loaded = false\n\n  var load = function load () {\n    if (loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1\n\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig])\n        return true\n      } catch (er) {\n        return false\n      }\n    })\n\n    process.emit = processEmit\n    process.reallyExit = processReallyExit\n  }\n  module.exports.load = load\n\n  var originalProcessReallyExit = process.reallyExit\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    process.exitCode = code || /* istanbul ignore next */ 0\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode)\n  }\n\n  var originalProcessEmit = process.emit\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg\n      }\n      var ret = originalProcessEmit.apply(this, arguments)\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null)\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null)\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  }\n}\n", "'use strict';\nconst {PassThrough: PassThroughStream} = require('stream');\n\nmodule.exports = options => {\n\toptions = {...options};\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst isBuffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || isBuffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tstream.on('data', chunk => {\n\t\tchunks.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlength = chunks.length;\n\t\t} else {\n\t\t\tlength += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn chunks;\n\t\t}\n\n\t\treturn isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\t};\n\n\tstream.getBufferedLength = () => length;\n\n\treturn stream;\n};\n", "'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst stream = require('stream');\nconst {promisify} = require('util');\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\tconst stream = bufferStream(options);\n\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tawait streamPipelinePromisified(inputStream, stream);\n\t\t\t\tresolve();\n\t\t\t} catch (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t}\n\t\t})();\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n", "'use strict';\n\nconst { PassThrough } = require('stream');\n\nmodule.exports = function (/*streams...*/) {\n  var sources = []\n  var output  = new PassThrough({objectMode: true})\n\n  output.setMaxListeners(0)\n\n  output.add = add\n  output.isEmpty = isEmpty\n\n  output.on('unpipe', remove)\n\n  Array.prototype.slice.call(arguments).forEach(add)\n\n  return output\n\n  function add (source) {\n    if (Array.isArray(source)) {\n      source.forEach(add)\n      return this\n    }\n\n    sources.push(source);\n    source.once('end', remove.bind(null, source))\n    source.once('error', output.emit.bind(output, 'error'))\n    source.pipe(output, {end: false})\n    return this\n  }\n\n  function isEmpty () {\n    return sources.length == 0;\n  }\n\n  function remove (source) {\n    sources = sources.filter(function (it) { return it !== source })\n    if (!sources.length && output.readable) { output.end() }\n  }\n}\n", "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// pkg/dist-src/index.js\nvar dist_src_exports = {};\n__export(dist_src_exports, {\n  composePaginateRest: () => composePaginateRest,\n  isPaginatingEndpoint: () => isPaginatingEndpoint,\n  paginateRest: () => paginateRest,\n  paginatingEndpoints: () => paginatingEndpoints\n});\nmodule.exports = __toCommonJS(dist_src_exports);\n\n// pkg/dist-src/version.js\nvar VERSION = \"8.0.0\";\n\n// pkg/dist-src/normalize-paginated-list-response.js\nfunction normalizePaginatedListResponse(response) {\n  if (!response.data) {\n    return {\n      ...response,\n      data: []\n    };\n  }\n  const responseNeedsNormalization = \"total_count\" in response.data && !(\"url\" in response.data);\n  if (!responseNeedsNormalization)\n    return response;\n  const incompleteResults = response.data.incomplete_results;\n  const repositorySelection = response.data.repository_selection;\n  const totalCount = response.data.total_count;\n  delete response.data.incomplete_results;\n  delete response.data.repository_selection;\n  delete response.data.total_count;\n  const namespaceKey = Object.keys(response.data)[0];\n  const data = response.data[namespaceKey];\n  response.data = data;\n  if (typeof incompleteResults !== \"undefined\") {\n    response.data.incomplete_results = incompleteResults;\n  }\n  if (typeof repositorySelection !== \"undefined\") {\n    response.data.repository_selection = repositorySelection;\n  }\n  response.data.total_count = totalCount;\n  return response;\n}\n\n// pkg/dist-src/iterator.js\nfunction iterator(octokit, route, parameters) {\n  const options = typeof route === \"function\" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);\n  const requestMethod = typeof route === \"function\" ? route : octokit.request;\n  const method = options.method;\n  const headers = options.headers;\n  let url = options.url;\n  return {\n    [Symbol.asyncIterator]: () => ({\n      async next() {\n        if (!url)\n          return { done: true };\n        try {\n          const response = await requestMethod({ method, url, headers });\n          const normalizedResponse = normalizePaginatedListResponse(response);\n          url = ((normalizedResponse.headers.link || \"\").match(\n            /<([^>]+)>;\\s*rel=\"next\"/\n          ) || [])[1];\n          return { value: normalizedResponse };\n        } catch (error) {\n          if (error.status !== 409)\n            throw error;\n          url = \"\";\n          return {\n            value: {\n              status: 200,\n              headers: {},\n              data: []\n            }\n          };\n        }\n      }\n    })\n  };\n}\n\n// pkg/dist-src/paginate.js\nfunction paginate(octokit, route, parameters, mapFn) {\n  if (typeof parameters === \"function\") {\n    mapFn = parameters;\n    parameters = void 0;\n  }\n  return gather(\n    octokit,\n    [],\n    iterator(octokit, route, parameters)[Symbol.asyncIterator](),\n    mapFn\n  );\n}\nfunction gather(octokit, results, iterator2, mapFn) {\n  return iterator2.next().then((result) => {\n    if (result.done) {\n      return results;\n    }\n    let earlyExit = false;\n    function done() {\n      earlyExit = true;\n    }\n    results = results.concat(\n      mapFn ? mapFn(result.value, done) : result.value.data\n    );\n    if (earlyExit) {\n      return results;\n    }\n    return gather(octokit, results, iterator2, mapFn);\n  });\n}\n\n// pkg/dist-src/compose-paginate.js\nvar composePaginateRest = Object.assign(paginate, {\n  iterator\n});\n\n// pkg/dist-src/generated/paginating-endpoints.js\nvar paginatingEndpoints = [\n  \"GET /app/hook/deliveries\",\n  \"GET /app/installation-requests\",\n  \"GET /app/installations\",\n  \"GET /enterprises/{enterprise}/dependabot/alerts\",\n  \"GET /enterprises/{enterprise}/secret-scanning/alerts\",\n  \"GET /events\",\n  \"GET /gists\",\n  \"GET /gists/public\",\n  \"GET /gists/starred\",\n  \"GET /gists/{gist_id}/comments\",\n  \"GET /gists/{gist_id}/commits\",\n  \"GET /gists/{gist_id}/forks\",\n  \"GET /installation/repositories\",\n  \"GET /issues\",\n  \"GET /licenses\",\n  \"GET /marketplace_listing/plans\",\n  \"GET /marketplace_listing/plans/{plan_id}/accounts\",\n  \"GET /marketplace_listing/stubbed/plans\",\n  \"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\",\n  \"GET /networks/{owner}/{repo}/events\",\n  \"GET /notifications\",\n  \"GET /organizations\",\n  \"GET /organizations/{org}/personal-access-token-requests\",\n  \"GET /organizations/{org}/personal-access-token-requests/{pat_request_id}/repositories\",\n  \"GET /organizations/{org}/personal-access-tokens\",\n  \"GET /organizations/{org}/personal-access-tokens/{pat_id}/repositories\",\n  \"GET /orgs/{org}/actions/cache/usage-by-repository\",\n  \"GET /orgs/{org}/actions/permissions/repositories\",\n  \"GET /orgs/{org}/actions/required_workflows\",\n  \"GET /orgs/{org}/actions/runners\",\n  \"GET /orgs/{org}/actions/secrets\",\n  \"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\",\n  \"GET /orgs/{org}/actions/variables\",\n  \"GET /orgs/{org}/actions/variables/{name}/repositories\",\n  \"GET /orgs/{org}/blocks\",\n  \"GET /orgs/{org}/code-scanning/alerts\",\n  \"GET /orgs/{org}/codespaces\",\n  \"GET /orgs/{org}/codespaces/secrets\",\n  \"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories\",\n  \"GET /orgs/{org}/dependabot/alerts\",\n  \"GET /orgs/{org}/dependabot/secrets\",\n  \"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\",\n  \"GET /orgs/{org}/events\",\n  \"GET /orgs/{org}/failed_invitations\",\n  \"GET /orgs/{org}/hooks\",\n  \"GET /orgs/{org}/hooks/{hook_id}/deliveries\",\n  \"GET /orgs/{org}/installations\",\n  \"GET /orgs/{org}/invitations\",\n  \"GET /orgs/{org}/invitations/{invitation_id}/teams\",\n  \"GET /orgs/{org}/issues\",\n  \"GET /orgs/{org}/members\",\n  \"GET /orgs/{org}/members/{username}/codespaces\",\n  \"GET /orgs/{org}/migrations\",\n  \"GET /orgs/{org}/migrations/{migration_id}/repositories\",\n  \"GET /orgs/{org}/outside_collaborators\",\n  \"GET /orgs/{org}/packages\",\n  \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\",\n  \"GET /orgs/{org}/projects\",\n  \"GET /orgs/{org}/public_members\",\n  \"GET /orgs/{org}/repos\",\n  \"GET /orgs/{org}/rulesets\",\n  \"GET /orgs/{org}/secret-scanning/alerts\",\n  \"GET /orgs/{org}/teams\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\",\n  \"GET /orgs/{org}/teams/{team_slug}/invitations\",\n  \"GET /orgs/{org}/teams/{team_slug}/members\",\n  \"GET /orgs/{org}/teams/{team_slug}/projects\",\n  \"GET /orgs/{org}/teams/{team_slug}/repos\",\n  \"GET /orgs/{org}/teams/{team_slug}/teams\",\n  \"GET /projects/columns/{column_id}/cards\",\n  \"GET /projects/{project_id}/collaborators\",\n  \"GET /projects/{project_id}/columns\",\n  \"GET /repos/{org}/{repo}/actions/required_workflows\",\n  \"GET /repos/{owner}/{repo}/actions/artifacts\",\n  \"GET /repos/{owner}/{repo}/actions/caches\",\n  \"GET /repos/{owner}/{repo}/actions/organization-secrets\",\n  \"GET /repos/{owner}/{repo}/actions/organization-variables\",\n  \"GET /repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs\",\n  \"GET /repos/{owner}/{repo}/actions/runners\",\n  \"GET /repos/{owner}/{repo}/actions/runs\",\n  \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\",\n  \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\",\n  \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\",\n  \"GET /repos/{owner}/{repo}/actions/secrets\",\n  \"GET /repos/{owner}/{repo}/actions/variables\",\n  \"GET /repos/{owner}/{repo}/actions/workflows\",\n  \"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\",\n  \"GET /repos/{owner}/{repo}/assignees\",\n  \"GET /repos/{owner}/{repo}/branches\",\n  \"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\",\n  \"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\",\n  \"GET /repos/{owner}/{repo}/code-scanning/alerts\",\n  \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\",\n  \"GET /repos/{owner}/{repo}/code-scanning/analyses\",\n  \"GET /repos/{owner}/{repo}/codespaces\",\n  \"GET /repos/{owner}/{repo}/codespaces/devcontainers\",\n  \"GET /repos/{owner}/{repo}/codespaces/secrets\",\n  \"GET /repos/{owner}/{repo}/collaborators\",\n  \"GET /repos/{owner}/{repo}/comments\",\n  \"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/commits\",\n  \"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\",\n  \"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/status\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/statuses\",\n  \"GET /repos/{owner}/{repo}/contributors\",\n  \"GET /repos/{owner}/{repo}/dependabot/alerts\",\n  \"GET /repos/{owner}/{repo}/dependabot/secrets\",\n  \"GET /repos/{owner}/{repo}/deployments\",\n  \"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\",\n  \"GET /repos/{owner}/{repo}/environments\",\n  \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies\",\n  \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps\",\n  \"GET /repos/{owner}/{repo}/events\",\n  \"GET /repos/{owner}/{repo}/forks\",\n  \"GET /repos/{owner}/{repo}/hooks\",\n  \"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\",\n  \"GET /repos/{owner}/{repo}/invitations\",\n  \"GET /repos/{owner}/{repo}/issues\",\n  \"GET /repos/{owner}/{repo}/issues/comments\",\n  \"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/issues/events\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/events\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\",\n  \"GET /repos/{owner}/{repo}/keys\",\n  \"GET /repos/{owner}/{repo}/labels\",\n  \"GET /repos/{owner}/{repo}/milestones\",\n  \"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\",\n  \"GET /repos/{owner}/{repo}/notifications\",\n  \"GET /repos/{owner}/{repo}/pages/builds\",\n  \"GET /repos/{owner}/{repo}/projects\",\n  \"GET /repos/{owner}/{repo}/pulls\",\n  \"GET /repos/{owner}/{repo}/pulls/comments\",\n  \"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\",\n  \"GET /repos/{owner}/{repo}/releases\",\n  \"GET /repos/{owner}/{repo}/releases/{release_id}/assets\",\n  \"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/rules/branches/{branch}\",\n  \"GET /repos/{owner}/{repo}/rulesets\",\n  \"GET /repos/{owner}/{repo}/secret-scanning/alerts\",\n  \"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\",\n  \"GET /repos/{owner}/{repo}/security-advisories\",\n  \"GET /repos/{owner}/{repo}/stargazers\",\n  \"GET /repos/{owner}/{repo}/subscribers\",\n  \"GET /repos/{owner}/{repo}/tags\",\n  \"GET /repos/{owner}/{repo}/teams\",\n  \"GET /repos/{owner}/{repo}/topics\",\n  \"GET /repositories\",\n  \"GET /repositories/{repository_id}/environments/{environment_name}/secrets\",\n  \"GET /repositories/{repository_id}/environments/{environment_name}/variables\",\n  \"GET /search/code\",\n  \"GET /search/commits\",\n  \"GET /search/issues\",\n  \"GET /search/labels\",\n  \"GET /search/repositories\",\n  \"GET /search/topics\",\n  \"GET /search/users\",\n  \"GET /teams/{team_id}/discussions\",\n  \"GET /teams/{team_id}/discussions/{discussion_number}/comments\",\n  \"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions\",\n  \"GET /teams/{team_id}/discussions/{discussion_number}/reactions\",\n  \"GET /teams/{team_id}/invitations\",\n  \"GET /teams/{team_id}/members\",\n  \"GET /teams/{team_id}/projects\",\n  \"GET /teams/{team_id}/repos\",\n  \"GET /teams/{team_id}/teams\",\n  \"GET /user/blocks\",\n  \"GET /user/codespaces\",\n  \"GET /user/codespaces/secrets\",\n  \"GET /user/emails\",\n  \"GET /user/followers\",\n  \"GET /user/following\",\n  \"GET /user/gpg_keys\",\n  \"GET /user/installations\",\n  \"GET /user/installations/{installation_id}/repositories\",\n  \"GET /user/issues\",\n  \"GET /user/keys\",\n  \"GET /user/marketplace_purchases\",\n  \"GET /user/marketplace_purchases/stubbed\",\n  \"GET /user/memberships/orgs\",\n  \"GET /user/migrations\",\n  \"GET /user/migrations/{migration_id}/repositories\",\n  \"GET /user/orgs\",\n  \"GET /user/packages\",\n  \"GET /user/packages/{package_type}/{package_name}/versions\",\n  \"GET /user/public_emails\",\n  \"GET /user/repos\",\n  \"GET /user/repository_invitations\",\n  \"GET /user/social_accounts\",\n  \"GET /user/ssh_signing_keys\",\n  \"GET /user/starred\",\n  \"GET /user/subscriptions\",\n  \"GET /user/teams\",\n  \"GET /users\",\n  \"GET /users/{username}/events\",\n  \"GET /users/{username}/events/orgs/{org}\",\n  \"GET /users/{username}/events/public\",\n  \"GET /users/{username}/followers\",\n  \"GET /users/{username}/following\",\n  \"GET /users/{username}/gists\",\n  \"GET /users/{username}/gpg_keys\",\n  \"GET /users/{username}/keys\",\n  \"GET /users/{username}/orgs\",\n  \"GET /users/{username}/packages\",\n  \"GET /users/{username}/projects\",\n  \"GET /users/{username}/received_events\",\n  \"GET /users/{username}/received_events/public\",\n  \"GET /users/{username}/repos\",\n  \"GET /users/{username}/social_accounts\",\n  \"GET /users/{username}/ssh_signing_keys\",\n  \"GET /users/{username}/starred\",\n  \"GET /users/{username}/subscriptions\"\n];\n\n// pkg/dist-src/paginating-endpoints.js\nfunction isPaginatingEndpoint(arg) {\n  if (typeof arg === \"string\") {\n    return paginatingEndpoints.includes(arg);\n  } else {\n    return false;\n  }\n}\n\n// pkg/dist-src/index.js\nfunction paginateRest(octokit) {\n  return {\n    paginate: Object.assign(paginate.bind(null, octokit), {\n      iterator: iterator.bind(null, octokit)\n    })\n  };\n}\npaginateRest.VERSION = VERSION;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  composePaginateRest,\n  isPaginatingEndpoint,\n  paginateRest,\n  paginatingEndpoints\n});\n", "import type {InputOptions} from './types.js'\n\nimport {EOL} from 'node:os'\nimport {delimiter} from 'node:path'\n\nimport {issue, issueCommand} from './lib/command.js'\nimport {issueFileCommand, prepareKeyValueMessage} from './lib/file-command.js'\nimport {toCommandValue} from './lib/utils.js'\n\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const exportVariable = (name: string, val: any): void => {\n  const convertedVal = toCommandValue(val)\n  process.env[name] = convertedVal\n\n  const filePath = process.env['GITHUB_ENV'] || ''\n  if (filePath) {\n    return issueFileCommand('ENV', prepareKeyValueMessage(name, val))\n  }\n\n  issueCommand('set-env', {name}, convertedVal)\n}\n\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nexport const setSecret = (secret: string): void => {\n  issueCommand('add-mask', {}, secret)\n}\n\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nexport const addPath = (inputPath: string): void => {\n  const filePath = process.env['GITHUB_PATH'] || ''\n  if (filePath) {\n    issueFileCommand('PATH', inputPath)\n  } else {\n    issueCommand('add-path', {}, inputPath)\n  }\n  process.env['PATH'] = `${inputPath}${delimiter}${process.env['PATH']}`\n}\n\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nexport const getInput = (name: string, options?: InputOptions): string => {\n  const val: string =\n    process.env[`INPUT_${name.replaceAll(' ', '_').toUpperCase()}`] || ''\n  if (options && options.required && !val) {\n    throw new Error(`Input required and not supplied: ${name}`)\n  }\n\n  if (options && options.trimWhitespace === false) {\n    return val\n  }\n\n  return val.trim()\n}\n\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nexport const getMultilineInput = (\n  name: string,\n  options?: InputOptions\n): string[] => {\n  const inputs: string[] = getInput(name, options)\n    .split('\\n')\n    .filter(x => x !== '')\n\n  if (options && options.trimWhitespace === false) {\n    return inputs\n  }\n\n  return inputs.map(input => input.trim())\n}\n\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nexport const getBooleanInput = (\n  name: string,\n  options?: InputOptions\n): boolean => {\n  const trueValue = ['true', 'True', 'TRUE']\n  const falseValue = ['false', 'False', 'FALSE']\n  const val = getInput(name, options)\n  if (trueValue.includes(val)) return true\n  if (falseValue.includes(val)) return false\n  throw new TypeError(\n    `Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n      `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``\n  )\n}\n\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const setOutput = (name: string, value: any): void => {\n  const filePath = process.env['GITHUB_OUTPUT'] || ''\n  if (filePath) {\n    return issueFileCommand('OUTPUT', prepareKeyValueMessage(name, value))\n  }\n\n  process.stdout.write(EOL)\n  issueCommand('set-output', {name}, toCommandValue(value))\n}\n\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nexport const setCommandEcho = (enabled: boolean): void => {\n  issue('echo', enabled ? 'on' : 'off')\n}\n", "import type {CommandProperties} from '../types.js'\n\nimport {EOL} from 'node:os'\n\nimport {toCommandValue} from './utils.js'\n\n// For internal use, subject to change.\n\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nexport const issueCommand = (\n  command: string,\n  properties: CommandProperties,\n  message: any\n): void => {\n  const cmd = new Command(command, properties, message)\n  process.stdout.write(cmd.toString() + EOL)\n}\n\nexport const issue = (name: string, message = ''): void => {\n  issueCommand(name, {}, message)\n}\n\nconst CMD_STRING = '::'\n\nclass Command {\n  readonly #command: string\n  readonly #message: string\n  readonly #properties: CommandProperties\n\n  constructor(command: string, properties: CommandProperties, message: string) {\n    if (!command) {\n      command = 'missing.command'\n    }\n\n    this.#command = command\n    this.#properties = properties\n    this.#message = message\n  }\n\n  toString(): string {\n    let cmdStr = CMD_STRING + this.#command\n\n    if (this.#properties && Object.keys(this.#properties).length > 0) {\n      cmdStr += ' '\n      let first = true\n      for (const key in this.#properties) {\n        if (this.#properties.hasOwnProperty(key)) {\n          const val = this.#properties[key]\n          if (val) {\n            if (first) {\n              first = false\n            } else {\n              cmdStr += ','\n            }\n\n            cmdStr += `${key}=${escapeProperty(val)}`\n          }\n        }\n      }\n    }\n\n    cmdStr += `${CMD_STRING}${escapeData(this.#message)}`\n    return cmdStr\n  }\n}\n\nfunction escapeData(s: any): string {\n  return toCommandValue(s)\n    .replaceAll('%', '%25')\n    .replaceAll('\\r', '%0D')\n    .replaceAll('\\n', '%0A')\n}\n\nfunction escapeProperty(s: any): string {\n  return toCommandValue(s)\n    .replaceAll('%', '%25')\n    .replaceAll('\\r', '%0D')\n    .replaceAll('\\n', '%0A')\n    .replaceAll(':', '%3A')\n    .replaceAll(',', '%2C')\n}\n", "// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type {AnnotationProperties, CommandProperties} from '../types.js'\n\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nexport const toCommandValue = (input: any): string => {\n  if (input === null || input === undefined) {\n    return ''\n  } else if (typeof input === 'string' || input instanceof String) {\n    return input as string\n  }\n  return JSON.stringify(input)\n}\n\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nexport const toCommandProperties = (\n  annotationProperties: AnnotationProperties\n): CommandProperties => {\n  if (!annotationProperties || Object.keys(annotationProperties).length === 0) {\n    return {}\n  }\n\n  return {\n    title: annotationProperties.title,\n    file: annotationProperties.file,\n    line: annotationProperties.startLine,\n    endLine: annotationProperties.endLine,\n    col: annotationProperties.startColumn,\n    endColumn: annotationProperties.endColumn\n  }\n}\n", "// For internal use, subject to change.\n\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {randomUUID as uuidv4} from 'node:crypto'\nimport {appendFileSync, existsSync} from 'node:fs'\nimport {EOL} from 'node:os'\n\nimport {toCommandValue} from './utils.js'\n\nexport const issueFileCommand = (command: string, message: any): void => {\n  const filePath = process.env[`GITHUB_${command}`]\n  if (!filePath) {\n    throw new Error(\n      `Unable to find environment variable for file command ${command}`\n    )\n  }\n  if (!existsSync(filePath)) {\n    throw new Error(`Missing file at path: ${filePath}`)\n  }\n\n  appendFileSync(filePath, `${toCommandValue(message)}${EOL}`, {\n    encoding: 'utf8'\n  })\n}\n\nexport const prepareKeyValueMessage = (key: string, value: any): string => {\n  const delimiter = `ghadelimiter_${uuidv4()}`\n  const convertedValue = toCommandValue(value)\n\n  // These should realistically never happen, but just in case someone finds a\n  // way to exploit uuid generation let's not allow keys or values that contain\n  // the delimiter.\n  if (key.includes(delimiter)) {\n    throw new Error(\n      `Unexpected input: name should not contain the delimiter \"${delimiter}\"`\n    )\n  }\n\n  if (convertedValue.includes(delimiter)) {\n    throw new Error(\n      `Unexpected input: value should not contain the delimiter \"${delimiter}\"`\n    )\n  }\n\n  return `${key}<<${delimiter}${EOL}${convertedValue}${EOL}${delimiter}`\n}\n", "/**\n * Interface for getInput options\n */\nexport interface InputOptions {\n  /** Optional. Whether the input is required. If required and not present, will throw. Defaults to false */\n  required?: boolean\n\n  /** Optional. Whether leading/trailing whitespace will be trimmed for the input. Defaults to true */\n  trimWhitespace?: boolean\n}\n\n/**\n * The code to exit an action\n */\nexport enum ExitCode {\n  /**\n   * A code indicating that the action was successful\n   */\n  Success = 0,\n\n  /**\n   * A code indicating that the action was a failure\n   */\n  Failure = 1\n}\n\n/**\n * Optional properties that can be sent with annotation commands (notice, error, and warning)\n * See: https://docs.github.com/en/rest/reference/checks#create-a-check-run for more information about annotations.\n */\nexport interface AnnotationProperties {\n  /**\n   * A title for the annotation.\n   */\n  title?: string\n\n  /**\n   * The path of the file for which the annotation should be created.\n   */\n  file?: string\n\n  /**\n   * The start line for the annotation.\n   */\n  startLine?: number\n\n  /**\n   * The end line for the annotation. Defaults to `startLine` when `startLine` is provided.\n   */\n  endLine?: number\n\n  /**\n   * The start column for the annotation. Cannot be sent when `startLine` and `endLine` are different values.\n   */\n  startColumn?: number\n\n  /**\n   * The end column for the annotation. Cannot be sent when `startLine` and `endLine` are different values.\n   * Defaults to `startColumn` when `startColumn` is provided.\n   */\n  endColumn?: number\n}\n\nexport interface CommandProperties {\n  [key: string]: unknown\n}\n", "import type {AnnotationProperties} from './types.js'\n\nimport {issueCommand} from './lib/command.js'\nimport {toCommandProperties} from './lib/utils.js'\nimport {ExitCode} from './types.js'\n\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport const error = (\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void => {\n  issueCommand(\n    'error',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nexport const setFailed = (message: string | Error): void => {\n  process.exitCode = ExitCode.Failure\n\n  error(message)\n}\n", "import {EOL} from 'node:os'\n\nimport {issue, issueCommand} from './lib/command.js'\nimport {toCommandProperties} from './lib/utils.js'\nimport {type AnnotationProperties} from './types.js'\n\n/**\n * Gets whether Actions Step Debug is on or not\n */\nexport const isDebug = (): boolean => {\n  return process.env['RUNNER_DEBUG'] === '1'\n}\n\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nexport const debug = (message: string): void => {\n  issueCommand('debug', {}, message)\n}\n\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport const warning = (\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void => {\n  issueCommand(\n    'warning',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport const notice = (\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void => {\n  issueCommand(\n    'notice',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nexport const info = (message: string): void => {\n  process.stdout.write(message + EOL)\n}\n\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nexport const startGroup = (name: string): void => {\n  issue('group', name)\n}\n\n/**\n * End an output group.\n */\nexport const endGroup = (): void => {\n  issue('endgroup')\n}\n\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nexport const group = async <T>(\n  name: string,\n  fn: () => Promise<T>\n): Promise<T> => {\n  startGroup(name)\n\n  let result: T\n\n  try {\n    result = await fn()\n  } finally {\n    endGroup()\n  }\n\n  return result\n}\n", "/* eslint-disable unicorn/no-null */\n\nimport {constants, promises} from 'node:fs'\nimport {EOL} from 'node:os'\n\nconst {access, appendFile, writeFile} = promises\n\nexport const SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY'\nexport const SUMMARY_DOCS_URL =\n  'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary'\n\nexport type SummaryTableRow = (SummaryTableCell | string)[]\n\nexport interface SummaryTableCell {\n  /**\n   * Cell content\n   */\n  data: string\n  /**\n   * Render cell as header\n   * (optional) default: false\n   */\n  header?: boolean\n  /**\n   * Number of columns the cell extends\n   * (optional) default: '1'\n   */\n  colspan?: string\n  /**\n   * Number of rows the cell extends\n   * (optional) default: '1'\n   */\n  rowspan?: string\n}\n\nexport interface SummaryImageOptions {\n  /**\n   * The width of the image in pixels. Must be an integer without a unit.\n   * (optional)\n   */\n  width?: string\n  /**\n   * The height of the image in pixels. Must be an integer without a unit.\n   * (optional)\n   */\n  height?: string\n}\n\nexport interface SummaryWriteOptions {\n  /**\n   * Replace all existing content in summary file with buffer contents\n   * (optional) default: false\n   */\n  overwrite?: boolean\n}\n\nclass Summary {\n  #buffer: string\n  #filePath?: string\n\n  constructor() {\n    this.#buffer = ''\n  }\n\n  /**\n   * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n   * Also checks r/w permissions.\n   *\n   * @returns step summary file path\n   */\n  async #fileSummaryPath(): Promise<string> {\n    if (this.#filePath) {\n      return this.#filePath\n    }\n\n    const pathFromEnv = process.env[SUMMARY_ENV_VAR]\n    if (!pathFromEnv) {\n      throw new Error(\n        `Unable to find environment variable for $${SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`\n      )\n    }\n\n    try {\n      await access(pathFromEnv, constants.R_OK | constants.W_OK)\n    } catch {\n      throw new Error(\n        `Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`\n      )\n    }\n\n    this.#filePath = pathFromEnv\n    return this.#filePath\n  }\n\n  /**\n   * Wraps content in an HTML tag, adding any HTML attributes\n   *\n   * @param {string} tag HTML tag to wrap\n   * @param {string | null} content content within the tag\n   * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n   *\n   * @returns {string} content wrapped in HTML element\n   */\n  #wrap(\n    tag: string,\n    content: string | null,\n    attrs: {[attribute: string]: string} = {}\n  ): string {\n    const htmlAttrs = Object.entries(attrs)\n      .map(([key, value]) => ` ${key}=\"${value}\"`)\n      .join('')\n\n    if (!content) {\n      return `<${tag}${htmlAttrs}>`\n    }\n\n    return `<${tag}${htmlAttrs}>${content}</${tag}>`\n  }\n\n  /**\n   * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n   *\n   * @param {SummaryWriteOptions} [options] (optional) options for write operation\n   *\n   * @returns {Promise<Summary>} summary instance\n   */\n  async write(options?: SummaryWriteOptions): Promise<Summary> {\n    const overwrite = !!options?.overwrite\n    const filePath = await this.#fileSummaryPath()\n    const writeFunc = overwrite ? writeFile : appendFile\n    await writeFunc(filePath, this.#buffer, {encoding: 'utf8'})\n    return this.emptyBuffer()\n  }\n\n  /**\n   * Clears the summary buffer and wipes the summary file\n   *\n   * @returns {Summary} summary instance\n   */\n  async clear(): Promise<Summary> {\n    return this.emptyBuffer().write({overwrite: true})\n  }\n\n  /**\n   * Returns the current summary buffer as a string\n   *\n   * @returns {string} string of summary buffer\n   */\n  stringify(): string {\n    return this.#buffer\n  }\n\n  /**\n   * If the summary buffer is empty\n   *\n   * @returns {boolen} true if the buffer is empty\n   */\n  isEmptyBuffer(): boolean {\n    return this.#buffer.length === 0\n  }\n\n  /**\n   * Resets the summary buffer without writing to summary file\n   *\n   * @returns {Summary} summary instance\n   */\n  emptyBuffer(): Summary {\n    this.#buffer = ''\n    return this\n  }\n\n  /**\n   * Adds raw text to the summary buffer\n   *\n   * @param {string} text content to add\n   * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n   *\n   * @returns {Summary} summary instance\n   */\n  addRaw(text: string, addEOL = false): Summary {\n    this.#buffer += text\n    return addEOL ? this.addEOL() : this\n  }\n\n  /**\n   * Adds the operating system-specific end-of-line marker to the buffer\n   *\n   * @returns {Summary} summary instance\n   */\n  addEOL(): Summary {\n    return this.addRaw(EOL)\n  }\n\n  /**\n   * Adds an HTML codeblock to the summary buffer\n   *\n   * @param {string} code content to render within fenced code block\n   * @param {string} lang (optional) language to syntax highlight code\n   *\n   * @returns {Summary} summary instance\n   */\n  addCodeBlock(code: string, lang?: string): Summary {\n    const attrs = {\n      ...(lang && {lang})\n    }\n    const element = this.#wrap('pre', this.#wrap('code', code), attrs)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML list to the summary buffer\n   *\n   * @param {string[]} items list of items to render\n   * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n   *\n   * @returns {Summary} summary instance\n   */\n  addList(items: string[], ordered = false): Summary {\n    const tag = ordered ? 'ol' : 'ul'\n    const listItems = items.map(item => this.#wrap('li', item)).join('')\n    const element = this.#wrap(tag, listItems)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML table to the summary buffer\n   *\n   * @param {SummaryTableCell[]} rows table rows\n   *\n   * @returns {Summary} summary instance\n   */\n  addTable(rows: SummaryTableRow[]): Summary {\n    const tableBody = rows\n      .map(row => {\n        const cells = row\n          .map(cell => {\n            if (typeof cell === 'string') {\n              return this.#wrap('td', cell)\n            }\n\n            const {header, data, colspan, rowspan} = cell\n            const tag = header ? 'th' : 'td'\n            const attrs = {\n              ...(colspan && {colspan}),\n              ...(rowspan && {rowspan})\n            }\n\n            return this.#wrap(tag, data, attrs)\n          })\n          .join('')\n\n        return this.#wrap('tr', cells)\n      })\n      .join('')\n\n    const element = this.#wrap('table', tableBody)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds a collapsable HTML details element to the summary buffer\n   *\n   * @param {string} label text for the closed state\n   * @param {string} content collapsable content\n   *\n   * @returns {Summary} summary instance\n   */\n  addDetails(label: string, content: string): Summary {\n    const element = this.#wrap(\n      'details',\n      this.#wrap('summary', label) + content\n    )\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML image tag to the summary buffer\n   *\n   * @param {string} src path to the image you to embed\n   * @param {string} alt text description of the image\n   * @param {SummaryImageOptions} options (optional) addition image attributes\n   *\n   * @returns {Summary} summary instance\n   */\n  addImage(src: string, alt: string, options?: SummaryImageOptions): Summary {\n    const {width, height} = options || {}\n    const attrs = {\n      ...(width && {width}),\n      ...(height && {height})\n    }\n\n    const element = this.#wrap('img', null, {src, alt, ...attrs})\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML section heading element\n   *\n   * @param {string} text heading text\n   * @param {number | string} [level=1] (optional) the heading level, default: 1\n   *\n   * @returns {Summary} summary instance\n   */\n  addHeading(text: string, level?: number | string): Summary {\n    const tag = `h${level}`\n    const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n      ? tag\n      : 'h1'\n    const element = this.#wrap(allowedTag, text)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML thematic break (<hr>) to the summary buffer\n   *\n   * @returns {Summary} summary instance\n   */\n  addSeparator(): Summary {\n    const element = this.#wrap('hr', null)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML line break (<br>) to the summary buffer\n   *\n   * @returns {Summary} summary instance\n   */\n  addBreak(): Summary {\n    const element = this.#wrap('br', null)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML blockquote to the summary buffer\n   *\n   * @param {string} text quote text\n   * @param {string} cite (optional) citation url\n   *\n   * @returns {Summary} summary instance\n   */\n  addQuote(text: string, cite?: string): Summary {\n    const attrs = {\n      ...(cite && {cite})\n    }\n    const element = this.#wrap('blockquote', text, attrs)\n    return this.addRaw(element).addEOL()\n  }\n\n  /**\n   * Adds an HTML anchor tag to the summary buffer\n   *\n   * @param {string} text link text/content\n   * @param {string} href hyperlink\n   *\n   * @returns {Summary} summary instance\n   */\n  addLink(text: string, href: string): Summary {\n    const element = this.#wrap('a', text, {href})\n    return this.addRaw(element).addEOL()\n  }\n}\n\nconst _summary = new Summary()\n\nexport const summary = _summary\n", "import {Buffer} from 'node:buffer';\nimport path from 'node:path';\nimport childProcess from 'node:child_process';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport stripFinalNewline from 'strip-final-newline';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport onetime from 'onetime';\nimport {makeError} from './lib/error.js';\nimport {normalizeStdio, normalizeStdioNode} from './lib/stdio.js';\nimport {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} from './lib/kill.js';\nimport {addPipeMethods} from './lib/pipe.js';\nimport {handleInput, getSpawnedResult, makeAllStream, handleInputSync} from './lib/stream.js';\nimport {mergePromise, getSpawnedPromise} from './lib/promise.js';\nimport {joinCommand, parseCommand, parseTemplates, getEscapedCommand} from './lib/command.js';\nimport {logCommand, verboseDefault} from './lib/verbose.js';\n\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal) {\n\t\treturn npmRunPathEnv({env, cwd: localDir, execPath});\n\t}\n\n\treturn env;\n};\n\nconst handleArguments = (file, args, options = {}) => {\n\tconst parsed = crossSpawn._parse(file, args, options);\n\tfile = parsed.command;\n\targs = parsed.args;\n\toptions = parsed.options;\n\n\toptions = {\n\t\tmaxBuffer: DEFAULT_MAX_BUFFER,\n\t\tbuffer: true,\n\t\tstripFinalNewline: true,\n\t\textendEnv: true,\n\t\tpreferLocal: false,\n\t\tlocalDir: options.cwd || process.cwd(),\n\t\texecPath: process.execPath,\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true,\n\t\tall: false,\n\t\twindowsHide: true,\n\t\tverbose: verboseDefault,\n\t\t...options,\n\t};\n\n\toptions.env = getEnv(options);\n\n\toptions.stdio = normalizeStdio(options);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\targs.unshift('/q');\n\t}\n\n\treturn {file, args, options, parsed};\n};\n\nconst handleOutput = (options, value, error) => {\n\tif (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n\t\t// When `execaSync()` errors, we normalize it to '' to mimic `execa()`\n\t\treturn error === undefined ? undefined : '';\n\t}\n\n\tif (options.stripFinalNewline) {\n\t\treturn stripFinalNewline(value);\n\t}\n\n\treturn value;\n};\n\nexport function execa(file, args, options) {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\tlogCommand(escapedCommand, parsed.options);\n\n\tvalidateTimeout(parsed.options);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\t// Ensure the returned error is always both a promise and a child process\n\t\tconst dummySpawned = new childProcess.ChildProcess();\n\t\tconst errorPromise = Promise.reject(makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t}));\n\t\tmergePromise(dummySpawned, errorPromise);\n\t\treturn dummySpawned;\n\t}\n\n\tconst spawnedPromise = getSpawnedPromise(spawned);\n\tconst timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n\tconst processDone = setExitHandler(spawned, parsed.options, timedPromise);\n\n\tconst context = {isCanceled: false};\n\n\tspawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n\tspawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n\tconst handlePromise = async () => {\n\t\tconst [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n\t\tconst stdout = handleOutput(parsed.options, stdoutResult);\n\t\tconst stderr = handleOutput(parsed.options, stderrResult);\n\t\tconst all = handleOutput(parsed.options, allResult);\n\n\t\tif (error || exitCode !== 0 || signal !== null) {\n\t\t\tconst returnedError = makeError({\n\t\t\t\terror,\n\t\t\t\texitCode,\n\t\t\t\tsignal,\n\t\t\t\tstdout,\n\t\t\t\tstderr,\n\t\t\t\tall,\n\t\t\t\tcommand,\n\t\t\t\tescapedCommand,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut,\n\t\t\t\tisCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),\n\t\t\t\tkilled: spawned.killed,\n\t\t\t});\n\n\t\t\tif (!parsed.options.reject) {\n\t\t\t\treturn returnedError;\n\t\t\t}\n\n\t\t\tthrow returnedError;\n\t\t}\n\n\t\treturn {\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\texitCode: 0,\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\tall,\n\t\t\tfailed: false,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t};\n\t};\n\n\tconst handlePromiseOnce = onetime(handlePromise);\n\n\thandleInput(spawned, parsed.options);\n\n\tspawned.all = makeAllStream(spawned, parsed.options);\n\n\taddPipeMethods(spawned);\n\tmergePromise(spawned, handlePromiseOnce);\n\treturn spawned;\n}\n\nexport function execaSync(file, args, options) {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\tlogCommand(escapedCommand, parsed.options);\n\n\tconst input = handleInputSync(parsed.options);\n\n\tlet result;\n\ttry {\n\t\tresult = childProcess.spawnSync(parsed.file, parsed.args, {...parsed.options, input});\n\t} catch (error) {\n\t\tthrow makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t});\n\t}\n\n\tconst stdout = handleOutput(parsed.options, result.stdout, result.error);\n\tconst stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst error = makeError({\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\terror: result.error,\n\t\t\tsignal: result.signal,\n\t\t\texitCode: result.status,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: result.error && result.error.code === 'ETIMEDOUT',\n\t\t\tisCanceled: false,\n\t\t\tkilled: result.signal !== null,\n\t\t});\n\n\t\tif (!parsed.options.reject) {\n\t\t\treturn error;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\texitCode: 0,\n\t\tstdout,\n\t\tstderr,\n\t\tfailed: false,\n\t\ttimedOut: false,\n\t\tisCanceled: false,\n\t\tkilled: false,\n\t};\n}\n\nconst normalizeScriptStdin = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined\n\t? {stdin: 'inherit'}\n\t: {};\n\nconst normalizeScriptOptions = (options = {}) => ({\n\tpreferLocal: true,\n\t...normalizeScriptStdin(options),\n\t...options,\n});\n\nfunction create$(options) {\n\tfunction $(templatesOrOptions, ...expressions) {\n\t\tif (!Array.isArray(templatesOrOptions)) {\n\t\t\treturn create$({...options, ...templatesOrOptions});\n\t\t}\n\n\t\tconst [file, ...args] = parseTemplates(templatesOrOptions, expressions);\n\t\treturn execa(file, args, normalizeScriptOptions(options));\n\t}\n\n\t$.sync = (templates, ...expressions) => {\n\t\tif (!Array.isArray(templates)) {\n\t\t\tthrow new TypeError('Please use $(options).sync`command` instead of $.sync(options)`command`.');\n\t\t}\n\n\t\tconst [file, ...args] = parseTemplates(templates, expressions);\n\t\treturn execaSync(file, args, normalizeScriptOptions(options));\n\t};\n\n\treturn $;\n}\n\nexport const $ = create$();\n\nexport function execaCommand(command, options) {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa(file, args, options);\n}\n\nexport function execaCommandSync(command, options) {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execaSync(file, args, options);\n}\n\nexport function execaNode(scriptPath, args, options = {}) {\n\tif (args && !Array.isArray(args) && typeof args === 'object') {\n\t\toptions = args;\n\t\targs = [];\n\t}\n\n\tconst stdio = normalizeStdioNode(options);\n\tconst defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));\n\n\tconst {\n\t\tnodePath = process.execPath,\n\t\tnodeOptions = defaultExecArgv,\n\t} = options;\n\n\treturn execa(\n\t\tnodePath,\n\t\t[\n\t\t\t...nodeOptions,\n\t\t\tscriptPath,\n\t\t\t...(Array.isArray(args) ? args : []),\n\t\t],\n\t\t{\n\t\t\t...options,\n\t\t\tstdin: undefined,\n\t\t\tstdout: undefined,\n\t\t\tstderr: undefined,\n\t\t\tstdio,\n\t\t\tshell: false,\n\t\t},\n\t);\n}\n", "export default function stripFinalNewline(input) {\n\tconst LF = typeof input === 'string' ? '\\n' : '\\n'.charCodeAt();\n\tconst CR = typeof input === 'string' ? '\\r' : '\\r'.charCodeAt();\n\n\tif (input[input.length - 1] === LF) {\n\t\tinput = input.slice(0, -1);\n\t}\n\n\tif (input[input.length - 1] === CR) {\n\t\tinput = input.slice(0, -1);\n\t}\n\n\treturn input;\n}\n", "import process from 'node:process';\nimport path from 'node:path';\nimport url from 'node:url';\nimport pathKey from 'path-key';\n\nexport function npmRunPath(options = {}) {\n\tconst {\n\t\tcwd = process.cwd(),\n\t\tpath: path_ = process.env[pathKey()],\n\t\texecPath = process.execPath,\n\t} = options;\n\n\tlet previous;\n\tconst cwdString = cwd instanceof URL ? url.fileURLToPath(cwd) : cwd;\n\tlet cwdPath = path.resolve(cwdString);\n\tconst result = [];\n\n\twhile (previous !== cwdPath) {\n\t\tresult.push(path.join(cwdPath, 'node_modules/.bin'));\n\t\tprevious = cwdPath;\n\t\tcwdPath = path.resolve(cwdPath, '..');\n\t}\n\n\t// Ensure the running `node` binary is used.\n\tresult.push(path.resolve(cwdString, execPath, '..'));\n\n\treturn [...result, path_].join(path.delimiter);\n}\n\nexport function npmRunPathEnv({env = process.env, ...options} = {}) {\n\tenv = {...env};\n\n\tconst path = pathKey({env});\n\toptions.path = env[path];\n\tenv[path] = npmRunPath(options);\n\n\treturn env;\n}\n", "export default function pathKey(options = {}) {\n\tconst {\n\t\tenv = process.env,\n\t\tplatform = process.platform\n\t} = options;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n}\n", "const copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n// - one its descriptors is changed\n// - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nexport default function mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n}\n", "import mimicFunction from 'mimic-fn';\n\nconst calledFunctions = new WeakMap();\n\nconst onetime = (function_, options = {}) => {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError('Expected a function');\n\t}\n\n\tlet returnValue;\n\tlet callCount = 0;\n\tconst functionName = function_.displayName || function_.name || '<anonymous>';\n\n\tconst onetime = function (...arguments_) {\n\t\tcalledFunctions.set(onetime, ++callCount);\n\n\t\tif (callCount === 1) {\n\t\t\treturnValue = function_.apply(this, arguments_);\n\t\t\tfunction_ = null;\n\t\t} else if (options.throw === true) {\n\t\t\tthrow new Error(`Function \\`${functionName}\\` can only be called once`);\n\t\t}\n\n\t\treturn returnValue;\n\t};\n\n\tmimicFunction(onetime, function_);\n\tcalledFunctions.set(onetime, callCount);\n\n\treturn onetime;\n};\n\nonetime.callCount = function_ => {\n\tif (!calledFunctions.has(function_)) {\n\t\tthrow new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n\t}\n\n\treturn calledFunctions.get(function_);\n};\n\nexport default onetime;\n", "import{constants}from\"node:os\";\n\nimport{SIGRTMAX}from\"./realtime.js\";\nimport{getSignals}from\"./signals.js\";\n\n\n\nconst getSignalsByName=()=>{\nconst signals=getSignals();\nreturn Object.fromEntries(signals.map(getSignalByName));\n};\n\nconst getSignalByName=({\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n})=>[name,{name,number,description,supported,action,forced,standard}];\n\nexport const signalsByName=getSignalsByName();\n\n\n\n\nconst getSignalsByNumber=()=>{\nconst signals=getSignals();\nconst length=SIGRTMAX+1;\nconst signalsA=Array.from({length},(value,number)=>\ngetSignalByNumber(number,signals));\n\nreturn Object.assign({},...signalsA);\n};\n\nconst getSignalByNumber=(number,signals)=>{\nconst signal=findSignalByNumber(number,signals);\n\nif(signal===undefined){\nreturn{};\n}\n\nconst{name,description,supported,action,forced,standard}=signal;\nreturn{\n[number]:{\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n}\n};\n};\n\n\n\nconst findSignalByNumber=(number,signals)=>{\nconst signal=signals.find(({name})=>constants.signals[name]===number);\n\nif(signal!==undefined){\nreturn signal;\n}\n\nreturn signals.find((signalA)=>signalA.number===number);\n};\n\nexport const signalsByNumber=getSignalsByNumber();", "\nexport const getRealtimeSignals=()=>{\nconst length=SIGRTMAX-SIGRTMIN+1;\nreturn Array.from({length},getRealtimeSignal);\n};\n\nconst getRealtimeSignal=(value,index)=>({\nname:`SIGRT${index+1}`,\nnumber:SIGRTMIN+index,\naction:\"terminate\",\ndescription:\"Application-specific signal (realtime)\",\nstandard:\"posix\"\n});\n\nconst SIGRTMIN=34;\nexport const SIGRTMAX=64;", "import{constants}from\"node:os\";\n\nimport{SIGNALS}from\"./core.js\";\nimport{getRealtimeSignals}from\"./realtime.js\";\n\n\n\nexport const getSignals=()=>{\nconst realtimeSignals=getRealtimeSignals();\nconst signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal);\nreturn signals;\n};\n\n\n\n\n\n\n\nconst normalizeSignal=({\nname,\nnumber:defaultNumber,\ndescription,\naction,\nforced=false,\nstandard\n})=>{\nconst{\nsignals:{[name]:constantSignal}\n}=constants;\nconst supported=constantSignal!==undefined;\nconst number=supported?constantSignal:defaultNumber;\nreturn{name,number,description,supported,action,forced,standard};\n};", "\n\nexport const SIGNALS=[\n{\nname:\"SIGHUP\",\nnumber:1,\naction:\"terminate\",\ndescription:\"Terminal closed\",\nstandard:\"posix\"\n},\n{\nname:\"SIGINT\",\nnumber:2,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-C\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGQUIT\",\nnumber:3,\naction:\"core\",\ndescription:\"User interruption with CTRL-\\\\\",\nstandard:\"posix\"\n},\n{\nname:\"SIGILL\",\nnumber:4,\naction:\"core\",\ndescription:\"Invalid machine instruction\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGTRAP\",\nnumber:5,\naction:\"core\",\ndescription:\"Debugger breakpoint\",\nstandard:\"posix\"\n},\n{\nname:\"SIGABRT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGIOT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGBUS\",\nnumber:7,\naction:\"core\",\ndescription:\n\"Bus error due to misaligned, non-existing address or paging error\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGEMT\",\nnumber:7,\naction:\"terminate\",\ndescription:\"Command should be emulated but is not implemented\",\nstandard:\"other\"\n},\n{\nname:\"SIGFPE\",\nnumber:8,\naction:\"core\",\ndescription:\"Floating point arithmetic error\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGKILL\",\nnumber:9,\naction:\"terminate\",\ndescription:\"Forced termination\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGUSR1\",\nnumber:10,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGSEGV\",\nnumber:11,\naction:\"core\",\ndescription:\"Segmentation fault\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGUSR2\",\nnumber:12,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGPIPE\",\nnumber:13,\naction:\"terminate\",\ndescription:\"Broken pipe or socket\",\nstandard:\"posix\"\n},\n{\nname:\"SIGALRM\",\nnumber:14,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTERM\",\nnumber:15,\naction:\"terminate\",\ndescription:\"Termination\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGSTKFLT\",\nnumber:16,\naction:\"terminate\",\ndescription:\"Stack is empty or overflowed\",\nstandard:\"other\"\n},\n{\nname:\"SIGCHLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"posix\"\n},\n{\nname:\"SIGCLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"other\"\n},\n{\nname:\"SIGCONT\",\nnumber:18,\naction:\"unpause\",\ndescription:\"Unpaused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGSTOP\",\nnumber:19,\naction:\"pause\",\ndescription:\"Paused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGTSTP\",\nnumber:20,\naction:\"pause\",\ndescription:\"Paused using CTRL-Z or \\\"suspend\\\"\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTTIN\",\nnumber:21,\naction:\"pause\",\ndescription:\"Background process cannot read terminal input\",\nstandard:\"posix\"\n},\n{\nname:\"SIGBREAK\",\nnumber:21,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-BREAK\",\nstandard:\"other\"\n},\n{\nname:\"SIGTTOU\",\nnumber:22,\naction:\"pause\",\ndescription:\"Background process cannot write to terminal output\",\nstandard:\"posix\"\n},\n{\nname:\"SIGURG\",\nnumber:23,\naction:\"ignore\",\ndescription:\"Socket received out-of-band data\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXCPU\",\nnumber:24,\naction:\"core\",\ndescription:\"Process timed out\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXFSZ\",\nnumber:25,\naction:\"core\",\ndescription:\"File too big\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGVTALRM\",\nnumber:26,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGPROF\",\nnumber:27,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGWINCH\",\nnumber:28,\naction:\"ignore\",\ndescription:\"Terminal window size changed\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGIO\",\nnumber:29,\naction:\"terminate\",\ndescription:\"I/O is available\",\nstandard:\"other\"\n},\n{\nname:\"SIGPOLL\",\nnumber:29,\naction:\"terminate\",\ndescription:\"Watched event\",\nstandard:\"other\"\n},\n{\nname:\"SIGINFO\",\nnumber:29,\naction:\"ignore\",\ndescription:\"Request for process information\",\nstandard:\"other\"\n},\n{\nname:\"SIGPWR\",\nnumber:30,\naction:\"terminate\",\ndescription:\"Device running out of power\",\nstandard:\"systemv\"\n},\n{\nname:\"SIGSYS\",\nnumber:31,\naction:\"core\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n},\n{\nname:\"SIGUNUSED\",\nnumber:31,\naction:\"terminate\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n}];", "import {signalsByName} from 'human-signals';\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nexport const makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}},\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n", "const aliases = ['stdin', 'stdout', 'stderr'];\n\nconst hasAlias = options => aliases.some(alias => options[alias] !== undefined);\n\nexport const normalizeStdio = options => {\n\tif (!options) {\n\t\treturn;\n\t}\n\n\tconst {stdio} = options;\n\n\tif (stdio === undefined) {\n\t\treturn aliases.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn stdio;\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, aliases.length);\n\treturn Array.from({length}, (value, index) => stdio[index]);\n};\n\n// `ipc` is pushed unless it is already present\nexport const normalizeStdioNode = options => {\n\tconst stdio = normalizeStdio(options);\n\n\tif (stdio === 'ipc') {\n\t\treturn 'ipc';\n\t}\n\n\tif (stdio === undefined || typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio, 'ipc'];\n\t}\n\n\tif (stdio.includes('ipc')) {\n\t\treturn stdio;\n\t}\n\n\treturn [...stdio, 'ipc'];\n};\n", "import os from 'node:os';\nimport onExit from 'signal-exit';\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nexport const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n\nconst isSigterm = signal => signal === os.constants.signals.SIGTERM\n\t\t|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nexport const spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nexport const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nexport const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n", "import {createWriteStream} from 'node:fs';\nimport {ChildProcess} from 'node:child_process';\nimport {isWritableStream} from 'is-stream';\n\nconst isExecaChildProcess = target => target instanceof ChildProcess && typeof target.then === 'function';\n\nconst pipeToTarget = (spawned, streamName, target) => {\n\tif (typeof target === 'string') {\n\t\tspawned[streamName].pipe(createWriteStream(target));\n\t\treturn spawned;\n\t}\n\n\tif (isWritableStream(target)) {\n\t\tspawned[streamName].pipe(target);\n\t\treturn spawned;\n\t}\n\n\tif (!isExecaChildProcess(target)) {\n\t\tthrow new TypeError('The second argument must be a string, a stream or an Execa child process.');\n\t}\n\n\tif (!isWritableStream(target.stdin)) {\n\t\tthrow new TypeError('The target child process\\'s stdin must be available.');\n\t}\n\n\tspawned[streamName].pipe(target.stdin);\n\treturn target;\n};\n\nexport const addPipeMethods = spawned => {\n\tif (spawned.stdout !== null) {\n\t\tspawned.pipeStdout = pipeToTarget.bind(undefined, spawned, 'stdout');\n\t}\n\n\tif (spawned.stderr !== null) {\n\t\tspawned.pipeStderr = pipeToTarget.bind(undefined, spawned, 'stderr');\n\t}\n\n\tif (spawned.all !== undefined) {\n\t\tspawned.pipeAll = pipeToTarget.bind(undefined, spawned, 'all');\n\t}\n};\n", "export function isStream(stream) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& typeof stream.pipe === 'function';\n}\n\nexport function isWritableStream(stream) {\n\treturn isStream(stream)\n\t\t&& stream.writable !== false\n\t\t&& typeof stream._write === 'function'\n\t\t&& typeof stream._writableState === 'object';\n}\n\nexport function isReadableStream(stream) {\n\treturn isStream(stream)\n\t\t&& stream.readable !== false\n\t\t&& typeof stream._read === 'function'\n\t\t&& typeof stream._readableState === 'object';\n}\n\nexport function isDuplexStream(stream) {\n\treturn isWritableStream(stream)\n\t\t&& isReadableStream(stream);\n}\n\nexport function isTransformStream(stream) {\n\treturn isDuplexStream(stream)\n\t\t&& typeof stream._transform === 'function';\n}\n", "import {createReadStream, readFileSync} from 'node:fs';\nimport {isStream} from 'is-stream';\nimport getStream from 'get-stream';\nimport mergeStream from 'merge-stream';\n\nconst validateInputOptions = input => {\n\tif (input !== undefined) {\n\t\tthrow new TypeError('The `input` and `inputFile` options cannot be both set.');\n\t}\n};\n\nconst getInputSync = ({input, inputFile}) => {\n\tif (typeof inputFile !== 'string') {\n\t\treturn input;\n\t}\n\n\tvalidateInputOptions(input);\n\treturn readFileSync(inputFile);\n};\n\n// `input` and `inputFile` option in sync mode\nexport const handleInputSync = options => {\n\tconst input = getInputSync(options);\n\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n\n\treturn input;\n};\n\nconst getInput = ({input, inputFile}) => {\n\tif (typeof inputFile !== 'string') {\n\t\treturn input;\n\t}\n\n\tvalidateInputOptions(input);\n\treturn createReadStream(inputFile);\n};\n\n// `input` and `inputFile` option in async mode\nexport const handleInput = (spawned, options) => {\n\tconst input = getInput(options);\n\n\tif (input === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\t// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\n\tif (!stream || streamPromise === undefined) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nexport const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise),\n\t\t]);\n\t}\n};\n", "// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nexport const mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function'\n\t\t\t? (...args) => Reflect.apply(descriptor.value, promise(), args)\n\t\t\t: descriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n};\n\n// Use promises instead of `child_process` events\nexport const getSpawnedPromise = spawned => new Promise((resolve, reject) => {\n\tspawned.on('exit', (exitCode, signal) => {\n\t\tresolve({exitCode, signal});\n\t});\n\n\tspawned.on('error', error => {\n\t\treject(error);\n\t});\n\n\tif (spawned.stdin) {\n\t\tspawned.stdin.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\t}\n});\n", "import {Buffer} from 'node:buffer';\nimport {ChildProcess} from 'node:child_process';\n\nconst normalizeArgs = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn [file];\n\t}\n\n\treturn [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n\tif (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n\t\treturn arg;\n\t}\n\n\treturn `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nexport const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');\n\nexport const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execaCommand()`\nexport const parseCommand = command => {\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens[tokens.length - 1];\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nconst parseExpression = expression => {\n\tconst typeOfExpression = typeof expression;\n\n\tif (typeOfExpression === 'string') {\n\t\treturn expression;\n\t}\n\n\tif (typeOfExpression === 'number') {\n\t\treturn String(expression);\n\t}\n\n\tif (\n\t\ttypeOfExpression === 'object'\n\t\t&& expression !== null\n\t\t&& !(expression instanceof ChildProcess)\n\t\t&& 'stdout' in expression\n\t) {\n\t\tconst typeOfStdout = typeof expression.stdout;\n\n\t\tif (typeOfStdout === 'string') {\n\t\t\treturn expression.stdout;\n\t\t}\n\n\t\tif (Buffer.isBuffer(expression.stdout)) {\n\t\t\treturn expression.stdout.toString();\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected \"${typeOfStdout}\" stdout in template expression`);\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\n\nconst concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0\n\t? [...tokens, ...nextTokens]\n\t: [\n\t\t...tokens.slice(0, -1),\n\t\t`${tokens[tokens.length - 1]}${nextTokens[0]}`,\n\t\t...nextTokens.slice(1),\n\t];\n\nconst parseTemplate = ({templates, expressions, tokens, index, template}) => {\n\tconst templateString = template ?? templates.raw[index];\n\tconst templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);\n\tconst newTokens = concatTokens(\n\t\ttokens,\n\t\ttemplateTokens,\n\t\ttemplateString.startsWith(' '),\n\t);\n\n\tif (index === expressions.length) {\n\t\treturn newTokens;\n\t}\n\n\tconst expression = expressions[index];\n\tconst expressionTokens = Array.isArray(expression)\n\t\t? expression.map(expression => parseExpression(expression))\n\t\t: [parseExpression(expression)];\n\treturn concatTokens(\n\t\tnewTokens,\n\t\texpressionTokens,\n\t\ttemplateString.endsWith(' '),\n\t);\n};\n\nexport const parseTemplates = (templates, expressions) => {\n\tlet tokens = [];\n\n\tfor (const [index, template] of templates.entries()) {\n\t\ttokens = parseTemplate({templates, expressions, tokens, index, template});\n\t}\n\n\treturn tokens;\n};\n\n", "import {debuglog} from 'node:util';\nimport process from 'node:process';\n\nexport const verboseDefault = debuglog('execa').enabled;\n\nconst padField = (field, padding) => String(field).padStart(padding, '0');\n\nconst getTimestamp = () => {\n\tconst date = new Date();\n\treturn `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;\n};\n\nexport const logCommand = (escapedCommand, {verbose}) => {\n\tif (!verbose) {\n\t\treturn;\n\t}\n\n\tprocess.stderr.write(`[${getTimestamp()}] ${escapedCommand}\\n`);\n};\n", "/**\n * GitHub Action Input\n */\n\n/** GitHub Action Input key - Cloudflare Account Id */\nexport const ACTION_INPUT_ACCOUNT_ID = 'accountId'\n/** GitHub Action Input key - Cloudflare Pages Project Name */\nexport const ACTION_INPUT_PROJECT_NAME = 'projectName'\n/** GitHub Action Input key - Cloudflare API token */\nexport const ACTION_INPUT_API_TOKEN = 'apiToken'\n/** GitHub Action Input key = Directory of static files to upload */\nexport const ACTION_INPUT_DIRECTORY = 'directory'\nexport const ACTION_INPUT_GITHUB_TOKEN = 'githubToken'\nexport const ACTION_INPUT_GITHUB_ENVIRONMENT = 'github environment'\n/**\n * Environment variables\n */\n\n/** Environment variables key for Cloudflare wrangler */\nexport const CLOUDFLARE_API_TOKEN = 'CLOUDFLARE_API_TOKEN'\n/** Environment variables key for Cloudflare wrangler */\nexport const CLOUDFLARE_ACCOUNT_ID = 'CLOUDFLARE_ACCOUNT_ID'\n", "export const raise = (message: string): never => {\n  throw new Error(message)\n}\n", "import {strict as assert} from 'node:assert'\nimport {existsSync, readFileSync} from 'node:fs'\nimport {EOL} from 'node:os'\n\nimport {debug, isDebug} from '@unlike/github-actions-core'\n\nimport type {EventName} from '@/types/github/workflow-events.js'\nimport {EVENT_NAMES} from '@/types/github/workflow-events.js'\n\nimport type {WorkflowEventExtract, WorkflowEventPayload} from './types.js'\n\n/**\n * Loads the file from the runner that contains the full event webhook payload.\n */\nconst getPayload = (): unknown => {\n  if (process.env.GITHUB_EVENT_PATH) {\n    if (existsSync(process.env.GITHUB_EVENT_PATH)) {\n      return JSON.parse(\n        readFileSync(process.env.GITHUB_EVENT_PATH, {encoding: 'utf8'})\n      )\n    } else {\n      const path = process.env.GITHUB_EVENT_PATH\n      process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${EOL}`)\n    }\n  }\n}\n\nexport const getWorkflowEvent = () => {\n  const eventName = process.env.GITHUB_EVENT_NAME as EventName\n\n  assert(\n    EVENT_NAMES.includes(eventName),\n    `eventName ${eventName} is not supported`\n  )\n  /** Assume that the payload matches the eventName */\n  const payload = getPayload() as WorkflowEventPayload<typeof eventName>\n\n  if (isDebug()) {\n    debug(`eventName: ${eventName}`)\n    debug(`payload: ${JSON.stringify(payload)}`)\n  }\n\n  return {\n    eventName,\n    payload\n  } as Readonly<WorkflowEventExtract<typeof eventName>>\n}\n", "import type {\n  BranchProtectionRuleEvent,\n  CheckRunEvent,\n  CheckSuiteEvent,\n  CodeScanningAlertEvent,\n  CommitCommentEvent,\n  CreateEvent,\n  DeleteEvent,\n  DependabotAlertEvent,\n  DeployKeyEvent,\n  DeploymentEvent,\n  DeploymentProtectionRuleEvent,\n  DeploymentStatusEvent,\n  DiscussionCommentEvent,\n  DiscussionEvent,\n  ForkEvent,\n  GithubAppAuthorizationEvent,\n  GollumEvent,\n  InstallationEvent,\n  InstallationRepositoriesEvent,\n  InstallationTargetEvent,\n  IssueCommentEvent,\n  IssuesEvent,\n  LabelEvent,\n  MarketplacePurchaseEvent,\n  MemberEvent,\n  MembershipEvent,\n  MergeGroupEvent,\n  MetaEvent,\n  MilestoneEvent,\n  OrganizationEvent,\n  OrgBlockEvent,\n  PackageEvent,\n  PageBuildEvent,\n  PingEvent,\n  ProjectCardEvent,\n  ProjectColumnEvent,\n  ProjectEvent,\n  ProjectsV2ItemEvent,\n  PublicEvent,\n  PullRequestEvent,\n  PullRequestReviewCommentEvent,\n  PullRequestReviewEvent,\n  PullRequestReviewThreadEvent,\n  PushEvent,\n  RegistryPackageEvent,\n  ReleaseEvent,\n  RepositoryDispatchEvent,\n  RepositoryEvent,\n  RepositoryImportEvent,\n  RepositoryVulnerabilityAlertEvent,\n  Schema,\n  SecretScanningAlertEvent,\n  SecretScanningAlertLocationEvent,\n  SecurityAdvisoryEvent,\n  SponsorshipEvent,\n  StarEvent,\n  StatusEvent,\n  TeamAddEvent,\n  TeamEvent,\n  WatchEvent,\n  WebhookEventName,\n  WorkflowDispatchEvent,\n  WorkflowJobEvent,\n  WorkflowRunEvent\n} from '@octokit/webhooks-types'\n\nexport const EVENT_NAMES = [\n  'branch_protection_rule',\n  'check_run',\n  'check_suite',\n  'code_scanning_alert',\n  'commit_comment',\n  'create',\n  'delete',\n  'dependabot_alert',\n  'deploy_key',\n  'deployment',\n  'deployment_protection_rule',\n  'deployment_status',\n  'discussion',\n  'discussion_comment',\n  'fork',\n  'github_app_authorization',\n  'gollum',\n  'installation',\n  'installation_repositories',\n  'installation_target',\n  'issue_comment',\n  'issues',\n  'label',\n  'marketplace_purchase',\n  'member',\n  'membership',\n  'merge_group',\n  'meta',\n  'milestone',\n  'org_block',\n  'organization',\n  'package',\n  'page_build',\n  'ping',\n  'project',\n  'project_card',\n  'project_column',\n  'projects_v2_item',\n  'public',\n  'pull_request',\n  'pull_request_review',\n  'pull_request_review_comment',\n  'pull_request_review_thread',\n  'push',\n  'registry_package',\n  'release',\n  'repository',\n  'repository_dispatch',\n  'repository_import',\n  'repository_vulnerability_alert',\n  'secret_scanning_alert',\n  'secret_scanning_alert_location',\n  'security_advisory',\n  'sponsorship',\n  'star',\n  'status',\n  'team',\n  'team_add',\n  'watch',\n  'workflow_dispatch',\n  'workflow_job',\n  'workflow_run'\n] satisfies Array<WebhookEventName>\nexport type EventName = (typeof EVENT_NAMES)[number]\nexport interface WorkflowEventBase {\n  eventName: WebhookEventName\n  payload: Schema\n}\nexport type WorkflowEvent =\n  | {\n      eventName: 'branch_protection_rule'\n      payload: BranchProtectionRuleEvent\n    }\n  | {\n      eventName: 'check_run'\n      payload: CheckRunEvent\n    }\n  | {\n      eventName: 'check_suite'\n      payload: CheckSuiteEvent\n    }\n  | {\n      eventName: 'code_scanning_alert'\n      payload: CodeScanningAlertEvent\n    }\n  | {\n      eventName: 'commit_comment'\n      payload: CommitCommentEvent\n    }\n  | {\n      eventName: 'create'\n      payload: CreateEvent\n    }\n  | {\n      eventName: 'delete'\n      payload: DeleteEvent\n    }\n  | {\n      eventName: 'dependabot_alert'\n      payload: DependabotAlertEvent\n    }\n  | {\n      eventName: 'deploy_key'\n      payload: DeployKeyEvent\n    }\n  | {\n      eventName: 'deployment'\n      payload: DeploymentEvent\n    }\n  | {\n      eventName: 'deployment_protection_rule'\n      payload: DeploymentProtectionRuleEvent\n    }\n  | {\n      eventName: 'deployment_status'\n      payload: DeploymentStatusEvent\n    }\n  | {\n      eventName: 'discussion'\n      payload: DiscussionEvent\n    }\n  | {\n      eventName: 'discussion_comment'\n      payload: DiscussionCommentEvent\n    }\n  | {\n      eventName: 'fork'\n      payload: ForkEvent\n    }\n  | {\n      eventName: 'github_app_authorization'\n      payload: GithubAppAuthorizationEvent\n    }\n  | {\n      eventName: 'gollum'\n      payload: GollumEvent\n    }\n  | {\n      eventName: 'installation'\n      payload: InstallationEvent\n    }\n  | {\n      eventName: 'installation_repositories'\n      payload: InstallationRepositoriesEvent\n    }\n  | {\n      eventName: 'installation_target'\n      payload: InstallationTargetEvent\n    }\n  | {\n      eventName: 'issue_comment'\n      payload: IssueCommentEvent\n    }\n  | {\n      eventName: 'issues'\n      payload: IssuesEvent\n    }\n  | {\n      eventName: 'label'\n      payload: LabelEvent\n    }\n  | {\n      eventName: 'marketplace_purchase'\n      payload: MarketplacePurchaseEvent\n    }\n  | {\n      eventName: 'member'\n      payload: MemberEvent\n    }\n  | {\n      eventName: 'membership'\n      payload: MembershipEvent\n    }\n  | {\n      eventName: 'merge_group'\n      payload: MergeGroupEvent\n    }\n  | {\n      eventName: 'meta'\n      payload: MetaEvent\n    }\n  | {\n      eventName: 'milestone'\n      payload: MilestoneEvent\n    }\n  | {\n      eventName: 'org_block'\n      payload: OrgBlockEvent\n    }\n  | {\n      eventName: 'organization'\n      payload: OrganizationEvent\n    }\n  | {\n      eventName: 'package'\n      payload: PackageEvent\n    }\n  | {\n      eventName: 'page_build'\n      payload: PageBuildEvent\n    }\n  | {\n      eventName: 'ping'\n      payload: PingEvent\n    }\n  | {\n      eventName: 'project'\n      payload: ProjectEvent\n    }\n  | {\n      eventName: 'project_card'\n      payload: ProjectCardEvent\n    }\n  | {\n      eventName: 'project_column'\n      payload: ProjectColumnEvent\n    }\n  | {\n      eventName: 'projects_v2_item'\n      payload: ProjectsV2ItemEvent\n    }\n  | {\n      eventName: 'public'\n      payload: PublicEvent\n    }\n  | {\n      eventName: 'pull_request'\n      payload: PullRequestEvent\n    }\n  | {\n      eventName: 'pull_request_review'\n      payload: PullRequestReviewEvent\n    }\n  | {\n      eventName: 'pull_request_review_comment'\n      payload: PullRequestReviewCommentEvent\n    }\n  | {\n      eventName: 'pull_request_review_thread'\n      payload: PullRequestReviewThreadEvent\n    }\n  | {\n      eventName: 'push'\n      payload: PushEvent\n    }\n  | {\n      eventName: 'registry_package'\n      payload: RegistryPackageEvent\n    }\n  | {\n      eventName: 'release'\n      payload: ReleaseEvent\n    }\n  | {\n      eventName: 'repository'\n      payload: RepositoryEvent\n    }\n  | {\n      eventName: 'repository_dispatch'\n      payload: RepositoryDispatchEvent\n    }\n  | {\n      eventName: 'repository_import'\n      payload: RepositoryImportEvent\n    }\n  | {\n      eventName: 'repository_vulnerability_alert'\n      payload: RepositoryVulnerabilityAlertEvent\n    }\n  | {\n      eventName: 'secret_scanning_alert'\n      payload: SecretScanningAlertEvent\n    }\n  | {\n      eventName: 'secret_scanning_alert_location'\n      payload: SecretScanningAlertLocationEvent\n    }\n  | {\n      eventName: 'security_advisory'\n      payload: SecurityAdvisoryEvent\n    }\n  | {\n      eventName: 'sponsorship'\n      payload: SponsorshipEvent\n    }\n  | {\n      eventName: 'star'\n      payload: StarEvent\n    }\n  | {\n      eventName: 'status'\n      payload: StatusEvent\n    }\n  | {\n      eventName: 'team'\n      payload: TeamEvent\n    }\n  | {\n      eventName: 'team_add'\n      payload: TeamAddEvent\n    }\n  | {\n      eventName: 'watch'\n      payload: WatchEvent\n    }\n  | {\n      eventName: 'workflow_dispatch'\n      payload: WorkflowDispatchEvent\n    }\n  | {\n      eventName: 'workflow_job'\n      payload: WorkflowJobEvent\n    }\n  | {\n      eventName: 'workflow_run'\n      payload: WorkflowRunEvent\n    }\n", "/* eslint-disable no-console */\n\nimport {debug, isDebug} from '@unlike/github-actions-core'\n\nimport {raise} from '../utils.js'\nimport {getWorkflowEvent} from './workflow-event/workflow-event.js'\n\ninterface Repo {\n  owner: string\n  repo: string\n  /**\n   * The GraphQL identifier of the repository.\n   */\n  node_id: string\n}\n\ninterface Context {\n  /**\n   * The event that triggered the workflow run.\n   */\n  event: ReturnType<typeof getWorkflowEvent>\n  repo: Repo\n  /**\n   * The branch or tag ref that triggered the workflow run.\n   */\n  branch?: string\n  /**\n   * The commit SHA that triggered the workflow. The value of this commit SHA\n   * depends on the event that triggered the workflow.\n   * For more information, see \"Events that trigger workflows.\"\n   *\n   * Example: `ffac537e6cbbf934b08745a378932722df287a53`.\n   */\n  sha: string\n  /**\n   * Returns the GraphQL API URL. For example: https://api.github.com/graphql.\n   */\n  graphqlEndpoint: string\n\n  /**\n   * refs/heads/feature-branch-1.\n   */\n  ref: string\n}\n\nconst getGitHubContext = (): Context => {\n  const event = getWorkflowEvent()\n\n  const repo = ((): Repo => {\n    const [owner, repo] = process.env.GITHUB_REPOSITORY\n      ? process.env.GITHUB_REPOSITORY.split('/')\n      : raise(\n          \"context.repo: requires a GITHUB_REPOSITORY environment variable like 'owner/repo'\"\n        )\n\n    const node_id =\n      'repository' in event.payload\n        ? event.payload.repository?.node_id ||\n          raise('context.repo: no repo node_id in payload')\n        : raise('context.repo: no repo node_id in payload')\n\n    return {owner, repo, node_id}\n  })()\n\n  /**\n   * Depending on what event triggers the action.\n   * The GITHUB_HEAD_REF may be undefined so we fallback to GITHUB_REF_NAME.\n   */\n  const branch = process.env.GITHUB_HEAD_REF || process.env.GITHUB_REF_NAME\n\n  const sha = process.env.GITHUB_SHA\n\n  const graphqlEndpoint = process.env.GITHUB_GRAPHQL_URL\n\n  const ref = ((): Context['ref'] => {\n    let ref = process.env.GITHUB_HEAD_REF\n    if (!ref) {\n      if ('ref' in event.payload) {\n        ref = event.payload.ref // refs/heads/feature-branch-1\n      } else if (event.eventName === 'pull_request') {\n        ref = event.payload.pull_request.head.ref // andykenward/issue18\n      }\n      if (!ref) return raise('context: no ref')\n    }\n    return ref\n  })()\n\n  const context = {\n    event,\n    repo,\n    branch,\n    sha,\n    graphqlEndpoint,\n    ref\n  }\n\n  if (isDebug()) {\n    const debugContext = {\n      ...context,\n      event: 'will debug itself as output is large'\n    }\n\n    debug(`context: ${JSON.stringify(debugContext)}`)\n  }\n\n  return context\n}\n\ntype UseContext = ReturnType<typeof getGitHubContext>\n\nlet _context: UseContext\nexport const useContext = (): UseContext => {\n  return _context ?? (_context = getGitHubContext())\n}\n\nexport const useContextEvent = (): UseContext['event'] => useContext().event\n", "import {getInput} from '@unlike/github-actions-core'\n\nimport {\n  ACTION_INPUT_ACCOUNT_ID,\n  ACTION_INPUT_PROJECT_NAME\n} from '../../constants.js'\n\nconst API_ENDPOINT = `https://api.cloudflare.com`\n\nexport const getCloudflareApiEndpoint = (path?: string): string => {\n  const accountIdentifier = getInput(ACTION_INPUT_ACCOUNT_ID, {\n    required: true\n  })\n  const projectName = getInput(ACTION_INPUT_PROJECT_NAME, {required: true})\n\n  const input: string = [\n    `/client/v4/accounts/${accountIdentifier}/pages/projects/${projectName}`,\n    path\n  ]\n    .filter(Boolean)\n    .join('/')\n\n  return new URL(input, API_ENDPOINT).toString()\n}\n\nexport const getCloudflareLogEndpoint = (id: string): string => {\n  const accountIdentifier = getInput(ACTION_INPUT_ACCOUNT_ID, {\n    required: true\n  })\n  const projectName = getInput(ACTION_INPUT_PROJECT_NAME, {required: true})\n\n  return `https://dash.cloudflare.com/${accountIdentifier}/pages/view/${projectName}/${id}`\n}\n", "/**\n * Fork of\n * https://github.com/cloudflare/workers-sdk/blob/55703e52da35b15f5c11f9e3936cc5b1ad5836dc/packages/wrangler/src/parse.ts\n */\n\nexport type Message = {\n  text: string\n  location?: Location\n  notes?: Message[]\n  kind?: 'warning' | 'error'\n}\n\nexport type Location = File & {\n  line: number\n  column: number\n  length?: number\n  lineText?: string\n  suggestion?: string\n}\n\nexport type File = {\n  file?: string\n  fileText?: string\n}\n\n/**\n * An error that's thrown when something fails to parse.\n */\nexport class ParseError extends Error implements Message {\n  readonly text: string\n  readonly notes: Message[]\n  readonly location?: Location\n  readonly kind: 'warning' | 'error'\n\n  constructor({text, notes, location, kind}: Message) {\n    super(text)\n    // eslint-disable-next-line unicorn/custom-error-definition\n    this.name = this.constructor.name\n    this.text = text\n    this.notes = notes ?? []\n    this.location = location\n    this.kind = kind ?? 'error'\n  }\n}\n", "import {error as coreError} from '@unlike/github-actions-core'\n\nimport type {FetchError, FetchResult} from '../types.js'\nimport {ParseError} from './parse-error.js'\n\n/**\n * Source: https://github.com/cloudflare/workers-sdk/blob/55703e52da35b15f5c11f9e3936cc5b1ad5836dc/packages/wrangler/src/cfetch/index.ts#L83-L101\n */\nexport function throwFetchError(\n  resource: string,\n  response: FetchResult<unknown>\n): never {\n  const error = new ParseError({\n    text: `A request to the Cloudflare API (${resource}) failed.`,\n    notes: response.errors.map(err => ({\n      text: renderError(err)\n    }))\n  })\n  // add the first error code directly to this error\n  // so consumers can use it for specific behaviour\n  const code = response.errors[0]?.code\n  if (code) {\n    // TODO: Does cloudflare have a schema for their codes?\n    //@ts-expect-error non-standard property on Error\n    error.code = code\n  }\n  if (error.notes?.length > 0) {\n    error.notes.map(note => {\n      // GitHub Action annotation\n      coreError(`Cloudflare API: ${note.text}`)\n    })\n  }\n  throw error\n}\n\n/**\n * Source: https://github.com/cloudflare/workers-sdk/blob/55703e52da35b15f5c11f9e3936cc5b1ad5836dc/packages/wrangler/src/cfetch/index.ts#L108-L120\n */\nfunction renderError(err: FetchError, level = 0): string {\n  const chainedMessages =\n    err.error_chain\n      ?.map(\n        chainedError =>\n          `\\n${'  '.repeat(level)}- ${renderError(chainedError, level + 1)}`\n      )\n      .join('\\n') ?? ''\n  return (\n    (err.code ? `${err.message} [code: ${err.code}]` : err.message) +\n    chainedMessages\n  )\n}\n", "import type {RequestInit} from 'undici'\n\nimport {getInput} from '@unlike/github-actions-core'\n\nimport type {FetchResult} from '../types.js'\nimport {ACTION_INPUT_API_TOKEN} from '../../constants.js'\nimport {throwFetchError} from './fetch-error.js'\n\nexport const fetchResult = async <ResponseType>(\n  resource: string,\n  init: RequestInit = {},\n  queryParams?: URLSearchParams,\n  abortSignal?: AbortSignal\n): Promise<ResponseType> => {\n  const method = init.method ?? 'GET'\n  const apiToken = getInput(ACTION_INPUT_API_TOKEN, {required: true})\n\n  const initFetch = {\n    headers: {\n      'Content-Type': 'application/json;charset=UTF-8',\n      Authorization: `Bearer ${apiToken}`\n    }\n  }\n\n  const response = (await fetch(resource, {\n    method,\n    ...initFetch,\n    signal: abortSignal\n  }).then(response => response.json())) as FetchResult<ResponseType>\n\n  if (response.success) {\n    if (response.result === null || response.result === undefined) {\n      throw new Error(`Cloudflare API: response missing 'result'`)\n    }\n    return response.result\n  } else {\n    throwFetchError(resource, response)\n  }\n}\n\nexport const fetchSuccess = async (\n  resource: string,\n  init: RequestInit = {}\n): Promise<boolean> => {\n  const method = init.method ?? 'GET'\n  const apiToken = getInput(ACTION_INPUT_API_TOKEN, {required: true})\n\n  const initFetch = {\n    headers: {\n      'Content-Type': 'application/json;charset=UTF-8',\n      Authorization: `Bearer ${apiToken}`\n    }\n  }\n\n  const response = (await fetch(resource, {\n    method,\n    ...initFetch\n  }).then(response => response.json())) as FetchResult<null>\n\n  return response.success\n}\n", "import {error, getInput, setOutput, summary} from '@unlike/github-actions-core'\nimport {$} from 'execa'\n\nimport type {PagesDeployment} from './types.js'\nimport {\n  ACTION_INPUT_ACCOUNT_ID,\n  ACTION_INPUT_API_TOKEN,\n  ACTION_INPUT_DIRECTORY,\n  ACTION_INPUT_PROJECT_NAME,\n  CLOUDFLARE_ACCOUNT_ID,\n  CLOUDFLARE_API_TOKEN\n} from '../constants.js'\nimport {useContext} from '../github/context.js'\nimport {getCloudflareApiEndpoint} from './api/endpoints.js'\nimport {fetchResult, fetchSuccess} from './api/fetch-result.js'\n\nconst ERROR_KEY = `Create Deployment:`\n\nconst getDeployments = async (): Promise<Array<PagesDeployment>> => {\n  const url = getCloudflareApiEndpoint('deployments')\n\n  const result = await fetchResult<Array<PagesDeployment>>(url)\n\n  return result\n}\n\nexport const deleteDeployment = async (\n  deploymentIdentifier: string\n): Promise<boolean> => {\n  const url = getCloudflareApiEndpoint(\n    `deployments/${deploymentIdentifier}?force=true`\n  )\n\n  try {\n    const result = await fetchSuccess(url, {\n      method: 'DELETE'\n    })\n\n    if (result === true) {\n      return true\n    }\n    throw new Error('Cloudflare Delete Deployment: fail')\n  } catch {\n    error(`Error deleting deployment: ${deploymentIdentifier}`)\n    return false\n  }\n}\n\nexport const getDeploymentAlias = (deployment: PagesDeployment): string => {\n  return deployment.aliases && deployment.aliases.length > 0\n    ? deployment.aliases[0]\n    : deployment.url\n}\n\nexport const createDeployment = async () => {\n  const accountId = getInput(ACTION_INPUT_ACCOUNT_ID, {\n    required: true\n  })\n  const projectName = getInput(ACTION_INPUT_PROJECT_NAME, {\n    required: true\n  })\n  const directory = getInput(ACTION_INPUT_DIRECTORY, {\n    required: true\n  })\n  const apiToken = getInput(ACTION_INPUT_API_TOKEN, {\n    required: true\n  })\n\n  process.env[CLOUDFLARE_API_TOKEN] = apiToken\n  process.env[CLOUDFLARE_ACCOUNT_ID] = accountId\n\n  const {repo, branch, sha: commitHash} = useContext()\n\n  if (branch === undefined) {\n    throw new Error(`${ERROR_KEY} branch is undefined`)\n  }\n\n  try {\n    /**\n     * Tried to use wrangler.unstable_pages.deploy. But wrangler is 8mb+ and the bundler is unable to tree shake it.\n     */\n    await $`npx wrangler@3.1.1 pages deploy ${directory} --project-name=${projectName} --branch=${branch} --commit-dirty=true --commit-hash=${commitHash}`\n\n    /**\n     * Get the latest deployment by commitHash.\n     */\n    const deployments = await getDeployments()\n    const deployment = deployments?.find(\n      deployment =>\n        deployment.deployment_trigger.metadata.commit_hash === commitHash\n    )\n\n    if (deployment === undefined) {\n      throw new Error(\n        `${ERROR_KEY} could not find deployment with commitHash: ${commitHash}`\n      )\n    }\n\n    setOutput('id', deployment.id)\n    setOutput('url', deployment.url)\n    setOutput('environment', deployment.environment)\n\n    const alias: string = getDeploymentAlias(deployment)\n    setOutput('alias', alias)\n\n    const deployStage = deployment.stages.find(stage => stage.name === 'deploy')\n\n    await summary.addHeading('Cloudflare Pages Deployment').write()\n    await summary.addBreak().write()\n    await summary\n      .addTable([\n        [\n          {\n            data: 'Name',\n            header: true\n          },\n          {\n            data: 'Result',\n            header: true\n          }\n        ],\n        ['Environment:', deployment.environment],\n        [\n          'Branch:',\n          `<a href='https://github.com/${repo.owner}/${repo.repo}/tree/${deployment.deployment_trigger.metadata.branch}'><code>${deployment.deployment_trigger.metadata.branch}</code></a>`\n        ],\n        [\n          'Commit Hash:',\n          `<a href='https://github.com/${repo.owner}/${repo.repo}/commit/${deployment.deployment_trigger.metadata.commit_hash}'><code>${deployment.deployment_trigger.metadata.commit_hash}</code></a>`\n        ],\n        [\n          'Commit Message:',\n          deployment.deployment_trigger.metadata.commit_message\n        ],\n        [\n          'Status:',\n          `<strong>${deployStage?.status.toUpperCase() || `UNKNOWN`}</strong>`\n        ],\n        ['Preview URL:', `<a href='${deployment.url}'>${deployment.url}</a>`],\n        ['Branch Preview URL:', `<a href='${alias}'>${alias}</a>`]\n      ])\n      .write()\n\n    return deployment\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error\n    }\n    if (\n      error &&\n      typeof error === 'object' &&\n      'stderr' in error &&\n      typeof error.stderr === 'string'\n    ) {\n      throw new Error(error.stderr)\n    }\n    throw new Error(`${ERROR_KEY} unknown error`)\n  }\n}\n", "import type {Project} from '@cloudflare/types'\n\nimport {getCloudflareApiEndpoint} from '../api/endpoints.js'\nimport {fetchResult} from '../api/fetch-result.js'\n\n/**\n * Get Cloudfalre Pages project\n * https://developers.cloudflare.com/api/operations/pages-project-get-project\n */\nexport const getProject = async (): Promise<Project> => {\n  const url = getCloudflareApiEndpoint()\n\n  const result = await fetchResult<Project>(url)\n\n  return result\n}\n", "/* eslint-disable */\nimport type { DocumentTypeDecoration } from '@graphql-typed-document-node/core';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n  /** A (potentially binary) string encoded using base64. */\n  Base64String: { input: any; output: any; }\n  /**\n   * Represents non-fractional signed whole numeric values. Since the value may\n   * exceed the size of a 32-bit integer, it's encoded as a string.\n   */\n  BigInt: { input: any; output: any; }\n  /** An ISO-8601 encoded date string. */\n  Date: { input: any; output: any; }\n  /** An ISO-8601 encoded UTC date string. */\n  DateTime: { input: any; output: any; }\n  /** A Git object ID. */\n  GitObjectID: { input: any; output: any; }\n  /** Git SSH string */\n  GitSSHRemote: { input: any; output: any; }\n  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */\n  GitTimestamp: { input: any; output: any; }\n  /** A string containing HTML code. */\n  HTML: { input: any; output: any; }\n  /** An ISO-8601 encoded UTC date string with millisecond precision. */\n  PreciseDateTime: { input: any; output: any; }\n  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */\n  URI: { input: any; output: any; }\n  /** A valid x509 certificate string */\n  X509Certificate: { input: any; output: any; }\n};\n\n/** Autogenerated input type of AbortQueuedMigrations */\nexport type AbortQueuedMigrationsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the organization that is running the migrations. */\n  ownerId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AbortQueuedMigrations */\nexport type AbortQueuedMigrationsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the invitation being accepted */\n  invitationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The invitation that was accepted. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** A message confirming the result of accepting an administrator invitation. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the suggested topic. */\n  name: Scalars['String']['input'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The accepted topic. */\n  topic?: Maybe<Topic>;\n};\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type Actor = {\n  /** A URL pointing to the actor's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** The username of the actor. */\n  login: Scalars['String']['output'];\n  /** The HTTP path for this actor. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this actor. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type ActorAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Location information for an actor */\nexport type ActorLocation = {\n  /** City */\n  city?: Maybe<Scalars['String']['output']>;\n  /** Country name */\n  country?: Maybe<Scalars['String']['output']>;\n  /** Country code */\n  countryCode?: Maybe<Scalars['String']['output']>;\n  /** Region name */\n  region?: Maybe<Scalars['String']['output']>;\n  /** Region or state code */\n  regionCode?: Maybe<Scalars['String']['output']>;\n};\n\n/** The actor's type. */\nexport enum ActorType {\n  /** Indicates a team actor. */\n  Team = 'TEAM',\n  /** Indicates a user actor. */\n  User = 'USER'\n}\n\n/** Autogenerated input type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignableInput = {\n  /** The id of the assignable object to add assignees to. */\n  assignableId: Scalars['ID']['input'];\n  /** The id of users to add as assignees. */\n  assigneeIds: Array<Scalars['ID']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignablePayload = {\n  /** The item that was assigned. */\n  assignable?: Maybe<Assignable>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of AddComment */\nexport type AddCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddComment */\nexport type AddCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The edge from the subject's comment connection. */\n  commentEdge?: Maybe<IssueCommentEdge>;\n  /** The subject */\n  subject?: Maybe<Node>;\n  /** The edge from the subject's timeline connection. */\n  timelineEdge?: Maybe<IssueTimelineItemEdge>;\n};\n\n/** Autogenerated input type of AddDiscussionComment */\nexport type AddDiscussionCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion to comment on. */\n  discussionId: Scalars['ID']['input'];\n  /** The Node ID of the discussion comment within this discussion to reply to. */\n  replyToId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of AddDiscussionComment */\nexport type AddDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created discussion comment. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of AddDiscussionPollVote */\nexport type AddDiscussionPollVoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion poll option to vote for. */\n  pollOptionId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddDiscussionPollVote */\nexport type AddDiscussionPollVotePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The poll option that a vote was added to. */\n  pollOption?: Maybe<DiscussionPollOption>;\n};\n\n/** Autogenerated input type of AddEnterpriseOrganizationMember */\nexport type AddEnterpriseOrganizationMemberInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise which owns the organization. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The ID of the organization the users will be added to. */\n  organizationId: Scalars['ID']['input'];\n  /** The role to assign the users in the organization */\n  role?: InputMaybe<OrganizationMemberRole>;\n  /** The IDs of the enterprise members to add. */\n  userIds: Array<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of AddEnterpriseOrganizationMember */\nexport type AddEnterpriseOrganizationMemberPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The users who were added to the organization. */\n  users?: Maybe<Array<User>>;\n};\n\n/** Autogenerated input type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of a member who will receive the support entitlement. */\n  login: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of adding the support entitlement. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of AddLabelsToLabelable */\nexport type AddLabelsToLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ids of the labels to add. */\n  labelIds: Array<Scalars['ID']['input']>;\n  /** The id of the labelable object to add labels to. */\n  labelableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddLabelsToLabelable */\nexport type AddLabelsToLabelablePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item that was labeled. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of AddProjectCard */\nexport type AddProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the card. Must be a member of the ProjectCardItem union */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** The note on the card. */\n  note?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the ProjectColumn. */\n  projectColumnId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddProjectCard */\nexport type AddProjectCardPayload = {\n  /** The edge from the ProjectColumn's card connection. */\n  cardEdge?: Maybe<ProjectCardEdge>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The ProjectColumn */\n  projectColumn?: Maybe<ProjectColumn>;\n};\n\n/** Autogenerated input type of AddProjectColumn */\nexport type AddProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the column. */\n  name: Scalars['String']['input'];\n  /** The Node ID of the project. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddProjectColumn */\nexport type AddProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The edge from the project's column connection. */\n  columnEdge?: Maybe<ProjectColumnEdge>;\n  /** The project */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of AddProjectV2DraftIssue */\nexport type AddProjectV2DraftIssueInput = {\n  /** The IDs of the assignees of the draft issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The body of the draft issue. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Project to add the draft issue to. */\n  projectId: Scalars['ID']['input'];\n  /**\n   * The title of the draft issue. A project item can also be created by providing\n   * the URL of an Issue or Pull Request if you have access.\n   */\n  title: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of AddProjectV2DraftIssue */\nexport type AddProjectV2DraftIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The draft issue added to the project. */\n  projectItem?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of AddProjectV2ItemById */\nexport type AddProjectV2ItemByIdInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the Issue or Pull Request to add. */\n  contentId: Scalars['ID']['input'];\n  /** The ID of the Project to add the item to. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddProjectV2ItemById */\nexport type AddProjectV2ItemByIdPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item added to the project. */\n  item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentInput = {\n  /**\n   * The text of the comment. This field is required\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The SHA of the commit to comment on.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;\n  /**\n   * The comment id to reply to.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  inReplyTo?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The relative path of the file to comment on.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  path?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The line index in the diff to comment on.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  position?: InputMaybe<Scalars['Int']['input']>;\n  /**\n   * The node ID of the pull request reviewing\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `pullRequestId` will be removed. use\n   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  pullRequestId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The Node ID of the review to modify.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `pullRequestReviewId` will be removed. use\n   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created comment. */\n  comment?: Maybe<PullRequestReviewComment>;\n  /** The edge from the review's comment connection. */\n  commentEdge?: Maybe<PullRequestReviewCommentEdge>;\n};\n\n/** Autogenerated input type of AddPullRequestReview */\nexport type AddPullRequestReviewInput = {\n  /** The contents of the review body comment. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The review line comments.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `comments` will be removed. use the `threads` argument instead\n   * **Reason:** We are deprecating comment fields that use diff-relative positioning\n   */\n  comments?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewComment>>>;\n  /** The commit OID the review pertains to. */\n  commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;\n  /** The event to perform on the pull request review. */\n  event?: InputMaybe<PullRequestReviewEvent>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID']['input'];\n  /** The review line comment threads. */\n  threads?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewThread>>>;\n};\n\n/** Autogenerated return type of AddPullRequestReview */\nexport type AddPullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** The edge from the pull request's review connection. */\n  reviewEdge?: Maybe<PullRequestReviewEdge>;\n};\n\n/** Autogenerated input type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadInput = {\n  /** Body of the thread's first comment. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The line of the blob to which the thread refers, required for line-level\n   * threads. The end of the line range for multi-line comments.\n   */\n  line?: InputMaybe<Scalars['Int']['input']>;\n  /** Path to the file being commented on. */\n  path: Scalars['String']['input'];\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: InputMaybe<Scalars['ID']['input']>;\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: InputMaybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: InputMaybe<Scalars['Int']['input']>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: InputMaybe<DiffSide>;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType?: InputMaybe<PullRequestReviewThreadSubjectType>;\n};\n\n/** Autogenerated return type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created thread. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Autogenerated input type of AddReaction */\nexport type AddReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the emoji to react with. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddReaction */\nexport type AddReactionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>;\n  /** The reaction groups for the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>;\n};\n\n/** Autogenerated input type of AddStar */\nexport type AddStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Starrable ID to star. */\n  starrableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddStar */\nexport type AddStarPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The starrable. */\n  starrable?: Maybe<Starrable>;\n};\n\n/** Autogenerated input type of AddUpvote */\nexport type AddUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion or comment to upvote. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddUpvote */\nexport type AddUpvotePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The votable subject. */\n  subject?: Maybe<Votable>;\n};\n\n/** Autogenerated input type of AddVerifiableDomain */\nexport type AddVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The URL of the domain */\n  domain: Scalars['URI']['input'];\n  /** The ID of the owner to add the domain to */\n  ownerId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of AddVerifiableDomain */\nexport type AddVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The verifiable domain that was added. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** Represents an 'added_to_merge_queue' event on a given pull request. */\nexport type AddedToMergeQueueEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who added this Pull Request to the merge queue */\n  enqueuer?: Maybe<User>;\n  id: Scalars['ID']['output'];\n  /** The merge queue where this pull request was added to. */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'added_to_project' event on a given issue or pull request. */\nexport type AddedToProjectEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n};\n\n/** Represents an announcement banner. */\nexport type AnnouncementBanner = {\n  /** The text of the announcement */\n  announcement?: Maybe<Scalars['String']['output']>;\n  /** The expiration date of the announcement, if any */\n  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Whether the announcement can be dismissed by the user */\n  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** A GitHub App. */\nexport type App = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The description of the app. */\n  description?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The IP addresses of the app. */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars['String']['output'];\n  /** A URL pointing to the app's logo. */\n  logoUrl: Scalars['URI']['output'];\n  /** The name of the app. */\n  name: Scalars['String']['output'];\n  /** A slug based on the name of the app for use in URLs. */\n  slug: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The URL to the app's homepage. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A GitHub App. */\nexport type AppIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n\n/** A GitHub App. */\nexport type AppLogoUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Autogenerated input type of ApproveDeployments */\nexport type ApproveDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Optional comment for approving deployments */\n  comment?: InputMaybe<Scalars['String']['input']>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']['input']>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ApproveDeployments */\nexport type ApproveDeploymentsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>;\n};\n\n/** Autogenerated input type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the verifiable domain to approve. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The verifiable domain that was approved. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** Autogenerated input type of ArchiveProjectV2Item */\nexport type ArchiveProjectV2ItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the ProjectV2Item to archive. */\n  itemId: Scalars['ID']['input'];\n  /** The ID of the Project to archive the item from. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ArchiveProjectV2Item */\nexport type ArchiveProjectV2ItemPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item archived from the project. */\n  item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of ArchiveRepository */\nexport type ArchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the repository to mark as archived. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ArchiveRepository */\nexport type ArchiveRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository that was marked as archived. */\n  repository?: Maybe<Repository>;\n};\n\n/** An object that can have users assigned to it. */\nexport type Assignable = {\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n};\n\n\n/** An object that can have users assigned to it. */\nexport type AssignableAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Represents an 'assigned' event on any assignable object. */\nexport type AssignedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable;\n  /** Identifies the user or mannequin that was assigned. */\n  assignee?: Maybe<Assignee>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /**\n   * Identifies the user who was assigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>;\n};\n\n/** Types that can be assigned to issues. */\nexport type Assignee = Bot | Mannequin | Organization | User;\n\n/** An entry in the audit log. */\nexport type AuditEntry = {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Types that can initiate an audit log event. */\nexport type AuditEntryActor = Bot | Organization | User;\n\n/** Ordering options for Audit Log connections. */\nexport type AuditLogOrder = {\n  /** The ordering direction. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field to order Audit Logs by. */\n  field?: InputMaybe<AuditLogOrderField>;\n};\n\n/** Properties by which Audit Log connections can be ordered. */\nexport enum AuditLogOrderField {\n  /** Order audit log entries by timestamp */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Represents a 'auto_merge_disabled' event on a given pull request. */\nexport type AutoMergeDisabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who disabled auto-merge for this Pull Request */\n  disabler?: Maybe<User>;\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event */\n  pullRequest?: Maybe<PullRequest>;\n  /** The reason auto-merge was disabled */\n  reason?: Maybe<Scalars['String']['output']>;\n  /** The reason_code relating to why auto-merge was disabled */\n  reasonCode?: Maybe<Scalars['String']['output']>;\n};\n\n/** Represents a 'auto_merge_enabled' event on a given pull request. */\nexport type AutoMergeEnabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who enabled auto-merge for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents an auto-merge request for a pull request */\nexport type AutoMergeRequest = {\n  /** The email address of the author of this auto-merge request. */\n  authorEmail?: Maybe<Scalars['String']['output']>;\n  /**\n   * The commit message of the auto-merge request. If a merge queue is required by\n   * the base branch, this value will be set by the merge queue when merging.\n   */\n  commitBody?: Maybe<Scalars['String']['output']>;\n  /**\n   * The commit title of the auto-merge request. If a merge queue is required by\n   * the base branch, this value will be set by the merge queue when merging\n   */\n  commitHeadline?: Maybe<Scalars['String']['output']>;\n  /** When was this auto-merge request was enabled. */\n  enabledAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The actor who created the auto-merge request. */\n  enabledBy?: Maybe<Actor>;\n  /**\n   * The merge method of the auto-merge request. If a merge queue is required by\n   * the base branch, this value will be set by the merge queue when merging.\n   */\n  mergeMethod: PullRequestMergeMethod;\n  /** The pull request that this auto-merge request is set against. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'auto_rebase_enabled' event on a given pull request. */\nexport type AutoRebaseEnabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who enabled auto-merge (rebase) for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'auto_squash_enabled' event on a given pull request. */\nexport type AutoSquashEnabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who enabled auto-merge (squash) for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'automatic_base_change_failed' event on a given pull request. */\nexport type AutomaticBaseChangeFailedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The new base for this PR */\n  newBase: Scalars['String']['output'];\n  /** The old base for this PR */\n  oldBase: Scalars['String']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\nexport type AutomaticBaseChangeSucceededEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The new base for this PR */\n  newBase: Scalars['String']['output'];\n  /** The old base for this PR */\n  oldBase: Scalars['String']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'base_ref_changed' event on a given issue or pull request. */\nexport type BaseRefChangedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the name of the base ref for the pull request after it was changed. */\n  currentRefName: Scalars['String']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** Identifies the name of the base ref for the pull request before it was changed. */\n  previousRefName: Scalars['String']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'base_ref_deleted' event on a given pull request. */\nexport type BaseRefDeletedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */\n  baseRefName?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'base_ref_force_pushed' event on a given pull request. */\nexport type BaseRefForcePushedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>;\n  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents a Git blame. */\nexport type Blame = {\n  /** The list of ranges from a Git blame. */\n  ranges: Array<BlameRange>;\n};\n\n/** Represents a range of information from a Git blame. */\nexport type BlameRange = {\n  /**\n   * Identifies the recency of the change, from 1 (new) to 10 (old). This is\n   * calculated as a 2-quantile and determines the length of distance between the\n   * median age of all the changes in the file and the recency of the current\n   * range's change.\n   */\n  age: Scalars['Int']['output'];\n  /** Identifies the line author */\n  commit: Commit;\n  /** The ending line for the range */\n  endingLine: Scalars['Int']['output'];\n  /** The starting line for the range */\n  startingLine: Scalars['Int']['output'];\n};\n\n/** Represents a Git blob. */\nexport type Blob = GitObject & Node & {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String']['output'];\n  /** Byte size of Blob object */\n  byteSize: Scalars['Int']['output'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI']['output'];\n  id: Scalars['ID']['output'];\n  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */\n  isBinary?: Maybe<Scalars['Boolean']['output']>;\n  /** Indicates whether the contents is truncated */\n  isTruncated: Scalars['Boolean']['output'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID']['output'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n  /** UTF8 text data or null if the Blob is binary */\n  text?: Maybe<Scalars['String']['output']>;\n};\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type Bot = Actor & Node & UniformResourceLocatable & {\n  /** A URL pointing to the GitHub App's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The username of the actor. */\n  login: Scalars['String']['output'];\n  /** The HTTP path for this bot */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this bot */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type BotAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Types which can be actors for `BranchActorAllowance` objects. */\nexport type BranchActorAllowanceActor = App | Team | User;\n\n/** Parameters to be used for the branch_name_pattern rule */\nexport type BranchNamePatternParameters = {\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean']['output'];\n  /** The operator to use for matching. */\n  operator: Scalars['String']['output'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['output'];\n};\n\n/** Parameters to be used for the branch_name_pattern rule */\nexport type BranchNamePatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String']['input'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['input'];\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRule = Node & {\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars['Boolean']['output'];\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars['Boolean']['output'];\n  /** Is branch creation a protected operation. */\n  blocksCreations: Scalars['Boolean']['output'];\n  /** A list of conflicts matching branches protection rule and other branch protection rules */\n  branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection;\n  /** A list of actors able to force push for this branch protection rule. */\n  bypassForcePushAllowances: BypassForcePushAllowanceConnection;\n  /** A list of actors able to bypass PRs for this branch protection rule. */\n  bypassPullRequestAllowances: BypassPullRequestAllowanceConnection;\n  /** The actor who created this branch protection rule. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews: Scalars['Boolean']['output'];\n  id: Scalars['ID']['output'];\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced: Scalars['Boolean']['output'];\n  /**\n   * Whether users can pull changes from upstream when the branch is locked. Set to\n   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.\n   */\n  lockAllowsFetchAndMerge: Scalars['Boolean']['output'];\n  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */\n  lockBranch: Scalars['Boolean']['output'];\n  /** Repository refs that are protected by this rule */\n  matchingRefs: RefConnection;\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars['String']['output'];\n  /** A list push allowances for this branch protection rule. */\n  pushAllowances: PushAllowanceConnection;\n  /** The repository associated with this branch protection rule. */\n  repository?: Maybe<Repository>;\n  /** Whether the most recent push must be approved by someone other than the person who pushed it */\n  requireLastPushApproval: Scalars['Boolean']['output'];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;\n  /** List of required deployment environments that must be deployed successfully to update matching branches */\n  requiredDeploymentEnvironments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;\n  /** List of required status checks that must pass for commits to be accepted to matching branches. */\n  requiredStatusChecks?: Maybe<Array<RequiredStatusCheckDescription>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews: Scalars['Boolean']['output'];\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars['Boolean']['output'];\n  /** Are commits required to be signed. */\n  requiresCommitSignatures: Scalars['Boolean']['output'];\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars['Boolean']['output'];\n  /** Does this branch require deployment to specific environments before merging */\n  requiresDeployments: Scalars['Boolean']['output'];\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars['Boolean']['output'];\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks: Scalars['Boolean']['output'];\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks: Scalars['Boolean']['output'];\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes: Scalars['Boolean']['output'];\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals: Scalars['Boolean']['output'];\n  /** A list review dismissal allowances for this branch protection rule. */\n  reviewDismissalAllowances: ReviewDismissalAllowanceConnection;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBranchProtectionRuleConflictsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBypassForcePushAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBypassPullRequestAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleMatchingRefsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRulePushAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleReviewDismissalAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A conflict between two branch protection rules. */\nexport type BranchProtectionRuleConflict = {\n  /** Identifies the branch protection rule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Identifies the conflicting branch protection rule. */\n  conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Identifies the branch ref that has conflicting rules */\n  ref?: Maybe<Ref>;\n};\n\n/** The connection type for BranchProtectionRuleConflict. */\nexport type BranchProtectionRuleConflictConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleConflictEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRuleConflict>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleConflictEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRuleConflict>;\n};\n\n/** The connection type for BranchProtectionRule. */\nexport type BranchProtectionRuleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRule>;\n};\n\n/**\n * Information about a sponsorship to make for a user or organization with a GitHub\n * Sponsors profile, as part of sponsoring many users or organizations at once.\n */\nexport type BulkSponsorship = {\n  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */\n  amount: Scalars['Int']['input'];\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']['input']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Types that can represent a repository ruleset bypass actor. */\nexport type BypassActor = App | Team;\n\n/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */\nexport type BypassForcePushAllowance = Node & {\n  /** The actor that can force push. */\n  actor?: Maybe<BranchActorAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID']['output'];\n};\n\n/** The connection type for BypassForcePushAllowance. */\nexport type BypassForcePushAllowanceConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BypassForcePushAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BypassForcePushAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type BypassForcePushAllowanceEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BypassForcePushAllowance>;\n};\n\n/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */\nexport type BypassPullRequestAllowance = Node & {\n  /** The actor that can bypass. */\n  actor?: Maybe<BranchActorAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID']['output'];\n};\n\n/** The connection type for BypassPullRequestAllowance. */\nexport type BypassPullRequestAllowanceConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BypassPullRequestAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BypassPullRequestAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type BypassPullRequestAllowanceEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BypassPullRequestAllowance>;\n};\n\n/** The Common Vulnerability Scoring System */\nexport type Cvss = {\n  /** The CVSS score associated with this advisory */\n  score: Scalars['Float']['output'];\n  /** The CVSS vector string associated with this advisory */\n  vectorString?: Maybe<Scalars['String']['output']>;\n};\n\n/** A common weakness enumeration */\nexport type Cwe = Node & {\n  /** The id of the CWE */\n  cweId: Scalars['String']['output'];\n  /** A detailed description of this CWE */\n  description: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of this CWE */\n  name: Scalars['String']['output'];\n};\n\n/** The connection type for CWE. */\nexport type CweConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CweEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Cwe>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CweEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Cwe>;\n};\n\n/** Autogenerated input type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the pending enterprise administrator invitation. */\n  invitationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The invitation that was canceled. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** A message confirming the result of canceling an administrator invitation. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of CancelSponsorship */\nexport type CancelSponsorshipInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']['input']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of CancelSponsorship */\nexport type CancelSponsorshipPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The tier that was being used at the time of cancellation. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of ChangeUserStatus */\nexport type ChangeUserStatusInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */\n  emoji?: InputMaybe<Scalars['String']['input']>;\n  /** If set, the user status will not be shown after this date. */\n  expiresAt?: InputMaybe<Scalars['DateTime']['input']>;\n  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */\n  limitedAvailability?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A short description of your current status. */\n  message?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The ID of the organization whose members will be allowed to see the status. If\n   * omitted, the status will be publicly visible.\n   */\n  organizationId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of ChangeUserStatus */\nexport type ChangeUserStatusPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** Your updated status. */\n  status?: Maybe<UserStatus>;\n};\n\n/** A single check annotation. */\nexport type CheckAnnotation = {\n  /** The annotation's severity level. */\n  annotationLevel?: Maybe<CheckAnnotationLevel>;\n  /** The path to the file that this annotation was made on. */\n  blobUrl: Scalars['URI']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The position of this annotation. */\n  location: CheckAnnotationSpan;\n  /** The annotation's message. */\n  message: Scalars['String']['output'];\n  /** The path that this annotation was made on. */\n  path: Scalars['String']['output'];\n  /** Additional information about the annotation. */\n  rawDetails?: Maybe<Scalars['String']['output']>;\n  /** The annotation's title */\n  title?: Maybe<Scalars['String']['output']>;\n};\n\n/** The connection type for CheckAnnotation. */\nexport type CheckAnnotationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckAnnotationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckAnnotation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationData = {\n  /** Represents an annotation's information level */\n  annotationLevel: CheckAnnotationLevel;\n  /** The location of the annotation */\n  location: CheckAnnotationRange;\n  /** A short description of the feedback for these lines of code. */\n  message: Scalars['String']['input'];\n  /** The path of the file to add an annotation to. */\n  path: Scalars['String']['input'];\n  /** Details about this annotation. */\n  rawDetails?: InputMaybe<Scalars['String']['input']>;\n  /** The title that represents the annotation. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** An edge in a connection. */\nexport type CheckAnnotationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckAnnotation>;\n};\n\n/** Represents an annotation's information level. */\nexport enum CheckAnnotationLevel {\n  /** An annotation indicating an inescapable error. */\n  Failure = 'FAILURE',\n  /** An annotation indicating some information. */\n  Notice = 'NOTICE',\n  /** An annotation indicating an ignorable error. */\n  Warning = 'WARNING'\n}\n\n/** A character position in a check annotation. */\nexport type CheckAnnotationPosition = {\n  /** Column number (1 indexed). */\n  column?: Maybe<Scalars['Int']['output']>;\n  /** Line number (1 indexed). */\n  line: Scalars['Int']['output'];\n};\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationRange = {\n  /** The ending column of the range. */\n  endColumn?: InputMaybe<Scalars['Int']['input']>;\n  /** The ending line of the range. */\n  endLine: Scalars['Int']['input'];\n  /** The starting column of the range. */\n  startColumn?: InputMaybe<Scalars['Int']['input']>;\n  /** The starting line of the range. */\n  startLine: Scalars['Int']['input'];\n};\n\n/** An inclusive pair of positions for a check annotation. */\nexport type CheckAnnotationSpan = {\n  /** End position (inclusive). */\n  end: CheckAnnotationPosition;\n  /** Start position (inclusive). */\n  start: CheckAnnotationPosition;\n};\n\n/** The possible states for a check suite or run conclusion. */\nexport enum CheckConclusionState {\n  /** The check suite or run requires action. */\n  ActionRequired = 'ACTION_REQUIRED',\n  /** The check suite or run has been cancelled. */\n  Cancelled = 'CANCELLED',\n  /** The check suite or run has failed. */\n  Failure = 'FAILURE',\n  /** The check suite or run was neutral. */\n  Neutral = 'NEUTRAL',\n  /** The check suite or run was skipped. */\n  Skipped = 'SKIPPED',\n  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = 'STALE',\n  /** The check suite or run has failed at startup. */\n  StartupFailure = 'STARTUP_FAILURE',\n  /** The check suite or run has succeeded. */\n  Success = 'SUCCESS',\n  /** The check suite or run has timed out. */\n  TimedOut = 'TIMED_OUT'\n}\n\n/** A check run. */\nexport type CheckRun = Node & RequirableByPullRequest & UniformResourceLocatable & {\n  /** The check run's annotations */\n  annotations?: Maybe<CheckAnnotationConnection>;\n  /** The check suite that this run is a part of. */\n  checkSuite: CheckSuite;\n  /** Identifies the date and time when the check run was completed. */\n  completedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The conclusion of the check run. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The corresponding deployment for this job, if any */\n  deployment?: Maybe<Deployment>;\n  /** The URL from which to find full details of the check run on the integrator's site. */\n  detailsUrl?: Maybe<Scalars['URI']['output']>;\n  /** A reference for the check run on the integrator's system. */\n  externalId?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean']['output'];\n  /** The name of the check for this check run. */\n  name: Scalars['String']['output'];\n  /** Information about a pending deployment, if any, in this check run */\n  pendingDeploymentRequest?: Maybe<DeploymentRequest>;\n  /** The permalink to the check run summary. */\n  permalink: Scalars['URI']['output'];\n  /** The repository associated with this check run. */\n  repository: Repository;\n  /** The HTTP path for this check run. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the check run was started. */\n  startedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The current status of the check run. */\n  status: CheckStatusState;\n  /** The check run's steps */\n  steps?: Maybe<CheckStepConnection>;\n  /** A string representing the check run's summary */\n  summary?: Maybe<Scalars['String']['output']>;\n  /** A string representing the check run's text */\n  text?: Maybe<Scalars['String']['output']>;\n  /** A string representing the check run */\n  title?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this check run. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A check run. */\nexport type CheckRunAnnotationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A check run. */\nexport type CheckRunIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars['ID']['input']>;\n  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A check run. */\nexport type CheckRunStepsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  number?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Possible further actions the integrator can perform. */\nexport type CheckRunAction = {\n  /** A short explanation of what this action would do. */\n  description: Scalars['String']['input'];\n  /** A reference for the action on the integrator's system.  */\n  identifier: Scalars['String']['input'];\n  /** The text to be displayed on a button in the web UI. */\n  label: Scalars['String']['input'];\n};\n\n/** The connection type for CheckRun. */\nexport type CheckRunConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckRunEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckRun>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CheckRunEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckRun>;\n};\n\n/** The filters that are available when fetching check runs. */\nexport type CheckRunFilter = {\n  /** Filters the check runs created by this application ID. */\n  appId?: InputMaybe<Scalars['Int']['input']>;\n  /** Filters the check runs by this name. */\n  checkName?: InputMaybe<Scalars['String']['input']>;\n  /** Filters the check runs by this type. */\n  checkType?: InputMaybe<CheckRunType>;\n  /** Filters the check runs by these conclusions. */\n  conclusions?: InputMaybe<Array<CheckConclusionState>>;\n  /** Filters the check runs by this status. Superceded by statuses. */\n  status?: InputMaybe<CheckStatusState>;\n  /** Filters the check runs by this status. Overrides status. */\n  statuses?: InputMaybe<Array<CheckStatusState>>;\n};\n\n/** Descriptive details about the check run. */\nexport type CheckRunOutput = {\n  /** The annotations that are made as part of the check run. */\n  annotations?: InputMaybe<Array<CheckAnnotationData>>;\n  /** Images attached to the check run output displayed in the GitHub pull request UI. */\n  images?: InputMaybe<Array<CheckRunOutputImage>>;\n  /** The summary of the check run (supports Commonmark). */\n  summary: Scalars['String']['input'];\n  /** The details of the check run (supports Commonmark). */\n  text?: InputMaybe<Scalars['String']['input']>;\n  /** A title to provide for this check run. */\n  title: Scalars['String']['input'];\n};\n\n/** Images attached to the check run output displayed in the GitHub pull request UI. */\nexport type CheckRunOutputImage = {\n  /** The alternative text for the image. */\n  alt: Scalars['String']['input'];\n  /** A short image description. */\n  caption?: InputMaybe<Scalars['String']['input']>;\n  /** The full URL of the image. */\n  imageUrl: Scalars['URI']['input'];\n};\n\n/** The possible states of a check run in a status rollup. */\nexport enum CheckRunState {\n  /** The check run requires action. */\n  ActionRequired = 'ACTION_REQUIRED',\n  /** The check run has been cancelled. */\n  Cancelled = 'CANCELLED',\n  /** The check run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check run has failed. */\n  Failure = 'FAILURE',\n  /** The check run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check run was neutral. */\n  Neutral = 'NEUTRAL',\n  /** The check run is in pending state. */\n  Pending = 'PENDING',\n  /** The check run has been queued. */\n  Queued = 'QUEUED',\n  /** The check run was skipped. */\n  Skipped = 'SKIPPED',\n  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = 'STALE',\n  /** The check run has failed at startup. */\n  StartupFailure = 'STARTUP_FAILURE',\n  /** The check run has succeeded. */\n  Success = 'SUCCESS',\n  /** The check run has timed out. */\n  TimedOut = 'TIMED_OUT',\n  /** The check run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n/** Represents a count of the state of a check run. */\nexport type CheckRunStateCount = {\n  /** The number of check runs with this state. */\n  count: Scalars['Int']['output'];\n  /** The state of a check run. */\n  state: CheckRunState;\n};\n\n/** The possible types of check runs. */\nexport enum CheckRunType {\n  /** Every check run available. */\n  All = 'ALL',\n  /** The latest check run. */\n  Latest = 'LATEST'\n}\n\n/** The possible states for a check suite or run status. */\nexport enum CheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run has been requested. */\n  Requested = 'REQUESTED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n/** A single check step. */\nexport type CheckStep = {\n  /** Identifies the date and time when the check step was completed. */\n  completedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The conclusion of the check step. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** A reference for the check step on the integrator's system. */\n  externalId?: Maybe<Scalars['String']['output']>;\n  /** The step's name. */\n  name: Scalars['String']['output'];\n  /** The index of the step in the list of steps of the parent check run. */\n  number: Scalars['Int']['output'];\n  /** Number of seconds to completion. */\n  secondsToCompletion?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the date and time when the check step was started. */\n  startedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The current status of the check step. */\n  status: CheckStatusState;\n};\n\n/** The connection type for CheckStep. */\nexport type CheckStepConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckStepEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckStep>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CheckStepEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckStep>;\n};\n\n/** A check suite. */\nexport type CheckSuite = Node & {\n  /** The GitHub App which created this check suite. */\n  app?: Maybe<App>;\n  /** The name of the branch for this check suite. */\n  branch?: Maybe<Ref>;\n  /** The check runs associated with a check suite. */\n  checkRuns?: Maybe<CheckRunConnection>;\n  /** The commit for this check suite */\n  commit: Commit;\n  /** The conclusion of this check suite. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who triggered the check suite. */\n  creator?: Maybe<User>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** A list of open pull requests matching the check suite. */\n  matchingPullRequests?: Maybe<PullRequestConnection>;\n  /** The push that triggered this check suite. */\n  push?: Maybe<Push>;\n  /** The repository associated with this check suite. */\n  repository: Repository;\n  /** The HTTP path for this check suite */\n  resourcePath: Scalars['URI']['output'];\n  /** The status of this check suite. */\n  status: CheckStatusState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this check suite */\n  url: Scalars['URI']['output'];\n  /** The workflow run associated with this check suite. */\n  workflowRun?: Maybe<WorkflowRun>;\n};\n\n\n/** A check suite. */\nexport type CheckSuiteCheckRunsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<CheckRunFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A check suite. */\nexport type CheckSuiteMatchingPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  headRefName?: InputMaybe<Scalars['String']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The auto-trigger preferences that are available for check suites. */\nexport type CheckSuiteAutoTriggerPreference = {\n  /** The node ID of the application that owns the check suite. */\n  appId: Scalars['ID']['input'];\n  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */\n  setting: Scalars['Boolean']['input'];\n};\n\n/** The connection type for CheckSuite. */\nexport type CheckSuiteConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckSuiteEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckSuite>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CheckSuiteEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckSuite>;\n};\n\n/** The filters that are available when fetching check suites. */\nexport type CheckSuiteFilter = {\n  /** Filters the check suites created by this application ID. */\n  appId?: InputMaybe<Scalars['Int']['input']>;\n  /** Filters the check suites by this name. */\n  checkName?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** An object which can have its data claimed or claim data from another. */\nexport type Claimable = Mannequin | User;\n\n/** Autogenerated input type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the labelable object to clear the labels from. */\n  labelableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelablePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item that was unlabeled. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of ClearProjectV2ItemFieldValue */\nexport type ClearProjectV2ItemFieldValueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the field to be cleared. */\n  fieldId: Scalars['ID']['input'];\n  /** The ID of the item to be cleared. */\n  itemId: Scalars['ID']['input'];\n  /** The ID of the Project. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ClearProjectV2ItemFieldValue */\nexport type ClearProjectV2ItemFieldValuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated item. */\n  projectV2Item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of CloneProject */\nexport type CloneProjectInput = {\n  /** The description of the project. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether or not to clone the source project's workflows. */\n  includeWorkflows: Scalars['Boolean']['input'];\n  /** The name of the project. */\n  name: Scalars['String']['input'];\n  /** The visibility of the project, defaults to false (private). */\n  public?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The source project to clone. */\n  sourceId: Scalars['ID']['input'];\n  /** The owner ID to create the project under. */\n  targetOwnerId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CloneProject */\nexport type CloneProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The id of the JobStatus for populating cloned fields. */\n  jobStatusId?: Maybe<Scalars['String']['output']>;\n  /** The new cloned project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A short description of the new repository. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Whether to copy all branches from the template to the new repository. Defaults\n   * to copying only the default branch of the template.\n   */\n  includeAllBranches?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The name of the new repository. */\n  name: Scalars['String']['input'];\n  /** The ID of the owner for the new repository. */\n  ownerId: Scalars['ID']['input'];\n  /** The Node ID of the template repository. */\n  repositoryId: Scalars['ID']['input'];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** Autogenerated return type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** An object that can be closed */\nexport type Closable = {\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n};\n\n/** Autogenerated input type of CloseDiscussion */\nexport type CloseDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the discussion to be closed. */\n  discussionId: Scalars['ID']['input'];\n  /** The reason why the discussion is being closed. */\n  reason?: InputMaybe<DiscussionCloseReason>;\n};\n\n/** Autogenerated return type of CloseDiscussion */\nexport type CloseDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion that was closed. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of CloseIssue */\nexport type CloseIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the issue to be closed. */\n  issueId: Scalars['ID']['input'];\n  /** The reason the issue is to be closed. */\n  stateReason?: InputMaybe<IssueClosedStateReason>;\n};\n\n/** Autogenerated return type of CloseIssue */\nexport type CloseIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue that was closed. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of ClosePullRequest */\nexport type ClosePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the pull request to be closed. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ClosePullRequest */\nexport type ClosePullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that was closed. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'closed' event on any `Closable`. */\nexport type ClosedEvent = Node & UniformResourceLocatable & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Object that was closed. */\n  closable: Closable;\n  /** Object which triggered the creation of this event. */\n  closer?: Maybe<Closer>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The HTTP path for this closed event. */\n  resourcePath: Scalars['URI']['output'];\n  /** The reason the issue state was changed to closed. */\n  stateReason?: Maybe<IssueStateReason>;\n  /** The HTTP URL for this closed event. */\n  url: Scalars['URI']['output'];\n};\n\n/** The object which triggered a `ClosedEvent`. */\nexport type Closer = Commit | PullRequest;\n\n/** The Code of Conduct for a repository */\nexport type CodeOfConduct = Node & {\n  /** The body of the Code of Conduct */\n  body?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The key for the Code of Conduct */\n  key: Scalars['String']['output'];\n  /** The formal name of the Code of Conduct */\n  name: Scalars['String']['output'];\n  /** The HTTP path for this Code of Conduct */\n  resourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this Code of Conduct */\n  url?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Collaborators affiliation level with a subject. */\nexport enum CollaboratorAffiliation {\n  /** All collaborators the authenticated user can see. */\n  All = 'ALL',\n  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */\n  Direct = 'DIRECT',\n  /** All outside collaborators of an organization-owned subject. */\n  Outside = 'OUTSIDE'\n}\n\n/** Represents a comment. */\nexport type Comment = {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a comment. */\nexport type CommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A comment author association with repository. */\nexport enum CommentAuthorAssociation {\n  /** Author has been invited to collaborate on the repository. */\n  Collaborator = 'COLLABORATOR',\n  /** Author has previously committed to the repository. */\n  Contributor = 'CONTRIBUTOR',\n  /** Author has not previously committed to GitHub. */\n  FirstTimer = 'FIRST_TIMER',\n  /** Author has not previously committed to the repository. */\n  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',\n  /** Author is a placeholder for an unclaimed user. */\n  Mannequin = 'MANNEQUIN',\n  /** Author is a member of the organization that owns the repository. */\n  Member = 'MEMBER',\n  /** Author has no association with the repository. */\n  None = 'NONE',\n  /** Author is the owner of the repository. */\n  Owner = 'OWNER'\n}\n\n/** The possible errors that will prevent a user from updating a comment. */\nexport enum CommentCannotUpdateReason {\n  /** Unable to create comment because repository is archived. */\n  Archived = 'ARCHIVED',\n  /** You cannot update this comment */\n  Denied = 'DENIED',\n  /** You must be the author or have write access to this repository to update this comment. */\n  InsufficientAccess = 'INSUFFICIENT_ACCESS',\n  /** Unable to create comment because issue is locked. */\n  Locked = 'LOCKED',\n  /** You must be logged in to update this comment. */\n  LoginRequired = 'LOGIN_REQUIRED',\n  /** Repository is under maintenance. */\n  Maintenance = 'MAINTENANCE',\n  /** At least one email address must be verified to update this comment. */\n  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'\n}\n\n/** Represents a 'comment_deleted' event on a given issue or pull request. */\nexport type CommentDeletedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The user who authored the deleted comment. */\n  deletedCommentAuthor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n};\n\n/** Represents a Git commit. */\nexport type Commit = GitObject & Node & Subscribable & UniformResourceLocatable & {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String']['output'];\n  /** The number of additions in this commit. */\n  additions: Scalars['Int']['output'];\n  /**\n   * The merged Pull Request that introduced the commit to the repository. If the\n   * commit is not present in the default branch, additionally returns open Pull\n   * Requests associated with the commit\n   */\n  associatedPullRequests?: Maybe<PullRequestConnection>;\n  /** Authorship details of the commit. */\n  author?: Maybe<GitActor>;\n  /** Check if the committer and the author match. */\n  authoredByCommitter: Scalars['Boolean']['output'];\n  /** The datetime when this commit was authored. */\n  authoredDate: Scalars['DateTime']['output'];\n  /**\n   * The list of authors for this commit based on the git author and the Co-authored-by\n   * message trailer. The git author will always be first.\n   */\n  authors: GitActorConnection;\n  /** Fetches `git blame` information. */\n  blame: Blame;\n  /**\n   * We recommend using the `changedFilesIfAvailable` field instead of\n   * `changedFiles`, as `changedFiles` will cause your request to return an error\n   * if GitHub is unable to calculate the number of changed files.\n   * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.\n   */\n  changedFiles: Scalars['Int']['output'];\n  /**\n   * The number of changed files in this commit. If GitHub is unable to calculate\n   * the number of changed files (for example due to a timeout), this will return\n   * `null`. We recommend using this field instead of `changedFiles`.\n   */\n  changedFilesIfAvailable?: Maybe<Scalars['Int']['output']>;\n  /** The check suites associated with a commit. */\n  checkSuites?: Maybe<CheckSuiteConnection>;\n  /** Comments made on the commit. */\n  comments: CommitCommentConnection;\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI']['output'];\n  /** The datetime when this commit was committed. */\n  committedDate: Scalars['DateTime']['output'];\n  /** Check if committed via GitHub web UI. */\n  committedViaWeb: Scalars['Boolean']['output'];\n  /** Committer details of the commit. */\n  committer?: Maybe<GitActor>;\n  /** The number of deletions in this commit. */\n  deletions: Scalars['Int']['output'];\n  /** The deployments associated with a commit. */\n  deployments?: Maybe<DeploymentConnection>;\n  /** The tree entry representing the file located at the given path. */\n  file?: Maybe<TreeEntry>;\n  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */\n  history: CommitHistoryConnection;\n  id: Scalars['ID']['output'];\n  /** The Git commit message */\n  message: Scalars['String']['output'];\n  /** The Git commit message body */\n  messageBody: Scalars['String']['output'];\n  /** The commit message body rendered to HTML. */\n  messageBodyHTML: Scalars['HTML']['output'];\n  /** The Git commit message headline */\n  messageHeadline: Scalars['String']['output'];\n  /** The commit message headline rendered to HTML. */\n  messageHeadlineHTML: Scalars['HTML']['output'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID']['output'];\n  /** The organization this commit was made on behalf of. */\n  onBehalfOf?: Maybe<Organization>;\n  /** The parents of a commit. */\n  parents: CommitConnection;\n  /**\n   * The datetime when this commit was pushed.\n   * @deprecated `pushedDate` is no longer supported. Removal on 2023-07-01 UTC.\n   */\n  pushedDate?: Maybe<Scalars['DateTime']['output']>;\n  /** The Repository this commit belongs to */\n  repository: Repository;\n  /** The HTTP path for this commit */\n  resourcePath: Scalars['URI']['output'];\n  /** Commit signing information, if present. */\n  signature?: Maybe<GitSignature>;\n  /** Status information for this commit */\n  status?: Maybe<Status>;\n  /** Check and Status rollup information for this commit. */\n  statusCheckRollup?: Maybe<StatusCheckRollup>;\n  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */\n  submodules: SubmoduleConnection;\n  /**\n   * Returns a URL to download a tarball archive for a repository.\n   * Note: For private repositories, these links are temporary and expire after five minutes.\n   */\n  tarballUrl: Scalars['URI']['output'];\n  /** Commit's root Tree */\n  tree: Tree;\n  /** The HTTP path for the tree of this commit */\n  treeResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for the tree of this commit */\n  treeUrl: Scalars['URI']['output'];\n  /** The HTTP URL for this commit */\n  url: Scalars['URI']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n  /**\n   * Returns a URL to download a zipball archive for a repository.\n   * Note: For private repositories, these links are temporary and expire after five minutes.\n   */\n  zipballUrl: Scalars['URI']['output'];\n};\n\n\n/** Represents a Git commit. */\nexport type CommitAssociatedPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<PullRequestOrder>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitAuthorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitBlameArgs = {\n  path: Scalars['String']['input'];\n};\n\n\n/** Represents a Git commit. */\nexport type CommitCheckSuitesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<CheckSuiteFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitDeploymentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  environments?: InputMaybe<Array<Scalars['String']['input']>>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitFileArgs = {\n  path: Scalars['String']['input'];\n};\n\n\n/** Represents a Git commit. */\nexport type CommitHistoryArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  author?: InputMaybe<CommitAuthor>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  path?: InputMaybe<Scalars['String']['input']>;\n  since?: InputMaybe<Scalars['GitTimestamp']['input']>;\n  until?: InputMaybe<Scalars['GitTimestamp']['input']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitParentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitSubmodulesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Specifies an author for filtering Git commits. */\nexport type CommitAuthor = {\n  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */\n  emails?: InputMaybe<Array<Scalars['String']['input']>>;\n  /**\n   * ID of a User to filter by. If non-null, only commits authored by this user\n   * will be returned. This field takes precedence over emails.\n   */\n  id?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Parameters to be used for the commit_author_email_pattern rule */\nexport type CommitAuthorEmailPatternParameters = {\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean']['output'];\n  /** The operator to use for matching. */\n  operator: Scalars['String']['output'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['output'];\n};\n\n/** Parameters to be used for the commit_author_email_pattern rule */\nexport type CommitAuthorEmailPatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String']['input'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['input'];\n};\n\n/** Represents a comment on a given Commit. */\nexport type CommitComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Identifies the comment body. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the commit associated with the comment, if the commit exists. */\n  commit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']['output']>;\n  /** Identifies the file path associated with the comment. */\n  path?: Maybe<Scalars['String']['output']>;\n  /** Identifies the line position associated with the comment. */\n  position?: Maybe<Scalars['Int']['output']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path permalink for this commit comment. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL permalink for this commit comment. */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for CommitComment. */\nexport type CommitCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CommitComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CommitCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CommitComment>;\n};\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThread = Node & RepositoryNode & {\n  /** The comments that exist in this thread. */\n  comments: CommitCommentConnection;\n  /** The commit the comments were made on. */\n  commit?: Maybe<Commit>;\n  id: Scalars['ID']['output'];\n  /** The file the comments were made on. */\n  path?: Maybe<Scalars['String']['output']>;\n  /** The position in the diff for the commit that the comment was made on. */\n  position?: Maybe<Scalars['Int']['output']>;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for Commit. */\nexport type CommitConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Ordering options for commit contribution connections. */\nexport type CommitContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field by which to order commit contributions. */\n  field: CommitContributionOrderField;\n};\n\n/** Properties by which commit contribution connections can be ordered. */\nexport enum CommitContributionOrderField {\n  /** Order commit contributions by how many commits they represent. */\n  CommitCount = 'COMMIT_COUNT',\n  /** Order commit contributions by when they were made. */\n  OccurredAt = 'OCCURRED_AT'\n}\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepository = {\n  /** The commit contributions, each representing a day. */\n  contributions: CreatedCommitContributionConnection;\n  /** The repository in which the commits were made. */\n  repository: Repository;\n  /** The HTTP path for the user's commits to the repository in this time range. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for the user's commits to the repository in this time range. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<CommitContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type CommitEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Commit>;\n};\n\n/** The connection type for Commit. */\nexport type CommitHistoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** A message to include with a new commit */\nexport type CommitMessage = {\n  /** The body of the message. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** The headline of the message. */\n  headline: Scalars['String']['input'];\n};\n\n/** Parameters to be used for the commit_message_pattern rule */\nexport type CommitMessagePatternParameters = {\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean']['output'];\n  /** The operator to use for matching. */\n  operator: Scalars['String']['output'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['output'];\n};\n\n/** Parameters to be used for the commit_message_pattern rule */\nexport type CommitMessagePatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String']['input'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['input'];\n};\n\n/**\n * A git ref for a commit to be appended to.\n *\n * The ref must be a branch, i.e. its fully qualified name must start\n * with `refs/heads/` (although the input is not required to be fully\n * qualified).\n *\n * The Ref may be specified by its global node ID or by the\n * `repositoryNameWithOwner` and `branchName`.\n *\n * ### Examples\n *\n * Specify a branch using a global node ID:\n *\n *     { \"id\": \"MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=\" }\n *\n * Specify a branch using `repositoryNameWithOwner` and `branchName`:\n *\n *     {\n *       \"repositoryNameWithOwner\": \"github/graphql-client\",\n *       \"branchName\": \"main\"\n *     }\n */\nexport type CommittableBranch = {\n  /** The unqualified name of the branch to append the commit to. */\n  branchName?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the Ref to be updated. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The nameWithOwner of the repository to commit to. */\n  repositoryNameWithOwner?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Parameters to be used for the committer_email_pattern rule */\nexport type CommitterEmailPatternParameters = {\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean']['output'];\n  /** The operator to use for matching. */\n  operator: Scalars['String']['output'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['output'];\n};\n\n/** Parameters to be used for the committer_email_pattern rule */\nexport type CommitterEmailPatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String']['input'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['input'];\n};\n\n/** Represents a comparison between two commit revisions. */\nexport type Comparison = Node & {\n  /** The number of commits ahead of the base branch. */\n  aheadBy: Scalars['Int']['output'];\n  /** The base revision of this comparison. */\n  baseTarget: GitObject;\n  /** The number of commits behind the base branch. */\n  behindBy: Scalars['Int']['output'];\n  /** The commits which compose this comparison. */\n  commits: ComparisonCommitConnection;\n  /** The head revision of this comparison. */\n  headTarget: GitObject;\n  id: Scalars['ID']['output'];\n  /** The status of this comparison. */\n  status: ComparisonStatus;\n};\n\n\n/** Represents a comparison between two commit revisions. */\nexport type ComparisonCommitsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for Commit. */\nexport type ComparisonCommitConnection = {\n  /** The total count of authors and co-authors across all commits. */\n  authorCount: Scalars['Int']['output'];\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** The status of a git comparison between two refs. */\nexport enum ComparisonStatus {\n  /** The head ref is ahead of the base ref. */\n  Ahead = 'AHEAD',\n  /** The head ref is behind the base ref. */\n  Behind = 'BEHIND',\n  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */\n  Diverged = 'DIVERGED',\n  /** The head ref and base ref are identical. */\n  Identical = 'IDENTICAL'\n}\n\n/** Represents a 'connected' event on a given issue or pull request. */\nexport type ConnectedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']['output'];\n  /** Issue or pull request that made the reference. */\n  source: ReferencedSubject;\n  /** Issue or pull request which was connected. */\n  subject: ReferencedSubject;\n};\n\n/** Represents a contribution a user made on GitHub, such as opening an issue. */\nexport type Contribution = {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A calendar of contributions made on GitHub by a user. */\nexport type ContributionCalendar = {\n  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */\n  colors: Array<Scalars['String']['output']>;\n  /** Determine if the color set was chosen because it's currently Halloween. */\n  isHalloween: Scalars['Boolean']['output'];\n  /** A list of the months of contributions in this calendar. */\n  months: Array<ContributionCalendarMonth>;\n  /** The count of total contributions in the calendar. */\n  totalContributions: Scalars['Int']['output'];\n  /** A list of the weeks of contributions in this calendar. */\n  weeks: Array<ContributionCalendarWeek>;\n};\n\n/** Represents a single day of contributions on GitHub by a user. */\nexport type ContributionCalendarDay = {\n  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */\n  color: Scalars['String']['output'];\n  /** How many contributions were made by the user on this day. */\n  contributionCount: Scalars['Int']['output'];\n  /**\n   * Indication of contributions, relative to other days. Can be used to indicate\n   * which color to represent this day on a calendar.\n   */\n  contributionLevel: ContributionLevel;\n  /** The day this square represents. */\n  date: Scalars['Date']['output'];\n  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */\n  weekday: Scalars['Int']['output'];\n};\n\n/** A month of contributions in a user's contribution graph. */\nexport type ContributionCalendarMonth = {\n  /** The date of the first day of this month. */\n  firstDay: Scalars['Date']['output'];\n  /** The name of the month. */\n  name: Scalars['String']['output'];\n  /** How many weeks started in this month. */\n  totalWeeks: Scalars['Int']['output'];\n  /** The year the month occurred in. */\n  year: Scalars['Int']['output'];\n};\n\n/** A week of contributions in a user's contribution graph. */\nexport type ContributionCalendarWeek = {\n  /** The days of contributions in this week. */\n  contributionDays: Array<ContributionCalendarDay>;\n  /** The date of the earliest square in this week. */\n  firstDay: Scalars['Date']['output'];\n};\n\n/** Varying levels of contributions from none to many. */\nexport enum ContributionLevel {\n  /** Lowest 25% of days of contributions. */\n  FirstQuartile = 'FIRST_QUARTILE',\n  /** Highest 25% of days of contributions. More contributions than the third quartile. */\n  FourthQuartile = 'FOURTH_QUARTILE',\n  /** No contributions occurred. */\n  None = 'NONE',\n  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */\n  SecondQuartile = 'SECOND_QUARTILE',\n  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */\n  ThirdQuartile = 'THIRD_QUARTILE'\n}\n\n/** Ordering options for contribution connections. */\nexport type ContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollection = {\n  /** Commit contributions made by the user, grouped by repository. */\n  commitContributionsByRepository: Array<CommitContributionsByRepository>;\n  /** A calendar of this user's contributions on GitHub. */\n  contributionCalendar: ContributionCalendar;\n  /** The years the user has been making contributions with the most recent year first. */\n  contributionYears: Array<Scalars['Int']['output']>;\n  /** Determine if this collection's time span ends in the current month. */\n  doesEndInCurrentMonth: Scalars['Boolean']['output'];\n  /**\n   * The date of the first restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  earliestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;\n  /** The ending date and time of this collection. */\n  endedAt: Scalars['DateTime']['output'];\n  /**\n   * The first issue the user opened on GitHub. This will be null if that issue was\n   * opened outside the collection's time range and ignoreTimeRange is false. If\n   * the issue is not visible but the user has opted to show private contributions,\n   * a RestrictedContribution will be returned.\n   */\n  firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>;\n  /**\n   * The first pull request the user opened on GitHub. This will be null if that\n   * pull request was opened outside the collection's time range and\n   * ignoreTimeRange is not true. If the pull request is not visible but the user\n   * has opted to show private contributions, a RestrictedContribution will be returned.\n   */\n  firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>;\n  /**\n   * The first repository the user created on GitHub. This will be null if that\n   * first repository was created outside the collection's time range and\n   * ignoreTimeRange is false. If the repository is not visible, then a\n   * RestrictedContribution is returned.\n   */\n  firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>;\n  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */\n  hasActivityInThePast: Scalars['Boolean']['output'];\n  /** Determine if there are any contributions in this collection. */\n  hasAnyContributions: Scalars['Boolean']['output'];\n  /**\n   * Determine if the user made any contributions in this time frame whose details\n   * are not visible because they were made in a private repository. Can only be\n   * true if the user enabled private contribution counts.\n   */\n  hasAnyRestrictedContributions: Scalars['Boolean']['output'];\n  /** Whether or not the collector's time span is all within the same day. */\n  isSingleDay: Scalars['Boolean']['output'];\n  /** A list of issues the user opened. */\n  issueContributions: CreatedIssueContributionConnection;\n  /** Issue contributions made by the user, grouped by repository. */\n  issueContributionsByRepository: Array<IssueContributionsByRepository>;\n  /**\n   * When the user signed up for GitHub. This will be null if that sign up date\n   * falls outside the collection's time range and ignoreTimeRange is false.\n   */\n  joinedGitHubContribution?: Maybe<JoinedGitHubContribution>;\n  /**\n   * The date of the most recent restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  latestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;\n  /**\n   * When this collection's time range does not include any activity from the user, use this\n   * to get a different collection from an earlier time range that does have activity.\n   */\n  mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>;\n  /**\n   * Returns a different contributions collection from an earlier time range than this one\n   * that does not have any contributions.\n   */\n  mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>;\n  /**\n   * The issue the user opened on GitHub that received the most comments in the specified\n   * time frame.\n   */\n  popularIssueContribution?: Maybe<CreatedIssueContribution>;\n  /**\n   * The pull request the user opened on GitHub that received the most comments in the\n   * specified time frame.\n   */\n  popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>;\n  /** Pull request contributions made by the user. */\n  pullRequestContributions: CreatedPullRequestContributionConnection;\n  /** Pull request contributions made by the user, grouped by repository. */\n  pullRequestContributionsByRepository: Array<PullRequestContributionsByRepository>;\n  /**\n   * Pull request review contributions made by the user. Returns the most recently\n   * submitted review for each PR reviewed by the user.\n   */\n  pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection;\n  /** Pull request review contributions made by the user, grouped by repository. */\n  pullRequestReviewContributionsByRepository: Array<PullRequestReviewContributionsByRepository>;\n  /** A list of repositories owned by the user that the user created in this time range. */\n  repositoryContributions: CreatedRepositoryContributionConnection;\n  /**\n   * A count of contributions made by the user that the viewer cannot access. Only\n   * non-zero when the user has chosen to share their private contribution counts.\n   */\n  restrictedContributionsCount: Scalars['Int']['output'];\n  /** The beginning date and time of this collection. */\n  startedAt: Scalars['DateTime']['output'];\n  /** How many commits were made by the user in this time span. */\n  totalCommitContributions: Scalars['Int']['output'];\n  /** How many issues the user opened. */\n  totalIssueContributions: Scalars['Int']['output'];\n  /** How many pull requests the user opened. */\n  totalPullRequestContributions: Scalars['Int']['output'];\n  /** How many pull request reviews the user left. */\n  totalPullRequestReviewContributions: Scalars['Int']['output'];\n  /** How many different repositories the user committed to. */\n  totalRepositoriesWithContributedCommits: Scalars['Int']['output'];\n  /** How many different repositories the user opened issues in. */\n  totalRepositoriesWithContributedIssues: Scalars['Int']['output'];\n  /** How many different repositories the user left pull request reviews in. */\n  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int']['output'];\n  /** How many different repositories the user opened pull requests in. */\n  totalRepositoriesWithContributedPullRequests: Scalars['Int']['output'];\n  /** How many repositories the user created. */\n  totalRepositoryContributions: Scalars['Int']['output'];\n  /** The user who made the contributions in this collection. */\n  user: User;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionCommitContributionsByRepositoryArgs = {\n  maxRepositories?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsByRepositoryArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n  maxRepositories?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsByRepositoryArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n  maxRepositories?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {\n  maxRepositories?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalIssueContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalPullRequestContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoryContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Autogenerated input type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssueInput = {\n  /** The body of the newly created issue. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ProjectCard ID to convert. */\n  projectCardId: Scalars['ID']['input'];\n  /** The ID of the repository to create the issue in. */\n  repositoryId: Scalars['ID']['input'];\n  /** The title of the newly created issue. Defaults to the card's note text. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>;\n};\n\n/** Autogenerated input type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the pull request to convert to draft */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that is now a draft. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'convert_to_draft' event on a given pull request. */\nexport type ConvertToDraftEvent = Node & UniformResourceLocatable & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this convert to draft event. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this convert to draft event. */\n  url: Scalars['URI']['output'];\n};\n\n/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\nexport type ConvertedNoteToIssueEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n};\n\n/** Represents a 'converted_to_discussion' event on a given issue. */\nexport type ConvertedToDiscussionEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The discussion that the issue was converted into. */\n  discussion?: Maybe<Discussion>;\n  id: Scalars['ID']['output'];\n};\n\n/** Autogenerated input type of CopyProjectV2 */\nexport type CopyProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Include draft issues in the new project */\n  includeDraftIssues?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The owner ID of the new project. */\n  ownerId: Scalars['ID']['input'];\n  /** The ID of the source Project to copy. */\n  projectId: Scalars['ID']['input'];\n  /** The title of the project. */\n  title: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of CopyProjectV2 */\nexport type CopyProjectV2Payload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The copied project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of CreateAttributionInvitation */\nexport type CreateAttributionInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the owner scoping the reattributable data. */\n  ownerId: Scalars['ID']['input'];\n  /** The Node ID of the account owning the data to reattribute. */\n  sourceId: Scalars['ID']['input'];\n  /** The Node ID of the account which may claim the data. */\n  targetId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CreateAttributionInvitation */\nexport type CreateAttributionInvitationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The owner scoping the reattributable data. */\n  owner?: Maybe<Organization>;\n  /** The account owning the data to reattribute. */\n  source?: Maybe<Claimable>;\n  /** The account which may claim the data. */\n  target?: Maybe<Claimable>;\n};\n\n/** Autogenerated input type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Is branch creation a protected operation. */\n  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */\n  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */\n  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * Whether users can pull changes from upstream when the branch is locked. Set to\n   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.\n   */\n  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */\n  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern: Scalars['String']['input'];\n  /** A list of User, Team, or App IDs allowed to push to matching branches. */\n  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The global relay id of the repository in which a new branch protection rule should be created in. */\n  repositoryId: Scalars['ID']['input'];\n  /** Whether the most recent push must be approved by someone other than the person who pushed it */\n  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;\n  /** The list of required deployment environments */\n  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** The list of required status checks */\n  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are successful deployments required before merging. */\n  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n};\n\n/** Autogenerated return type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRulePayload = {\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of CreateCheckRun */\nexport type CreateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: InputMaybe<Array<CheckRunAction>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The time that the check run finished. */\n  completedAt?: InputMaybe<Scalars['DateTime']['input']>;\n  /** The final conclusion of the check. */\n  conclusion?: InputMaybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: InputMaybe<Scalars['URI']['input']>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: InputMaybe<Scalars['String']['input']>;\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID']['input'];\n  /** The name of the check. */\n  name: Scalars['String']['input'];\n  /** Descriptive details about the run. */\n  output?: InputMaybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n  /** The time that the check run began. */\n  startedAt?: InputMaybe<Scalars['DateTime']['input']>;\n  /** The current status. */\n  status?: InputMaybe<RequestableCheckStatusState>;\n};\n\n/** Autogenerated return type of CreateCheckRun */\nexport type CreateCheckRunPayload = {\n  /** The newly created check run. */\n  checkRun?: Maybe<CheckRun>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of CreateCheckSuite */\nexport type CreateCheckSuiteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID']['input'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CreateCheckSuite */\nexport type CreateCheckSuitePayload = {\n  /** The newly created check suite. */\n  checkSuite?: Maybe<CheckSuite>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchInput = {\n  /** The Ref to be updated.  Must be a branch. */\n  branch: CommittableBranch;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The git commit oid expected at the head of the branch prior to the commit */\n  expectedHeadOid: Scalars['GitObjectID']['input'];\n  /** A description of changes to files in this commit. */\n  fileChanges?: InputMaybe<FileChanges>;\n  /** The commit message the be included with the commit. */\n  message: CommitMessage;\n};\n\n/** Autogenerated return type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new commit. */\n  commit?: Maybe<Commit>;\n  /** The ref which has been updated to point to the new commit. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of CreateDiscussion */\nexport type CreateDiscussionInput = {\n  /** The body of the discussion. */\n  body: Scalars['String']['input'];\n  /** The id of the discussion category to associate with this discussion. */\n  categoryId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the repository on which to create the discussion. */\n  repositoryId: Scalars['ID']['input'];\n  /** The title of the discussion. */\n  title: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of CreateDiscussion */\nexport type CreateDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion that was just created. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationInput = {\n  /** The logins for the administrators of the new organization. */\n  adminLogins: Array<Scalars['String']['input']>;\n  /** The email used for sending billing receipts. */\n  billingEmail: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise owning the new organization. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of the new organization. */\n  login: Scalars['String']['input'];\n  /** The profile name of the new organization. */\n  profileName: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise that owns the created organization. */\n  enterprise?: Maybe<Enterprise>;\n  /** The organization that was created. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of CreateEnvironment */\nexport type CreateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the environment. */\n  name: Scalars['String']['input'];\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CreateEnvironment */\nexport type CreateEnvironmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new or existing environment. */\n  environment?: Maybe<Environment>;\n};\n\n/** Autogenerated input type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean']['input'];\n  /** An optional name for the IP allow list entry. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the owner for which to create the new IP allow list entry. */\n  ownerId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The IP allow list entry that was created. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of CreateIssue */\nexport type CreateIssueInput = {\n  /** The Node ID for the user assignee for this issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The body for the issue description. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */\n  issueTemplate?: InputMaybe<Scalars['String']['input']>;\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: InputMaybe<Scalars['ID']['input']>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n  /** The title for the issue. */\n  title: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of CreateIssue */\nexport type CreateIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new issue. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of CreateLinkedBranch */\nexport type CreateLinkedBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the issue to link to. */\n  issueId: Scalars['ID']['input'];\n  /** The name of the new branch. Defaults to issue number and title. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The commit SHA to base the new branch on. */\n  oid: Scalars['GitObjectID']['input'];\n  /** ID of the repository to create the branch in. Defaults to the issue repository. */\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of CreateLinkedBranch */\nexport type CreateLinkedBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new branch issue reference. */\n  linkedBranch?: Maybe<LinkedBranch>;\n};\n\n/** Autogenerated input type of CreateMigrationSource */\nexport type CreateMigrationSourceInput = {\n  /** The migration source access token. */\n  accessToken?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The GitHub personal access token of the user importing to the target repository. */\n  githubPat?: InputMaybe<Scalars['String']['input']>;\n  /** The migration source name. */\n  name: Scalars['String']['input'];\n  /** The ID of the organization that will own the migration source. */\n  ownerId: Scalars['ID']['input'];\n  /** The migration source type. */\n  type: MigrationSourceType;\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  url?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of CreateMigrationSource */\nexport type CreateMigrationSourcePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The created migration source. */\n  migrationSource?: Maybe<MigrationSource>;\n};\n\n/** Autogenerated input type of CreateProject */\nexport type CreateProjectInput = {\n  /** The description of project. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of project. */\n  name: Scalars['String']['input'];\n  /** The owner ID to create the project under. */\n  ownerId: Scalars['ID']['input'];\n  /** A list of repository IDs to create as linked repositories for the project */\n  repositoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The name of the GitHub-provided template. */\n  template?: InputMaybe<ProjectTemplate>;\n};\n\n/** Autogenerated return type of CreateProject */\nexport type CreateProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of CreateProjectV2Field */\nexport type CreateProjectV2FieldInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The data type of the field. */\n  dataType: ProjectV2CustomFieldType;\n  /** The name of the field. */\n  name: Scalars['String']['input'];\n  /** The ID of the Project to create the field in. */\n  projectId: Scalars['ID']['input'];\n  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */\n  singleSelectOptions?: InputMaybe<Array<ProjectV2SingleSelectFieldOptionInput>>;\n};\n\n/** Autogenerated return type of CreateProjectV2Field */\nexport type CreateProjectV2FieldPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new field. */\n  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;\n};\n\n/** Autogenerated input type of CreateProjectV2 */\nexport type CreateProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The owner ID to create the project under. */\n  ownerId: Scalars['ID']['input'];\n  /** The repository to link the project to. */\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n  /** The team to link the project to. The team will be granted read permissions. */\n  teamId?: InputMaybe<Scalars['ID']['input']>;\n  /** The title of the project. */\n  title: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of CreateProjectV2 */\nexport type CreateProjectV2Payload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of CreatePullRequest */\nexport type CreatePullRequestInput = {\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository. You cannot update the base branch on a pull request to point\n   * to another repository.\n   */\n  baseRefName: Scalars['String']['input'];\n  /** The contents of the pull request. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Indicates whether this pull request should be a draft. */\n  draft?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * The name of the branch where your changes are implemented. For cross-repository pull requests\n   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.\n   */\n  headRefName: Scalars['String']['input'];\n  /** The Node ID of the head repository. */\n  headRepositoryId?: InputMaybe<Scalars['ID']['input']>;\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n  /** The title of the pull request. */\n  title: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of CreatePullRequest */\nexport type CreatePullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of CreateRef */\nexport type CreateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */\n  name: Scalars['String']['input'];\n  /** The GitObjectID that the new Ref shall target. Must point to a commit. */\n  oid: Scalars['GitObjectID']['input'];\n  /** The Node ID of the Repository to create the Ref in. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of CreateRef */\nexport type CreateRefPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of CreateRepository */\nexport type CreateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A short description of the new repository. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The URL for a web page about this repository. */\n  homepageUrl?: InputMaybe<Scalars['URI']['input']>;\n  /** The name of the new repository. */\n  name: Scalars['String']['input'];\n  /** The ID of the owner for the new repository. */\n  ownerId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * When an organization is specified as the owner, this ID identifies the team\n   * that should be granted access to the new repository.\n   */\n  teamId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** Autogenerated return type of CreateRepository */\nexport type CreateRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of CreateRepositoryRuleset */\nexport type CreateRepositoryRulesetInput = {\n  /** A list of actors that are allowed to bypass rules in this ruleset. */\n  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The set of conditions for this ruleset */\n  conditions: RepositoryRuleConditionsInput;\n  /** The enforcement level for this ruleset */\n  enforcement: RuleEnforcement;\n  /** The name of the ruleset. */\n  name: Scalars['String']['input'];\n  /** The list of rules for this ruleset */\n  rules?: InputMaybe<Array<RepositoryRuleInput>>;\n  /** The global relay id of the source in which a new ruleset should be created in. */\n  sourceId: Scalars['ID']['input'];\n  /** The target of the ruleset. */\n  target?: InputMaybe<RepositoryRulesetTarget>;\n};\n\n/** Autogenerated return type of CreateRepositoryRuleset */\nexport type CreateRepositoryRulesetPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created Ruleset. */\n  ruleset?: Maybe<RepositoryRuleset>;\n};\n\n/** Autogenerated input type of CreateSponsorsListing */\nexport type CreateSponsorsListingInput = {\n  /**\n   * The country or region where the sponsorable's bank account is located.\n   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.\n   */\n  billingCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The email address we should use to contact you about the GitHub Sponsors\n   * profile being created. This will not be shared publicly. Must be a verified\n   * email address already on your GitHub account. Only relevant when the\n   * sponsorable is yourself. Defaults to your primary email address on file if omitted.\n   */\n  contactEmail?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The username of the supported fiscal host's GitHub organization, if you want\n   * to receive sponsorship payouts through a fiscal host rather than directly to a\n   * bank account. For example, 'Open-Source-Collective' for Open Source Collective\n   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts\n   * for more information.\n   */\n  fiscalHostLogin?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The URL for your profile page on the fiscal host's website, e.g.,\n   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.\n   * Required if fiscalHostLogin is specified.\n   */\n  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Provide an introduction to serve as the main focus that appears on your GitHub\n   * Sponsors profile. It's a great opportunity to help potential sponsors learn\n   * more about you, your work, and why their sponsorship is important to you.\n   * GitHub-flavored Markdown is supported.\n   */\n  fullDescription?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The country or region where the sponsorable resides. This is for tax purposes.\n   * Required if the sponsorable is yourself, ignored when sponsorableLogin\n   * specifies an organization.\n   */\n  residenceCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;\n  /**\n   * The username of the organization to create a GitHub Sponsors profile for, if\n   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated\n   * user if omitted.\n   */\n  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of CreateSponsorsListing */\nexport type CreateSponsorsListingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new GitHub Sponsors profile. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n};\n\n/** Autogenerated input type of CreateSponsorsTier */\nexport type CreateSponsorsTierInput = {\n  /** The value of the new tier in US dollars. Valid values: 1-12000. */\n  amount: Scalars['Int']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */\n  description: Scalars['String']['input'];\n  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */\n  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * Whether to make the tier available immediately for sponsors to choose.\n   * Defaults to creating a draft tier that will not be publicly visible.\n   */\n  publish?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * Optional ID of the private repository that sponsors at this tier should gain\n   * read-only access to. Must be owned by an organization.\n   */\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * Optional name of the private repository that sponsors at this tier should gain\n   * read-only access to. Must be owned by an organization. Necessary if\n   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.\n   */\n  repositoryName?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Optional login of the organization owner of the private repository that\n   * sponsors at this tier should gain read-only access to. Necessary if\n   * repositoryName is given. Will be ignored if repositoryId is given.\n   */\n  repositoryOwnerLogin?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The ID of the user or organization who owns the GitHub Sponsors profile.\n   * Defaults to the current user if omitted and sponsorableLogin is not given.\n   */\n  sponsorableId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The username of the user or organization who owns the GitHub Sponsors profile.\n   * Defaults to the current user if omitted and sponsorableId is not given.\n   */\n  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;\n  /** Optional message new sponsors at this tier will receive. */\n  welcomeMessage?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of CreateSponsorsTier */\nexport type CreateSponsorsTierPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new tier. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of CreateSponsorship */\nexport type CreateSponsorshipInput = {\n  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */\n  amount?: InputMaybe<Scalars['Int']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */\n  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']['input']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */\n  tierId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of CreateSponsorship */\nexport type CreateSponsorshipPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The sponsorship that was started. */\n  sponsorship?: Maybe<Sponsorship>;\n};\n\n/** Autogenerated input type of CreateSponsorships */\nexport type CreateSponsorshipsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorables. Public visibility still does not reveal the dollar value of\n   * the sponsorship.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorables. */\n  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */\n  sponsorLogin: Scalars['String']['input'];\n  /** The list of maintainers to sponsor and for how much apiece. */\n  sponsorships: Array<BulkSponsorship>;\n};\n\n/** Autogenerated return type of CreateSponsorships */\nexport type CreateSponsorshipsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The users and organizations who received a sponsorship. */\n  sponsorables?: Maybe<Array<Sponsorable>>;\n};\n\n/** Autogenerated input type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentInput = {\n  /**\n   * The content of the comment. This field is required.\n   *\n   * **Upcoming Change on 2024-07-01 UTC**\n   * **Description:** `body` will be removed. Follow the guide at\n   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to\n   * find a suitable replacement.\n   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.\n   */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The ID of the discussion to which the comment belongs. This field is required.\n   *\n   * **Upcoming Change on 2024-07-01 UTC**\n   * **Description:** `discussionId` will be removed. Follow the guide at\n   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to\n   * find a suitable replacement.\n   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.\n   */\n  discussionId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /**\n   * The new comment.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>;\n};\n\n/** Autogenerated input type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionInput = {\n  /**\n   * The content of the discussion. This field is required.\n   *\n   * **Upcoming Change on 2024-07-01 UTC**\n   * **Description:** `body` will be removed. Follow the guide at\n   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to\n   * find a suitable replacement.\n   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.\n   */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * If true, restricts the visibility of this discussion to team members and\n   * organization admins. If false or not specified, allows any organization member\n   * to view this discussion.\n   *\n   * **Upcoming Change on 2024-07-01 UTC**\n   * **Description:** `private` will be removed. Follow the guide at\n   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to\n   * find a suitable replacement.\n   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.\n   */\n  private?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * The ID of the team to which the discussion belongs. This field is required.\n   *\n   * **Upcoming Change on 2024-07-01 UTC**\n   * **Description:** `teamId` will be removed. Follow the guide at\n   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to\n   * find a suitable replacement.\n   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.\n   */\n  teamId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The title of the discussion. This field is required.\n   *\n   * **Upcoming Change on 2024-07-01 UTC**\n   * **Description:** `title` will be removed. Follow the guide at\n   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to\n   * find a suitable replacement.\n   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.\n   */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /**\n   * The new discussion.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  teamDiscussion?: Maybe<TeamDiscussion>;\n};\n\n/** Represents the contribution a user made by committing to a repository. */\nexport type CreatedCommitContribution = Contribution & {\n  /** How many commits were made on this day to this repository by the user. */\n  commitCount: Scalars['Int']['output'];\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The repository the user made a commit in. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedCommitContribution. */\nexport type CreatedCommitContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedCommitContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedCommitContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of commits across days and repositories in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CreatedCommitContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedCommitContribution>;\n};\n\n/** Represents the contribution a user made on GitHub by opening an issue. */\nexport type CreatedIssueContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** The issue that was opened. */\n  issue: Issue;\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedIssueContribution. */\nexport type CreatedIssueContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedIssueContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedIssueContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CreatedIssueContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedIssueContribution>;\n};\n\n/** Represents either a issue the viewer can access or a restricted contribution. */\nexport type CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution;\n\n/** Represents the contribution a user made on GitHub by opening a pull request. */\nexport type CreatedPullRequestContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The pull request that was opened. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedPullRequestContribution. */\nexport type CreatedPullRequestContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CreatedPullRequestContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestContribution>;\n};\n\n/** Represents either a pull request the viewer can access or a restricted contribution. */\nexport type CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution;\n\n/** Represents the contribution a user made by leaving a review on a pull request. */\nexport type CreatedPullRequestReviewContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The pull request the user reviewed. */\n  pullRequest: PullRequest;\n  /** The review the user left on the pull request. */\n  pullRequestReview: PullRequestReview;\n  /** The repository containing the pull request that the user reviewed. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedPullRequestReviewContribution. */\nexport type CreatedPullRequestReviewContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestReviewContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestReviewContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CreatedPullRequestReviewContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestReviewContribution>;\n};\n\n/** Represents the contribution a user made on GitHub by creating a repository. */\nexport type CreatedRepositoryContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The repository that was created. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedRepositoryContribution. */\nexport type CreatedRepositoryContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedRepositoryContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedRepositoryContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type CreatedRepositoryContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedRepositoryContribution>;\n};\n\n/** Represents either a repository the viewer can access or a restricted contribution. */\nexport type CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution;\n\n/** Represents a mention made by one issue or pull request to another. */\nexport type CrossReferencedEvent = Node & UniformResourceLocatable & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']['output'];\n  /** Identifies when the reference was made. */\n  referencedAt: Scalars['DateTime']['output'];\n  /** The HTTP path for this pull request. */\n  resourcePath: Scalars['URI']['output'];\n  /** Issue or pull request that made the reference. */\n  source: ReferencedSubject;\n  /** Issue or pull request to which the reference was made. */\n  target: ReferencedSubject;\n  /** The HTTP URL for this pull request. */\n  url: Scalars['URI']['output'];\n  /** Checks if the target will be closed when the source is merged. */\n  willCloseTarget: Scalars['Boolean']['output'];\n};\n\n/** Autogenerated input type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the suggested topic. */\n  name: Scalars['String']['input'];\n  /** The reason why the suggested topic is declined. */\n  reason: TopicSuggestionDeclineReason;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The declined topic. */\n  topic?: Maybe<Topic>;\n};\n\n/** The possible base permissions for repositories. */\nexport enum DefaultRepositoryPermissionField {\n  /** Can read, write, and administrate repos by default */\n  Admin = 'ADMIN',\n  /** No access */\n  None = 'NONE',\n  /** Can read repos by default */\n  Read = 'READ',\n  /** Can read and write repos by default */\n  Write = 'WRITE'\n}\n\n/** Entities that can be deleted. */\nexport type Deletable = {\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n};\n\n/** Autogenerated input type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRuleInput = {\n  /** The global relay id of the branch protection rule to be deleted. */\n  branchProtectionRuleId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRulePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteDeployment */\nexport type DeleteDeploymentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the deployment to be deleted. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteDeployment */\nexport type DeleteDeploymentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node id of the discussion comment to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion comment that was just deleted. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of DeleteDiscussion */\nexport type DeleteDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the discussion to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteDiscussion */\nexport type DeleteDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion that was just deleted. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of DeleteEnvironment */\nexport type DeleteEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the environment to be deleted. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteEnvironment */\nexport type DeleteEnvironmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the IP allow list entry to delete. */\n  ipAllowListEntryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The IP allow list entry that was deleted. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of DeleteIssueComment */\nexport type DeleteIssueCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteIssueComment */\nexport type DeleteIssueCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteIssue */\nexport type DeleteIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the issue to delete. */\n  issueId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteIssue */\nexport type DeleteIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository the issue belonged to */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of DeleteLinkedBranch */\nexport type DeleteLinkedBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the linked branch */\n  linkedBranchId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteLinkedBranch */\nexport type DeleteLinkedBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue the linked branch was unlinked from. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of DeleteProjectCard */\nexport type DeleteProjectCardInput = {\n  /** The id of the card to delete. */\n  cardId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of DeleteProjectCard */\nexport type DeleteProjectCardPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The column the deleted card was in. */\n  column?: Maybe<ProjectColumn>;\n  /** The deleted card ID. */\n  deletedCardId?: Maybe<Scalars['ID']['output']>;\n};\n\n/** Autogenerated input type of DeleteProjectColumn */\nexport type DeleteProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the column to delete. */\n  columnId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteProjectColumn */\nexport type DeleteProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The deleted column ID. */\n  deletedColumnId?: Maybe<Scalars['ID']['output']>;\n  /** The project the deleted column was in. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of DeleteProject */\nexport type DeleteProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Project ID to update. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteProject */\nexport type DeleteProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository or organization the project was removed from. */\n  owner?: Maybe<ProjectOwner>;\n};\n\n/** Autogenerated input type of DeleteProjectV2Field */\nexport type DeleteProjectV2FieldInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the field to delete. */\n  fieldId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteProjectV2Field */\nexport type DeleteProjectV2FieldPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The deleted field. */\n  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;\n};\n\n/** Autogenerated input type of DeleteProjectV2 */\nexport type DeleteProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Project to delete. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated input type of DeleteProjectV2Item */\nexport type DeleteProjectV2ItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the item to be removed. */\n  itemId: Scalars['ID']['input'];\n  /** The ID of the Project from which the item should be removed. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteProjectV2Item */\nexport type DeleteProjectV2ItemPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The ID of the deleted item. */\n  deletedItemId?: Maybe<Scalars['ID']['output']>;\n};\n\n/** Autogenerated return type of DeleteProjectV2 */\nexport type DeleteProjectV2Payload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The deleted Project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of DeleteProjectV2Workflow */\nexport type DeleteProjectV2WorkflowInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the workflow to be removed. */\n  workflowId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteProjectV2Workflow */\nexport type DeleteProjectV2WorkflowPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The ID of the deleted workflow. */\n  deletedWorkflowId?: Maybe<Scalars['ID']['output']>;\n  /** The project the deleted workflow was in. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request review the deleted comment belonged to. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** The deleted pull request review comment. */\n  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;\n};\n\n/** Autogenerated input type of DeletePullRequestReview */\nexport type DeletePullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the pull request review to delete. */\n  pullRequestReviewId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeletePullRequestReview */\nexport type DeletePullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The deleted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of DeleteRef */\nexport type DeleteRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the Ref to be deleted. */\n  refId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteRef */\nexport type DeleteRefPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteRepositoryRuleset */\nexport type DeleteRepositoryRulesetInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The global relay id of the repository ruleset to be deleted. */\n  repositoryRulesetId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteRepositoryRuleset */\nexport type DeleteRepositoryRulesetPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The discussion ID to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the verifiable domain to delete. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The owning account from which the domain was deleted. */\n  owner?: Maybe<VerifiableDomainOwner>;\n};\n\n/** Represents a 'demilestoned' event on a given issue or pull request. */\nexport type DemilestonedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the milestone title associated with the 'demilestoned' event. */\n  milestoneTitle: Scalars['String']['output'];\n  /** Object referenced by event. */\n  subject: MilestoneItem;\n};\n\n/** A Dependabot Update for a dependency in a repository */\nexport type DependabotUpdate = RepositoryNode & {\n  /** The error from a dependency update */\n  error?: Maybe<DependabotUpdateError>;\n  /** The associated pull request */\n  pullRequest?: Maybe<PullRequest>;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n/** An error produced from a Dependabot Update */\nexport type DependabotUpdateError = {\n  /** The body of the error */\n  body: Scalars['String']['output'];\n  /** The error code */\n  errorType: Scalars['String']['output'];\n  /** The title of the error */\n  title: Scalars['String']['output'];\n};\n\n/** The possible ecosystems of a dependency graph package. */\nexport enum DependencyGraphEcosystem {\n  /** GitHub Actions */\n  Actions = 'ACTIONS',\n  /** PHP packages hosted at packagist.org */\n  Composer = 'COMPOSER',\n  /** Go modules */\n  Go = 'GO',\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = 'MAVEN',\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = 'NPM',\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = 'NUGET',\n  /** Python packages hosted at PyPI.org */\n  Pip = 'PIP',\n  /** Dart packages hosted at pub.dev */\n  Pub = 'PUB',\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = 'RUBYGEMS',\n  /** Rust crates */\n  Rust = 'RUST',\n  /** Swift packages */\n  Swift = 'SWIFT'\n}\n\n/** A repository deploy key. */\nexport type DeployKey = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The deploy key. */\n  key: Scalars['String']['output'];\n  /** Whether or not the deploy key is read only. */\n  readOnly: Scalars['Boolean']['output'];\n  /** The deploy key title. */\n  title: Scalars['String']['output'];\n  /** Whether or not the deploy key has been verified. */\n  verified: Scalars['Boolean']['output'];\n};\n\n/** The connection type for DeployKey. */\nexport type DeployKeyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeployKeyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeployKey>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeployKeyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeployKey>;\n};\n\n/** Represents a 'deployed' event on a given pull request. */\nexport type DeployedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The deployment associated with the 'deployed' event. */\n  deployment: Deployment;\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The ref associated with the 'deployed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents triggered deployment instance. */\nexport type Deployment = Node & {\n  /** Identifies the commit sha of the deployment. */\n  commit?: Maybe<Commit>;\n  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */\n  commitOid: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The deployment description. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The latest environment to which this deployment was made. */\n  environment?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The latest environment to which this deployment was made. */\n  latestEnvironment?: Maybe<Scalars['String']['output']>;\n  /** The latest status of this deployment. */\n  latestStatus?: Maybe<DeploymentStatus>;\n  /** The original environment to which this deployment was made. */\n  originalEnvironment?: Maybe<Scalars['String']['output']>;\n  /** Extra information that a deployment system might need. */\n  payload?: Maybe<Scalars['String']['output']>;\n  /** Identifies the Ref of the deployment, if the deployment was created by ref. */\n  ref?: Maybe<Ref>;\n  /** Identifies the repository associated with the deployment. */\n  repository: Repository;\n  /** The current state of the deployment. */\n  state?: Maybe<DeploymentState>;\n  /** A list of statuses associated with the deployment. */\n  statuses?: Maybe<DeploymentStatusConnection>;\n  /** The deployment task. */\n  task?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n\n/** Represents triggered deployment instance. */\nexport type DeploymentStatusesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for Deployment. */\nexport type DeploymentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Deployment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Deployment>;\n};\n\n/** Represents a 'deployment_environment_changed' event on a given pull request. */\nexport type DeploymentEnvironmentChangedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The deployment status that updated the deployment environment. */\n  deploymentStatus: DeploymentStatus;\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Ordering options for deployment connections */\nexport type DeploymentOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order deployments by. */\n  field: DeploymentOrderField;\n};\n\n/** Properties by which deployment connections can be ordered. */\nexport enum DeploymentOrderField {\n  /** Order collection by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** A protection rule. */\nexport type DeploymentProtectionRule = {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection;\n  /** The timeout in minutes for this protection rule. */\n  timeout: Scalars['Int']['output'];\n  /** The type of protection rule. */\n  type: DeploymentProtectionRuleType;\n};\n\n\n/** A protection rule. */\nexport type DeploymentProtectionRuleReviewersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for DeploymentProtectionRule. */\nexport type DeploymentProtectionRuleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentProtectionRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentProtectionRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentProtectionRuleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentProtectionRule>;\n};\n\n/** The possible protection rule types. */\nexport enum DeploymentProtectionRuleType {\n  /** Required reviewers */\n  RequiredReviewers = 'REQUIRED_REVIEWERS',\n  /** Wait timer */\n  WaitTimer = 'WAIT_TIMER'\n}\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequest = {\n  /** Whether or not the current user can approve the deployment */\n  currentUserCanApprove: Scalars['Boolean']['output'];\n  /** The target environment of the deployment */\n  environment: Environment;\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection;\n  /** The wait timer in minutes configured in the environment */\n  waitTimer: Scalars['Int']['output'];\n  /** The wait timer in minutes configured in the environment */\n  waitTimerStartedAt?: Maybe<Scalars['DateTime']['output']>;\n};\n\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequestReviewersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for DeploymentRequest. */\nexport type DeploymentRequestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentRequestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentRequest>;\n};\n\n/** A deployment review. */\nexport type DeploymentReview = Node & {\n  /** The comment the user left. */\n  comment: Scalars['String']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The environments approved or rejected */\n  environments: EnvironmentConnection;\n  id: Scalars['ID']['output'];\n  /** The decision of the user. */\n  state: DeploymentReviewState;\n  /** The user that reviewed the deployment. */\n  user: User;\n};\n\n\n/** A deployment review. */\nexport type DeploymentReviewEnvironmentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for DeploymentReview. */\nexport type DeploymentReviewConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReview>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentReviewEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReview>;\n};\n\n/** The possible states for a deployment review. */\nexport enum DeploymentReviewState {\n  /** The deployment was approved. */\n  Approved = 'APPROVED',\n  /** The deployment was rejected. */\n  Rejected = 'REJECTED'\n}\n\n/** Users and teams. */\nexport type DeploymentReviewer = Team | User;\n\n/** The connection type for DeploymentReviewer. */\nexport type DeploymentReviewerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReviewer>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentReviewerEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReviewer>;\n};\n\n/** The possible states in which a deployment can be. */\nexport enum DeploymentState {\n  /** The pending deployment was not updated after 30 minutes. */\n  Abandoned = 'ABANDONED',\n  /** The deployment is currently active. */\n  Active = 'ACTIVE',\n  /** An inactive transient deployment. */\n  Destroyed = 'DESTROYED',\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment has queued */\n  Queued = 'QUEUED',\n  /** The deployment was successful. */\n  Success = 'SUCCESS',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING'\n}\n\n/** Describes the status of a given deployment attempt. */\nexport type DeploymentStatus = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor;\n  /** Identifies the deployment associated with status. */\n  deployment: Deployment;\n  /** Identifies the description of the deployment. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** Identifies the environment URL of the deployment. */\n  environmentUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** Identifies the log URL of the deployment. */\n  logUrl?: Maybe<Scalars['URI']['output']>;\n  /** Identifies the current state of the deployment. */\n  state: DeploymentStatusState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for DeploymentStatus. */\nexport type DeploymentStatusConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentStatusEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentStatus>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentStatusEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentStatus>;\n};\n\n/** The possible states for a deployment status. */\nexport enum DeploymentStatusState {\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment is queued */\n  Queued = 'QUEUED',\n  /** The deployment was successful. */\n  Success = 'SUCCESS',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING'\n}\n\n/** Autogenerated input type of DequeuePullRequest */\nexport type DequeuePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the pull request to be dequeued. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DequeuePullRequest */\nexport type DequeuePullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The merge queue entry of the dequeued pull request. */\n  mergeQueueEntry?: Maybe<MergeQueueEntry>;\n};\n\n/** The possible sides of a diff. */\nexport enum DiffSide {\n  /** The left side of the diff. */\n  Left = 'LEFT',\n  /** The right side of the diff. */\n  Right = 'RIGHT'\n}\n\n/** Autogenerated input type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergeInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the pull request to disable auto merge on. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request auto merge was disabled on. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'disconnected' event on a given issue or pull request. */\nexport type DisconnectedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']['output'];\n  /** Issue or pull request from which the issue was disconnected. */\n  source: ReferencedSubject;\n  /** Issue or pull request which was disconnected. */\n  subject: ReferencedSubject;\n};\n\n/** A discussion in a repository. */\nexport type Discussion = Closable & Comment & Deletable & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & Updatable & Votable & {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** The comment chosen as this discussion's answer, if any. */\n  answer?: Maybe<DiscussionComment>;\n  /** The time when a user chose this discussion's answer, if answered. */\n  answerChosenAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The user who chose this discussion's answer, if answered. */\n  answerChosenBy?: Maybe<Actor>;\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The main text of the discussion post. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** The category for this discussion. */\n  category: DiscussionCategory;\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The replies to the discussion. */\n  comments: DiscussionCommentConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean']['output'];\n  /** The number identifying this discussion within the repository. */\n  number: Scalars['Int']['output'];\n  /** The poll associated with this discussion, if one exists. */\n  poll?: Maybe<DiscussionPoll>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The path for this discussion. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the reason for the discussion's state. */\n  stateReason?: Maybe<DiscussionStateReason>;\n  /** The title of this discussion. */\n  title: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int']['output'];\n  /** The URL for this discussion. */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean']['output'];\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A category for discussions in a repository. */\nexport type DiscussionCategory = Node & RepositoryNode & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** A description of this category. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** An emoji representing this category. */\n  emoji: Scalars['String']['output'];\n  /** This category's emoji rendered as HTML. */\n  emojiHTML: Scalars['HTML']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */\n  isAnswerable: Scalars['Boolean']['output'];\n  /** The name of this category. */\n  name: Scalars['String']['output'];\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The slug of this category. */\n  slug: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for DiscussionCategory. */\nexport type DiscussionCategoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCategoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionCategory>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionCategoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionCategory>;\n};\n\n/** The possible reasons for closing a discussion. */\nexport enum DiscussionCloseReason {\n  /** The discussion is a duplicate of another */\n  Duplicate = 'DUPLICATE',\n  /** The discussion is no longer relevant */\n  Outdated = 'OUTDATED',\n  /** The discussion has been resolved */\n  Resolved = 'RESOLVED'\n}\n\n/** A comment on a discussion. */\nexport type DiscussionComment = Comment & Deletable & Minimizable & Node & Reactable & Updatable & UpdatableComment & Votable & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The time when this replied-to comment was deleted */\n  deletedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The discussion this comment was created in */\n  discussion?: Maybe<Discussion>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** Has this comment been chosen as the answer of its discussion? */\n  isAnswer: Scalars['Boolean']['output'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']['output']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The threaded replies to this comment. */\n  replies: DiscussionCommentConnection;\n  /** The discussion comment this comment is a reply to */\n  replyTo?: Maybe<DiscussionComment>;\n  /** The path for this discussion comment. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int']['output'];\n  /** The URL for this discussion comment. */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Can the current user mark this comment as an answer? */\n  viewerCanMarkAsAnswer: Scalars['Boolean']['output'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Can the current user unmark this comment as an answer? */\n  viewerCanUnmarkAsAnswer: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean']['output'];\n};\n\n\n/** A comment on a discussion. */\nexport type DiscussionCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A comment on a discussion. */\nexport type DiscussionCommentRepliesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A comment on a discussion. */\nexport type DiscussionCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for DiscussionComment. */\nexport type DiscussionCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionComment>;\n};\n\n/** The connection type for Discussion. */\nexport type DiscussionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Discussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Discussion>;\n};\n\n/** Ways in which lists of discussions can be ordered upon return. */\nexport type DiscussionOrder = {\n  /** The direction in which to order discussions by the specified field. */\n  direction: OrderDirection;\n  /** The field by which to order discussions. */\n  field: DiscussionOrderField;\n};\n\n/** Properties by which discussion connections can be ordered. */\nexport enum DiscussionOrderField {\n  /** Order discussions by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order discussions by most recent modification time. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** A poll for a discussion. */\nexport type DiscussionPoll = Node & {\n  /** The discussion that this poll belongs to. */\n  discussion?: Maybe<Discussion>;\n  id: Scalars['ID']['output'];\n  /** The options for this poll. */\n  options?: Maybe<DiscussionPollOptionConnection>;\n  /** The question that is being asked by this poll. */\n  question: Scalars['String']['output'];\n  /** The total number of votes that have been cast for this poll. */\n  totalVoteCount: Scalars['Int']['output'];\n  /** Indicates if the viewer has permission to vote in this poll. */\n  viewerCanVote: Scalars['Boolean']['output'];\n  /** Indicates if the viewer has voted for any option in this poll. */\n  viewerHasVoted: Scalars['Boolean']['output'];\n};\n\n\n/** A poll for a discussion. */\nexport type DiscussionPollOptionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DiscussionPollOptionOrder>;\n};\n\n/** An option for a discussion poll. */\nexport type DiscussionPollOption = Node & {\n  id: Scalars['ID']['output'];\n  /** The text for this option. */\n  option: Scalars['String']['output'];\n  /** The discussion poll that this option belongs to. */\n  poll?: Maybe<DiscussionPoll>;\n  /** The total number of votes that have been cast for this option. */\n  totalVoteCount: Scalars['Int']['output'];\n  /** Indicates if the viewer has voted for this option in the poll. */\n  viewerHasVoted: Scalars['Boolean']['output'];\n};\n\n/** The connection type for DiscussionPollOption. */\nexport type DiscussionPollOptionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionPollOptionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionPollOption>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionPollOptionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionPollOption>;\n};\n\n/** Ordering options for discussion poll option connections. */\nexport type DiscussionPollOptionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order poll options by. */\n  field: DiscussionPollOptionOrderField;\n};\n\n/** Properties by which discussion poll option connections can be ordered. */\nexport enum DiscussionPollOptionOrderField {\n  /** Order poll options by the order that the poll author specified when creating the poll. */\n  AuthoredOrder = 'AUTHORED_ORDER',\n  /** Order poll options by the number of votes it has. */\n  VoteCount = 'VOTE_COUNT'\n}\n\n/** The possible states of a discussion. */\nexport enum DiscussionState {\n  /** A discussion that has been closed */\n  Closed = 'CLOSED',\n  /** A discussion that is open */\n  Open = 'OPEN'\n}\n\n/** The possible state reasons of a discussion. */\nexport enum DiscussionStateReason {\n  /** The discussion is a duplicate of another */\n  Duplicate = 'DUPLICATE',\n  /** The discussion is no longer relevant */\n  Outdated = 'OUTDATED',\n  /** The discussion was reopened */\n  Reopened = 'REOPENED',\n  /** The discussion has been resolved */\n  Resolved = 'RESOLVED'\n}\n\n/** Autogenerated input type of DismissPullRequestReview */\nexport type DismissPullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The contents of the pull request review dismissal message. */\n  message: Scalars['String']['input'];\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DismissPullRequestReview */\nexport type DismissPullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The dismissed pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** The possible reasons that a Dependabot alert was dismissed. */\nexport enum DismissReason {\n  /** A fix has already been started */\n  FixStarted = 'FIX_STARTED',\n  /** This alert is inaccurate or incorrect */\n  Inaccurate = 'INACCURATE',\n  /** Vulnerable code is not actually used */\n  NotUsed = 'NOT_USED',\n  /** No bandwidth to fix this */\n  NoBandwidth = 'NO_BANDWIDTH',\n  /** Risk is tolerable to this project */\n  TolerableRisk = 'TOLERABLE_RISK'\n}\n\n/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The reason the Dependabot alert is being dismissed. */\n  dismissReason: DismissReason;\n  /** The Dependabot alert ID to dismiss. */\n  repositoryVulnerabilityAlertId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The Dependabot alert that was dismissed */\n  repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;\n};\n\n/** A draft issue within a project. */\nexport type DraftIssue = Node & {\n  /** A list of users to assigned to this draft issue. */\n  assignees: UserConnection;\n  /** The body of the draft issue. */\n  body: Scalars['String']['output'];\n  /** The body of the draft issue rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body of the draft issue rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created this draft issue. */\n  creator?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */\n  projectV2Items: ProjectV2ItemConnection;\n  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */\n  projectsV2: ProjectV2Connection;\n  /** The title of the draft issue */\n  title: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n\n/** A draft issue within a project. */\nexport type DraftIssueAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A draft issue within a project. */\nexport type DraftIssueProjectV2ItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A draft issue within a project. */\nexport type DraftIssueProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Specifies a review comment to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewComment = {\n  /** Body of the comment to leave. */\n  body: Scalars['String']['input'];\n  /** Path to the file being commented on. */\n  path: Scalars['String']['input'];\n  /** Position in the file to leave a comment on. */\n  position: Scalars['Int']['input'];\n};\n\n/** Specifies a review comment thread to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewThread = {\n  /** Body of the comment to leave. */\n  body: Scalars['String']['input'];\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars['Int']['input'];\n  /** Path to the file being commented on. */\n  path: Scalars['String']['input'];\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: InputMaybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: InputMaybe<Scalars['Int']['input']>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: InputMaybe<DiffSide>;\n};\n\n/** Autogenerated input type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergeInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Commit body to use for the commit when the PR is mergable; if omitted, a\n   * default message will be used. NOTE: when merging with a merge queue any input\n   * value for commit message is ignored.\n   */\n  commitBody?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Commit headline to use for the commit when the PR is mergable; if omitted, a\n   * default message will be used. NOTE: when merging with a merge queue any input\n   * value for commit headline is ignored.\n   */\n  commitHeadline?: InputMaybe<Scalars['String']['input']>;\n  /** The expected head OID of the pull request. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;\n  /**\n   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging\n   * with a merge queue any input value for merge method is ignored.\n   */\n  mergeMethod?: InputMaybe<PullRequestMergeMethod>;\n  /** ID of the pull request to enable auto-merge on. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request auto-merge was enabled on. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of EnqueuePullRequest */\nexport type EnqueuePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The expected head OID of the pull request. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;\n  /** Add the pull request to the front of the queue. */\n  jump?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the pull request to enqueue. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of EnqueuePullRequest */\nexport type EnqueuePullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The merge queue entry for the enqueued pull request. */\n  mergeQueueEntry?: Maybe<MergeQueueEntry>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type Enterprise = AnnouncementBanner & Node & {\n  /** The text of the announcement */\n  announcement?: Maybe<Scalars['String']['output']>;\n  /** The expiration date of the announcement, if any */\n  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Whether the announcement can be dismissed by the user */\n  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;\n  /** A URL pointing to the enterprise's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** Enterprise billing information\u00A0visible to enterprise billing managers. */\n  billingInfo?: Maybe<EnterpriseBillingInfo>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The description of the enterprise. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The description of the enterprise as HTML. */\n  descriptionHTML: Scalars['HTML']['output'];\n  id: Scalars['ID']['output'];\n  /** The location of the enterprise. */\n  location?: Maybe<Scalars['String']['output']>;\n  /** A list of users who are members of this enterprise. */\n  members: EnterpriseMemberConnection;\n  /** The name of the enterprise. */\n  name: Scalars['String']['output'];\n  /** A list of organizations that belong to this enterprise. */\n  organizations: OrganizationConnection;\n  /**\n   * Enterprise information visible to enterprise owners or enterprise owners'\n   * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n   */\n  ownerInfo?: Maybe<EnterpriseOwnerInfo>;\n  /** The HTTP path for this enterprise. */\n  resourcePath: Scalars['URI']['output'];\n  /** The URL-friendly identifier for the enterprise. */\n  slug: Scalars['String']['output'];\n  /** The HTTP URL for this enterprise. */\n  url: Scalars['URI']['output'];\n  /** Is the current viewer an admin of this enterprise? */\n  viewerIsAdmin: Scalars['Boolean']['output'];\n  /** The URL of the enterprise website. */\n  websiteUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseMembersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  deployment?: InputMaybe<EnterpriseUserDeployment>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  viewerOrganizationRole?: InputMaybe<RoleInOrganization>;\n};\n\n/** The connection type for User. */\nexport type EnterpriseAdministratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** A User who is an administrator of an enterprise. */\nexport type EnterpriseAdministratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role of the administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n/** An invitation for a user to become an owner or billing manager of an enterprise. */\nexport type EnterpriseAdministratorInvitation = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The email of the person who was invited to the enterprise. */\n  email?: Maybe<Scalars['String']['output']>;\n  /** The enterprise the invitation is for. */\n  enterprise: Enterprise;\n  id: Scalars['ID']['output'];\n  /** The user who was invited to the enterprise. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter?: Maybe<User>;\n  /** The invitee's pending role in the enterprise (owner or billing_manager). */\n  role: EnterpriseAdministratorRole;\n};\n\n/** The connection type for EnterpriseAdministratorInvitation. */\nexport type EnterpriseAdministratorInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseAdministratorInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseAdministratorInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseAdministratorInvitation>;\n};\n\n/** Ordering options for enterprise administrator invitation connections */\nexport type EnterpriseAdministratorInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise administrator invitations by. */\n  field: EnterpriseAdministratorInvitationOrderField;\n};\n\n/** Properties by which enterprise administrator invitation connections can be ordered. */\nexport enum EnterpriseAdministratorInvitationOrderField {\n  /** Order enterprise administrator member invitations by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible administrator roles in an enterprise account. */\nexport enum EnterpriseAdministratorRole {\n  /** Represents a billing manager of the enterprise account. */\n  BillingManager = 'BILLING_MANAGER',\n  /** Represents an owner of the enterprise account. */\n  Owner = 'OWNER'\n}\n\n/** The possible values for the enterprise allow private repository forking policy value. */\nexport enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {\n  /** Members can fork a repository to an organization within this enterprise. */\n  EnterpriseOrganizations = 'ENTERPRISE_ORGANIZATIONS',\n  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */\n  EnterpriseOrganizationsUserAccounts = 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS',\n  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */\n  Everywhere = 'EVERYWHERE',\n  /** Members can fork a repository only within the same organization (intra-org). */\n  SameOrganization = 'SAME_ORGANIZATION',\n  /** Members can fork a repository to their user account or within the same organization. */\n  SameOrganizationUserAccounts = 'SAME_ORGANIZATION_USER_ACCOUNTS',\n  /** Members can fork a repository to their user account. */\n  UserAccounts = 'USER_ACCOUNTS'\n}\n\n/** Metadata for an audit entry containing enterprise account information. */\nexport type EnterpriseAuditEntryData = {\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Enterprise billing information visible to enterprise billing managers and owners. */\nexport type EnterpriseBillingInfo = {\n  /** The number of licenseable users/emails across the enterprise. */\n  allLicensableUsersCount: Scalars['Int']['output'];\n  /** The number of data packs used by all organizations owned by the enterprise. */\n  assetPacks: Scalars['Int']['output'];\n  /** The bandwidth quota in GB for all organizations owned by the enterprise. */\n  bandwidthQuota: Scalars['Float']['output'];\n  /** The bandwidth usage in GB for all organizations owned by the enterprise. */\n  bandwidthUsage: Scalars['Float']['output'];\n  /** The bandwidth usage as a percentage of the bandwidth quota. */\n  bandwidthUsagePercentage: Scalars['Int']['output'];\n  /** The storage quota in GB for all organizations owned by the enterprise. */\n  storageQuota: Scalars['Float']['output'];\n  /** The storage usage in GB for all organizations owned by the enterprise. */\n  storageUsage: Scalars['Float']['output'];\n  /** The storage usage as a percentage of the storage quota. */\n  storageUsagePercentage: Scalars['Int']['output'];\n  /** The number of available licenses across all owned organizations based on the unique number of billable users. */\n  totalAvailableLicenses: Scalars['Int']['output'];\n  /** The total number of licenses allocated. */\n  totalLicenses: Scalars['Int']['output'];\n};\n\n/** The possible values for the enterprise base repository permission setting. */\nexport enum EnterpriseDefaultRepositoryPermissionSettingValue {\n  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */\n  Admin = 'ADMIN',\n  /** Organization members will only be able to clone and pull public repositories. */\n  None = 'NONE',\n  /** Organizations in the enterprise choose base repository permissions for their members. */\n  NoPolicy = 'NO_POLICY',\n  /** Organization members will be able to clone and pull all organization repositories. */\n  Read = 'READ',\n  /** Organization members will be able to clone, pull, and push all organization repositories. */\n  Write = 'WRITE'\n}\n\n/** The possible values for an enabled/disabled enterprise setting. */\nexport enum EnterpriseEnabledDisabledSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY'\n}\n\n/** The possible values for an enabled/no policy enterprise setting. */\nexport enum EnterpriseEnabledSettingValue {\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY'\n}\n\n/** The connection type for OrganizationInvitation. */\nexport type EnterpriseFailedInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseFailedInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** Identifies the total count of unique users in the connection. */\n  totalUniqueUserCount: Scalars['Int']['output'];\n};\n\n/** A failed invitation to be a member in an enterprise organization. */\nexport type EnterpriseFailedInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/**\n * An identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseIdentityProvider = Node & {\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod?: Maybe<SamlDigestAlgorithm>;\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>;\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars['ID']['output'];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars['X509Certificate']['output']>;\n  /** The Issuer Entity ID for the SAML identity provider. */\n  issuer?: Maybe<Scalars['String']['output']>;\n  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */\n  recoveryCodes?: Maybe<Array<Scalars['String']['output']>>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod?: Maybe<SamlSignatureAlgorithm>;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/**\n * An identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseIdentityProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  login?: InputMaybe<Scalars['String']['input']>;\n  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  userName?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** An object that is a member of an enterprise. */\nexport type EnterpriseMember = EnterpriseUserAccount | User;\n\n/** The connection type for EnterpriseMember. */\nexport type EnterpriseMemberConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseMember>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** A User who is a member of an enterprise through one or more organizations. */\nexport type EnterpriseMemberEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseMember>;\n};\n\n/** Ordering options for enterprise member connections. */\nexport type EnterpriseMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise members by. */\n  field: EnterpriseMemberOrderField;\n};\n\n/** Properties by which enterprise member connections can be ordered. */\nexport enum EnterpriseMemberOrderField {\n  /** Order enterprise members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order enterprise members by login */\n  Login = 'LOGIN'\n}\n\n/** The possible values for the enterprise members can create repositories setting. */\nexport enum EnterpriseMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Organization administrators choose whether to allow members to create repositories. */\n  NoPolicy = 'NO_POLICY',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE',\n  /** Members will be able to create only public repositories. */\n  Public = 'PUBLIC'\n}\n\n/** The possible values for the members can make purchases setting. */\nexport enum EnterpriseMembersCanMakePurchasesSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED'\n}\n\n/** The connection type for Organization. */\nexport type EnterpriseOrganizationMembershipConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOrganizationMembershipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An enterprise organization that a user is a member of. */\nexport type EnterpriseOrganizationMembershipEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>;\n  /** The role of the user in the enterprise membership. */\n  role: EnterpriseUserAccountMembershipRole;\n};\n\n/** The connection type for User. */\nexport type EnterpriseOutsideCollaboratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOutsideCollaboratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The enterprise organization repositories this user is a member of. */\n  repositories: EnterpriseRepositoryInfoConnection;\n};\n\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n};\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfo = {\n  /** A list of all of the administrators for this enterprise. */\n  admins: EnterpriseAdministratorConnection;\n  /** A list of users in the enterprise who currently have two-factor authentication disabled. */\n  affiliatedUsersWithTwoFactorDisabled: UserConnection;\n  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */\n  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean']['output'];\n  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */\n  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided private repository forking setting value. */\n  allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection;\n  /** The value for the allow private repository forking policy on the enterprise. */\n  allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;\n  /** The setting value for base repository permissions for organizations in this enterprise. */\n  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;\n  /** A list of enterprise organizations configured with the provided base repository permission. */\n  defaultRepositoryPermissionSettingOrganizations: OrganizationConnection;\n  /**\n   * A list of domains owned by the enterprise. Visible to enterprise owners or\n   * enterprise owners' personal access tokens (classic) with admin:enterprise scope.\n   */\n  domains: VerifiableDomainConnection;\n  /** Enterprise Server installations owned by the enterprise. */\n  enterpriseServerInstallations: EnterpriseServerInstallationConnection;\n  /** A list of failed invitations in the enterprise. */\n  failedInvitations: EnterpriseFailedInvitationConnection;\n  /** The setting value for whether the enterprise has an IP allow list enabled. */\n  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;\n  /**\n   * The IP addresses that are allowed to access resources owned by the enterprise.\n   * Visible to enterprise owners or enterprise owners' personal access tokens\n   * (classic) with admin:enterprise scope.\n   */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */\n  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;\n  /** Whether or not the base repository permission is currently being updated. */\n  isUpdatingDefaultRepositoryPermission: Scalars['Boolean']['output'];\n  /** Whether the two-factor authentication requirement is currently being enforced. */\n  isUpdatingTwoFactorRequirement: Scalars['Boolean']['output'];\n  /**\n   * The setting value for whether organization members with admin permissions on a\n   * repository can change repository visibility.\n   */\n  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */\n  membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */\n  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;\n  /** The setting value for whether members of organizations in the enterprise can create private repositories. */\n  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;\n  /** The setting value for whether members of organizations in the enterprise can create public repositories. */\n  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;\n  /** The setting value for whether members of organizations in the enterprise can create repositories. */\n  membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n  /** A list of enterprise organizations configured with the provided repository creation setting value. */\n  membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members with admin permissions for repositories can delete issues. */\n  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */\n  membersCanDeleteIssuesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */\n  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */\n  membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */\n  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */\n  membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection;\n  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */\n  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;\n  /** The setting value for whether members with admin permissions for repositories can update protected branches. */\n  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */\n  membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members can view dependency insights. */\n  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */\n  membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection;\n  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */\n  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;\n  /** The OIDC Identity Provider for the enterprise. */\n  oidcProvider?: Maybe<OidcProvider>;\n  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */\n  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided organization projects setting value. */\n  organizationProjectsSettingOrganizations: OrganizationConnection;\n  /** A list of outside collaborators across the repositories in the enterprise. */\n  outsideCollaborators: EnterpriseOutsideCollaboratorConnection;\n  /** A list of pending administrator invitations for the enterprise. */\n  pendingAdminInvitations: EnterpriseAdministratorInvitationConnection;\n  /** A list of pending collaborator invitations across the repositories in the enterprise. */\n  pendingCollaboratorInvitations: RepositoryInvitationConnection;\n  /** A list of pending member invitations for organizations in the enterprise. */\n  pendingMemberInvitations: EnterprisePendingMemberInvitationConnection;\n  /** The setting value for whether repository projects are enabled in this enterprise. */\n  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided repository projects setting value. */\n  repositoryProjectsSettingOrganizations: OrganizationConnection;\n  /** The SAML Identity Provider for the enterprise. */\n  samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>;\n  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */\n  samlIdentityProviderSettingOrganizations: OrganizationConnection;\n  /** A list of members with a support entitlement. */\n  supportEntitlements: EnterpriseMemberConnection;\n  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */\n  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided team discussions setting value. */\n  teamDiscussionsSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */\n  twoFactorRequiredSetting: EnterpriseEnabledSettingValue;\n  /** A list of enterprise organizations configured with the two-factor authentication setting value. */\n  twoFactorRequiredSettingOrganizations: OrganizationConnection;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoAdminsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: DefaultRepositoryPermissionField;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoDomainsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isApproved?: InputMaybe<Scalars['Boolean']['input']>;\n  isVerified?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<VerifiableDomainOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  connectedOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoFailedInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: OrganizationMembersCanCreateRepositoriesSettingValue;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoOutsideCollaboratorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  login?: InputMaybe<Scalars['String']['input']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  visibility?: InputMaybe<RepositoryVisibility>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoPendingAdminInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseAdministratorInvitationOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryInvitationOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoPendingMemberInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  invitationSource?: InputMaybe<OrganizationInvitationSource>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: IdentityProviderConfigurationState;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoSupportEntitlementsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean']['input'];\n};\n\n/** The connection type for OrganizationInvitation. */\nexport type EnterprisePendingMemberInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterprisePendingMemberInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** Identifies the total count of unique users in the connection. */\n  totalUniqueUserCount: Scalars['Int']['output'];\n};\n\n/** An invitation to be a member in an enterprise organization. */\nexport type EnterprisePendingMemberInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/** A subset of repository information queryable from an enterprise. */\nexport type EnterpriseRepositoryInfo = Node & {\n  id: Scalars['ID']['output'];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean']['output'];\n  /** The repository's name. */\n  name: Scalars['String']['output'];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String']['output'];\n};\n\n/** The connection type for EnterpriseRepositoryInfo. */\nexport type EnterpriseRepositoryInfoConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseRepositoryInfoEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseRepositoryInfo>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseRepositoryInfoEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseRepositoryInfo>;\n};\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallation = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The customer name to which the Enterprise Server installation belongs. */\n  customerName: Scalars['String']['output'];\n  /** The host name of the Enterprise Server installation. */\n  hostName: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */\n  isConnected: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** User accounts on this Enterprise Server installation. */\n  userAccounts: EnterpriseServerUserAccountConnection;\n  /** User accounts uploads for the Enterprise Server installation. */\n  userAccountsUploads: EnterpriseServerUserAccountsUploadConnection;\n};\n\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountOrder>;\n};\n\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsUploadsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountsUploadOrder>;\n};\n\n/** The connection type for EnterpriseServerInstallation. */\nexport type EnterpriseServerInstallationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerInstallationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerInstallation>;\n};\n\n/** The connection type for EnterpriseServerInstallation. */\nexport type EnterpriseServerInstallationMembershipConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationMembershipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An Enterprise Server installation that a user is a member of. */\nexport type EnterpriseServerInstallationMembershipEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerInstallation>;\n  /** The role of the user in the enterprise membership. */\n  role: EnterpriseUserAccountMembershipRole;\n};\n\n/** Ordering options for Enterprise Server installation connections. */\nexport type EnterpriseServerInstallationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order Enterprise Server installations by. */\n  field: EnterpriseServerInstallationOrderField;\n};\n\n/** Properties by which Enterprise Server installation connections can be ordered. */\nexport enum EnterpriseServerInstallationOrderField {\n  /** Order Enterprise Server installations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order Enterprise Server installations by customer name */\n  CustomerName = 'CUSTOMER_NAME',\n  /** Order Enterprise Server installations by host name */\n  HostName = 'HOST_NAME'\n}\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccount = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** User emails belonging to this user account. */\n  emails: EnterpriseServerUserAccountEmailConnection;\n  /** The Enterprise Server installation on which this user account exists. */\n  enterpriseServerInstallation: EnterpriseServerInstallation;\n  id: Scalars['ID']['output'];\n  /** Whether the user account is a site administrator on the Enterprise Server installation. */\n  isSiteAdmin: Scalars['Boolean']['output'];\n  /** The login of the user account on the Enterprise Server installation. */\n  login: Scalars['String']['output'];\n  /** The profile name of the user account on the Enterprise Server installation. */\n  profileName?: Maybe<Scalars['String']['output']>;\n  /** The date and time when the user account was created on the Enterprise Server installation. */\n  remoteCreatedAt: Scalars['DateTime']['output'];\n  /** The ID of the user account on the Enterprise Server installation. */\n  remoteUserId: Scalars['Int']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmailsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountEmailOrder>;\n};\n\n/** The connection type for EnterpriseServerUserAccount. */\nexport type EnterpriseServerUserAccountConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccount>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccount>;\n};\n\n/** An email belonging to a user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmail = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The email address. */\n  email: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** Indicates whether this is the primary email of the associated user account. */\n  isPrimary: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The user account to which the email belongs. */\n  userAccount: EnterpriseServerUserAccount;\n};\n\n/** The connection type for EnterpriseServerUserAccountEmail. */\nexport type EnterpriseServerUserAccountEmailConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmailEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmail>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEmailEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountEmail>;\n};\n\n/** Ordering options for Enterprise Server user account email connections. */\nexport type EnterpriseServerUserAccountEmailOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order emails by. */\n  field: EnterpriseServerUserAccountEmailOrderField;\n};\n\n/** Properties by which Enterprise Server user account email connections can be ordered. */\nexport enum EnterpriseServerUserAccountEmailOrderField {\n  /** Order emails by email */\n  Email = 'EMAIL'\n}\n\n/** Ordering options for Enterprise Server user account connections. */\nexport type EnterpriseServerUserAccountOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts by. */\n  field: EnterpriseServerUserAccountOrderField;\n};\n\n/** Properties by which Enterprise Server user account connections can be ordered. */\nexport enum EnterpriseServerUserAccountOrderField {\n  /** Order user accounts by login */\n  Login = 'LOGIN',\n  /** Order user accounts by creation time on the Enterprise Server installation */\n  RemoteCreatedAt = 'REMOTE_CREATED_AT'\n}\n\n/** A user accounts upload from an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountsUpload = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The enterprise to which this upload belongs. */\n  enterprise: Enterprise;\n  /** The Enterprise Server installation for which this upload was generated. */\n  enterpriseServerInstallation: EnterpriseServerInstallation;\n  id: Scalars['ID']['output'];\n  /** The name of the file uploaded. */\n  name: Scalars['String']['output'];\n  /** The synchronization state of the upload */\n  syncState: EnterpriseServerUserAccountsUploadSyncState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for EnterpriseServerUserAccountsUpload. */\nexport type EnterpriseServerUserAccountsUploadConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUploadEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUpload>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountsUploadEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountsUpload>;\n};\n\n/** Ordering options for Enterprise Server user accounts upload connections. */\nexport type EnterpriseServerUserAccountsUploadOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts uploads by. */\n  field: EnterpriseServerUserAccountsUploadOrderField;\n};\n\n/** Properties by which Enterprise Server user accounts upload connections can be ordered. */\nexport enum EnterpriseServerUserAccountsUploadOrderField {\n  /** Order user accounts uploads by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Synchronization state of the Enterprise Server user accounts upload */\nexport enum EnterpriseServerUserAccountsUploadSyncState {\n  /** The synchronization of the upload failed. */\n  Failure = 'FAILURE',\n  /** The synchronization of the upload is pending. */\n  Pending = 'PENDING',\n  /** The synchronization of the upload succeeded. */\n  Success = 'SUCCESS'\n}\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccount = Actor & Node & {\n  /** A URL pointing to the enterprise user account's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The enterprise in which this user account exists. */\n  enterprise: Enterprise;\n  /** A list of Enterprise Server installations this user is a member of. */\n  enterpriseInstallations: EnterpriseServerInstallationMembershipConnection;\n  id: Scalars['ID']['output'];\n  /** An identifier for the enterprise user account, a login or email address */\n  login: Scalars['String']['output'];\n  /** The name of the enterprise user account */\n  name?: Maybe<Scalars['String']['output']>;\n  /** A list of enterprise organizations this user is a member of. */\n  organizations: EnterpriseOrganizationMembershipConnection;\n  /** The HTTP path for this user. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this user. */\n  url: Scalars['URI']['output'];\n  /** The user within the enterprise. */\n  user?: Maybe<User>;\n};\n\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountEnterpriseInstallationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n/** The possible roles for enterprise membership. */\nexport enum EnterpriseUserAccountMembershipRole {\n  /** The user is a member of an organization in the enterprise. */\n  Member = 'MEMBER',\n  /** The user is an owner of an organization in the enterprise. */\n  Owner = 'OWNER',\n  /**\n   * The user is not an owner of the enterprise, and not a member or owner of any\n   * organizations in the enterprise; only for EMU-enabled enterprises.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The possible GitHub Enterprise deployments where this user can exist. */\nexport enum EnterpriseUserDeployment {\n  /** The user is part of a GitHub Enterprise Cloud deployment. */\n  Cloud = 'CLOUD',\n  /** The user is part of a GitHub Enterprise Server deployment. */\n  Server = 'SERVER'\n}\n\n/** An environment. */\nexport type Environment = Node & {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The name of the environment */\n  name: Scalars['String']['output'];\n  /** The protection rules defined for this environment */\n  protectionRules: DeploymentProtectionRuleConnection;\n};\n\n\n/** An environment. */\nexport type EnvironmentProtectionRulesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for Environment. */\nexport type EnvironmentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Environment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type EnvironmentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Environment>;\n};\n\n/**\n * An external identity provisioned by SAML SSO or SCIM. If SAML is configured on\n * the organization, the external identity is visible to (1) organization owners,\n * (2) organization owners' personal access tokens (classic) with read:org or\n * admin:org scope, (3) GitHub App with an installation token with read or write\n * access to members. If SAML is configured on the enterprise, the external\n * identity is visible to (1) enterprise owners, (2) enterprise owners' personal\n * access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type ExternalIdentity = Node & {\n  /** The GUID for this identity */\n  guid: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** Organization invitation for this SCIM-provisioned external identity */\n  organizationInvitation?: Maybe<OrganizationInvitation>;\n  /** SAML Identity attributes */\n  samlIdentity?: Maybe<ExternalIdentitySamlAttributes>;\n  /** SCIM Identity attributes */\n  scimIdentity?: Maybe<ExternalIdentityScimAttributes>;\n  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */\n  user?: Maybe<User>;\n};\n\n/** An attribute for the External Identity attributes collection */\nexport type ExternalIdentityAttribute = {\n  /** The attribute metadata as JSON */\n  metadata?: Maybe<Scalars['String']['output']>;\n  /** The attribute name */\n  name: Scalars['String']['output'];\n  /** The attribute value */\n  value: Scalars['String']['output'];\n};\n\n/** The connection type for ExternalIdentity. */\nexport type ExternalIdentityConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ExternalIdentityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ExternalIdentity>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ExternalIdentityEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ExternalIdentity>;\n};\n\n/** SAML attributes for the External Identity */\nexport type ExternalIdentitySamlAttributes = {\n  /** SAML Identity attributes */\n  attributes: Array<ExternalIdentityAttribute>;\n  /** The emails associated with the SAML identity */\n  emails?: Maybe<Array<UserEmailMetadata>>;\n  /** Family name of the SAML identity */\n  familyName?: Maybe<Scalars['String']['output']>;\n  /** Given name of the SAML identity */\n  givenName?: Maybe<Scalars['String']['output']>;\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars['String']['output']>>;\n  /** The NameID of the SAML identity */\n  nameId?: Maybe<Scalars['String']['output']>;\n  /** The userName of the SAML identity */\n  username?: Maybe<Scalars['String']['output']>;\n};\n\n/** SCIM attributes for the External Identity */\nexport type ExternalIdentityScimAttributes = {\n  /** The emails associated with the SCIM identity */\n  emails?: Maybe<Array<UserEmailMetadata>>;\n  /** Family name of the SCIM identity */\n  familyName?: Maybe<Scalars['String']['output']>;\n  /** Given name of the SCIM identity */\n  givenName?: Maybe<Scalars['String']['output']>;\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars['String']['output']>>;\n  /** The userName of the SCIM identity */\n  username?: Maybe<Scalars['String']['output']>;\n};\n\n/**\n * A command to add a file at the given path with the given contents as part of a\n * commit.  Any existing file at that that path will be replaced.\n */\nexport type FileAddition = {\n  /** The base64 encoded contents of the file */\n  contents: Scalars['Base64String']['input'];\n  /** The path in the repository where the file will be located */\n  path: Scalars['String']['input'];\n};\n\n/**\n * A description of a set of changes to a file tree to be made as part of\n * a git commit, modeled as zero or more file `additions` and zero or more\n * file `deletions`.\n *\n * Both fields are optional; omitting both will produce a commit with no\n * file changes.\n *\n * `deletions` and `additions` describe changes to files identified\n * by their path in the git tree using unix-style path separators, i.e.\n * `/`.  The root of a git tree is an empty string, so paths are not\n * slash-prefixed.\n *\n * `path` values must be unique across all `additions` and `deletions`\n * provided.  Any duplication will result in a validation error.\n *\n * ### Encoding\n *\n * File contents must be provided in full for each `FileAddition`.\n *\n * The `contents` of a `FileAddition` must be encoded using RFC 4648\n * compliant base64, i.e. correct padding is required and no characters\n * outside the standard alphabet may be used.  Invalid base64\n * encoding will be rejected with a validation error.\n *\n * The encoded contents may be binary.\n *\n * For text files, no assumptions are made about the character encoding of\n * the file contents (after base64 decoding).  No charset transcoding or\n * line-ending normalization will be performed; it is the client's\n * responsibility to manage the character encoding of files they provide.\n * However, for maximum compatibility we recommend using UTF-8 encoding\n * and ensuring that all files in a repository use a consistent\n * line-ending convention (`\\n` or `\\r\\n`), and that all files end\n * with a newline.\n *\n * ### Modeling file changes\n *\n * Each of the the five types of conceptual changes that can be made in a\n * git commit can be described using the `FileChanges` type as follows:\n *\n * 1. New file addition: create file `hello world\\n` at path `docs/README.txt`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n * 2. Existing file modification: change existing `docs/README.txt` to have new\n *    content `new content here\\n`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"new content here\\n\")\n *            }\n *          ]\n *        }\n *\n * 3. Existing file deletion: remove existing file `docs/README.txt`.\n *    Note that the path is required to exist -- specifying a\n *    path that does not exist on the given branch will abort the\n *    commit and return an error.\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\"\n *            }\n *          ]\n *        }\n *\n *\n * 4. File rename with no changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to the same content at\n *    `newdocs/README.txt`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n *\n * 5. File rename with changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to a file at path\n *    `newdocs/README.txt` with content `new contents\\n`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"new contents\\n\")\n *            }\n *          ]\n *        }\n */\nexport type FileChanges = {\n  /** File to add or change. */\n  additions?: InputMaybe<Array<FileAddition>>;\n  /** Files to delete. */\n  deletions?: InputMaybe<Array<FileDeletion>>;\n};\n\n/** A command to delete the file at the given path as part of a commit. */\nexport type FileDeletion = {\n  /** The path to delete */\n  path: Scalars['String']['input'];\n};\n\n/** The possible viewed states of a file . */\nexport enum FileViewedState {\n  /** The file has new changes since last viewed. */\n  Dismissed = 'DISMISSED',\n  /** The file has not been marked as viewed. */\n  Unviewed = 'UNVIEWED',\n  /** The file has been marked as viewed. */\n  Viewed = 'VIEWED'\n}\n\n/** Autogenerated input type of FollowOrganization */\nexport type FollowOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the organization to follow. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of FollowOrganization */\nexport type FollowOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The organization that was followed. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of FollowUser */\nexport type FollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the user to follow. */\n  userId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of FollowUser */\nexport type FollowUserPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The user that was followed. */\n  user?: Maybe<User>;\n};\n\n/** The connection type for User. */\nexport type FollowerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** The connection type for User. */\nexport type FollowingConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** A funding platform link for a repository. */\nexport type FundingLink = {\n  /** The funding platform this link is for. */\n  platform: FundingPlatform;\n  /** The configured URL for this funding link. */\n  url: Scalars['URI']['output'];\n};\n\n/** The possible funding platforms for repository funding links. */\nexport enum FundingPlatform {\n  /** Community Bridge funding platform. */\n  CommunityBridge = 'COMMUNITY_BRIDGE',\n  /** Custom funding platform. */\n  Custom = 'CUSTOM',\n  /** GitHub funding platform. */\n  Github = 'GITHUB',\n  /** IssueHunt funding platform. */\n  Issuehunt = 'ISSUEHUNT',\n  /** Ko-fi funding platform. */\n  KoFi = 'KO_FI',\n  /** LFX Crowdfunding funding platform. */\n  LfxCrowdfunding = 'LFX_CROWDFUNDING',\n  /** Liberapay funding platform. */\n  Liberapay = 'LIBERAPAY',\n  /** Open Collective funding platform. */\n  OpenCollective = 'OPEN_COLLECTIVE',\n  /** Otechie funding platform. */\n  Otechie = 'OTECHIE',\n  /** Patreon funding platform. */\n  Patreon = 'PATREON',\n  /** Tidelift funding platform. */\n  Tidelift = 'TIDELIFT'\n}\n\n/** A generic hovercard context with a message and icon */\nexport type GenericHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']['output'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']['output'];\n};\n\n/** A Gist. */\nexport type Gist = Node & Starrable & UniformResourceLocatable & {\n  /** A list of comments associated with the gist */\n  comments: GistCommentConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The gist description. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The files in this gist. */\n  files?: Maybe<Array<Maybe<GistFile>>>;\n  /** A list of forks associated with the gist */\n  forks: GistConnection;\n  id: Scalars['ID']['output'];\n  /** Identifies if the gist is a fork. */\n  isFork: Scalars['Boolean']['output'];\n  /** Whether the gist is public or not. */\n  isPublic: Scalars['Boolean']['output'];\n  /** The gist name. */\n  name: Scalars['String']['output'];\n  /** The gist owner. */\n  owner?: Maybe<RepositoryOwner>;\n  /** Identifies when the gist was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI']['output'];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int']['output'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this Gist. */\n  url: Scalars['URI']['output'];\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean']['output'];\n};\n\n\n/** A Gist. */\nexport type GistCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A Gist. */\nexport type GistFilesArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  oid?: InputMaybe<Scalars['GitObjectID']['input']>;\n};\n\n\n/** A Gist. */\nexport type GistForksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<GistOrder>;\n};\n\n\n/** A Gist. */\nexport type GistStargazersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** Represents a comment on an Gist. */\nexport type GistComment = Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the gist. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Identifies the comment body. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  /** The associated gist. */\n  gist: Gist;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']['output']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a comment on an Gist. */\nexport type GistCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for GistComment. */\nexport type GistCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GistComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type GistCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<GistComment>;\n};\n\n/** The connection type for Gist. */\nexport type GistConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Gist>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type GistEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Gist>;\n};\n\n/** A file in a gist. */\nexport type GistFile = {\n  /** The file name encoded to remove characters that are invalid in URL paths. */\n  encodedName?: Maybe<Scalars['String']['output']>;\n  /** The gist file encoding. */\n  encoding?: Maybe<Scalars['String']['output']>;\n  /** The file extension from the file name. */\n  extension?: Maybe<Scalars['String']['output']>;\n  /** Indicates if this file is an image. */\n  isImage: Scalars['Boolean']['output'];\n  /** Whether the file's contents were truncated. */\n  isTruncated: Scalars['Boolean']['output'];\n  /** The programming language this file is written in. */\n  language?: Maybe<Language>;\n  /** The gist file name. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** The gist file size in bytes. */\n  size?: Maybe<Scalars['Int']['output']>;\n  /** UTF8 text data or null if the file is binary */\n  text?: Maybe<Scalars['String']['output']>;\n};\n\n\n/** A file in a gist. */\nexport type GistFileTextArgs = {\n  truncate?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Ordering options for gist connections */\nexport type GistOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: GistOrderField;\n};\n\n/** Properties by which gist connections can be ordered. */\nexport enum GistOrderField {\n  /** Order gists by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order gists by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order gists by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The privacy of a Gist */\nexport enum GistPrivacy {\n  /** Gists that are public and secret */\n  All = 'ALL',\n  /** Public */\n  Public = 'PUBLIC',\n  /** Secret */\n  Secret = 'SECRET'\n}\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActor = {\n  /** A URL pointing to the author's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** The timestamp of the Git action (authoring or committing). */\n  date?: Maybe<Scalars['GitTimestamp']['output']>;\n  /** The email in the Git commit. */\n  email?: Maybe<Scalars['String']['output']>;\n  /** The name in the Git commit. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** The GitHub user corresponding to the email field. Null if no such user exists. */\n  user?: Maybe<User>;\n};\n\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActorAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for GitActor. */\nexport type GitActorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GitActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GitActor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type GitActorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<GitActor>;\n};\n\n/** Represents information about the GitHub instance. */\nexport type GitHubMetadata = {\n  /** Returns a String that's a SHA of `github-services` */\n  gitHubServicesSha: Scalars['GitObjectID']['output'];\n  /** IP addresses that users connect to for git operations */\n  gitIpAddresses?: Maybe<Array<Scalars['String']['output']>>;\n  /** IP addresses that service hooks are sent from */\n  hookIpAddresses?: Maybe<Array<Scalars['String']['output']>>;\n  /** IP addresses that the importer connects from */\n  importerIpAddresses?: Maybe<Array<Scalars['String']['output']>>;\n  /** Whether or not users are verified */\n  isPasswordAuthenticationVerifiable: Scalars['Boolean']['output'];\n  /** IP addresses for GitHub Pages' A records */\n  pagesIpAddresses?: Maybe<Array<Scalars['String']['output']>>;\n};\n\n/** Represents a Git object. */\nexport type GitObject = {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String']['output'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI']['output'];\n  id: Scalars['ID']['output'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID']['output'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n};\n\n/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */\nexport type GitSignature = {\n  /** Email used to sign this object. */\n  email: Scalars['String']['output'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']['output'];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']['output'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']['output'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']['output'];\n};\n\n/** The state of a Git signature. */\nexport enum GitSignatureState {\n  /** The signing certificate or its chain could not be verified */\n  BadCert = 'BAD_CERT',\n  /** Invalid email used for signing */\n  BadEmail = 'BAD_EMAIL',\n  /** Signing key expired */\n  ExpiredKey = 'EXPIRED_KEY',\n  /** Internal error - the GPG verification service misbehaved */\n  GpgverifyError = 'GPGVERIFY_ERROR',\n  /** Internal error - the GPG verification service is unavailable at the moment */\n  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',\n  /** Invalid signature */\n  Invalid = 'INVALID',\n  /** Malformed signature */\n  MalformedSig = 'MALFORMED_SIG',\n  /** The usage flags for the key that signed this don't allow signing */\n  NotSigningKey = 'NOT_SIGNING_KEY',\n  /** Email used for signing not known to GitHub */\n  NoUser = 'NO_USER',\n  /** Valid signature, though certificate revocation check failed */\n  OcspError = 'OCSP_ERROR',\n  /** Valid signature, pending certificate revocation checking */\n  OcspPending = 'OCSP_PENDING',\n  /** One or more certificates in chain has been revoked */\n  OcspRevoked = 'OCSP_REVOKED',\n  /** Key used for signing not known to GitHub */\n  UnknownKey = 'UNKNOWN_KEY',\n  /** Unknown signature type */\n  UnknownSigType = 'UNKNOWN_SIG_TYPE',\n  /** Unsigned */\n  Unsigned = 'UNSIGNED',\n  /** Email used for signing unverified on GitHub */\n  UnverifiedEmail = 'UNVERIFIED_EMAIL',\n  /** Valid signature and verified by GitHub */\n  Valid = 'VALID'\n}\n\n/** Represents a GPG signature on a Commit or Tag. */\nexport type GpgSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']['output'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']['output'];\n  /** Hex-encoded ID of the key that signed this object. */\n  keyId?: Maybe<Scalars['String']['output']>;\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']['output'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']['output'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']['output'];\n};\n\n/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of the user to grant the migrator role */\n  login: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The organizations that had the migrator role applied to for the given user. */\n  organizations?: Maybe<OrganizationConnection>;\n};\n\n\n/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Autogenerated input type of GrantMigratorRole */\nexport type GrantMigratorRoleInput = {\n  /** The user login or Team slug to grant the migrator role. */\n  actor: Scalars['String']['input'];\n  /** Specifies the type of the actor, can be either USER or TEAM. */\n  actorType: ActorType;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the organization that the user/team belongs to. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of GrantMigratorRole */\nexport type GrantMigratorRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** Represents a 'head_ref_deleted' event on a given pull request. */\nexport type HeadRefDeletedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the Ref associated with the `head_ref_deleted` event. */\n  headRef?: Maybe<Ref>;\n  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */\n  headRefName: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'head_ref_force_pushed' event on a given pull request. */\nexport type HeadRefForcePushedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>;\n  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents a 'head_ref_restored' event on a given pull request. */\nexport type HeadRefRestoredEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Detail needed to display a hovercard for a user */\nexport type Hovercard = {\n  /** Each of the contexts for this hovercard */\n  contexts: Array<HovercardContext>;\n};\n\n/** An individual line of a hovercard */\nexport type HovercardContext = {\n  /** A string describing this context */\n  message: Scalars['String']['output'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']['output'];\n};\n\n/** The possible states in which authentication can be configured with an identity provider. */\nexport enum IdentityProviderConfigurationState {\n  /** Authentication with an identity provider is configured but not enforced. */\n  Configured = 'CONFIGURED',\n  /** Authentication with an identity provider is configured and enforced. */\n  Enforced = 'ENFORCED',\n  /** Authentication with an identity provider is not configured. */\n  Unconfigured = 'UNCONFIGURED'\n}\n\n/** Autogenerated input type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The email of the person to invite as an administrator. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise to which you want to invite an administrator. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of a user to invite as an administrator. */\n  invitee?: InputMaybe<Scalars['String']['input']>;\n  /** The role of the administrator. */\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n/** Autogenerated return type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The created enterprise administrator invitation. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n};\n\n/** The possible values for the IP allow list enabled setting. */\nexport enum IpAllowListEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n/** An IP address or range of addresses that is allowed to access an owner's resources. */\nexport type IpAllowListEntry = Node & {\n  /** A single IP address or range of IP addresses in CIDR notation. */\n  allowListValue: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the entry is currently active. */\n  isActive: Scalars['Boolean']['output'];\n  /** The name of the IP allow list entry. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** The owner of the IP allow list entry. */\n  owner: IpAllowListOwner;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for IpAllowListEntry. */\nexport type IpAllowListEntryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IpAllowListEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IpAllowListEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type IpAllowListEntryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IpAllowListEntry>;\n};\n\n/** Ordering options for IP allow list entry connections. */\nexport type IpAllowListEntryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order IP allow list entries by. */\n  field: IpAllowListEntryOrderField;\n};\n\n/** Properties by which IP allow list entry connections can be ordered. */\nexport enum IpAllowListEntryOrderField {\n  /** Order IP allow list entries by the allow list value. */\n  AllowListValue = 'ALLOW_LIST_VALUE',\n  /** Order IP allow list entries by creation time. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */\nexport enum IpAllowListForInstalledAppsEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n/** Types that can own an IP allow list. */\nexport type IpAllowListOwner = App | Enterprise | Organization;\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type Issue = Assignable & Closable & Comment & Deletable & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Identifies the body of the issue. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The http path for this issue body */\n  bodyResourcePath: Scalars['URI']['output'];\n  /** Identifies the body of the issue rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** The http URL for this issue body */\n  bodyUrl: Scalars['URI']['output'];\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of comments associated with the Issue. */\n  comments: IssueCommentConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  /** Identifies the primary key from the database as a BigInt. */\n  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;\n  /** The hovercard information for this issue */\n  hovercard: Hovercard;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** Indicates whether or not this issue is currently pinned to the repository issues list */\n  isPinned?: Maybe<Scalars['Boolean']['output']>;\n  /** Is this issue read by the viewer */\n  isReadByViewer?: Maybe<Scalars['Boolean']['output']>;\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Branches linked to this issue. */\n  linkedBranches: LinkedBranchConnection;\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean']['output'];\n  /** Identifies the milestone associated with the issue. */\n  milestone?: Maybe<Milestone>;\n  /** Identifies the issue number. */\n  number: Scalars['Int']['output'];\n  /** A list of Users that are participating in the Issue conversation. */\n  participants: UserConnection;\n  /** List of project cards associated with this issue. */\n  projectCards: ProjectCardConnection;\n  /** List of project items associated with this issue. */\n  projectItems: ProjectV2ItemConnection;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path for this issue */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the state of the issue. */\n  state: IssueState;\n  /** Identifies the reason for the issue state. */\n  stateReason?: Maybe<IssueStateReason>;\n  /**\n   * A list of events, comments, commits, etc. associated with the issue.\n   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.\n   */\n  timeline: IssueTimelineConnection;\n  /** A list of events, comments, commits, etc. associated with the issue. */\n  timelineItems: IssueTimelineItemsConnection;\n  /** Identifies the issue title. */\n  title: Scalars['String']['output'];\n  /** Identifies the issue title rendered to HTML. */\n  titleHTML: Scalars['String']['output'];\n  /** A list of issues that track this issue */\n  trackedInIssues: IssueConnection;\n  /** A list of issues tracked inside the current issue */\n  trackedIssues: IssueConnection;\n  /** The number of tracked issues for this issue */\n  trackedIssuesCount: Scalars['Int']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this issue */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueHovercardArgs = {\n  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueLinkedBranchesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueParticipantsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectCardsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  itemTypes?: InputMaybe<Array<IssueTimelineItemsItemType>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  skip?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedInIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedIssuesCountArgs = {\n  states?: InputMaybe<Array<InputMaybe<TrackedIssueStates>>>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The possible state reasons of a closed issue. */\nexport enum IssueClosedStateReason {\n  /** An issue that has been closed as completed */\n  Completed = 'COMPLETED',\n  /** An issue that has been closed as not planned */\n  NotPlanned = 'NOT_PLANNED'\n}\n\n/** Represents a comment on an Issue. */\nexport type IssueComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  /** Identifies the primary key from the database as a BigInt. */\n  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']['output'];\n  /** Identifies the issue associated with the comment. */\n  issue: Issue;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']['output']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Returns the pull request associated with the comment, if this comment was made on a\n   * pull request.\n   */\n  pullRequest?: Maybe<PullRequest>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path for this issue comment */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this issue comment */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for IssueComment. */\nexport type IssueCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type IssueCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueComment>;\n};\n\n/** Ways in which lists of issue comments can be ordered upon return. */\nexport type IssueCommentOrder = {\n  /** The direction in which to order issue comments by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issue comments by. */\n  field: IssueCommentOrderField;\n};\n\n/** Properties by which issue comment connections can be ordered. */\nexport enum IssueCommentOrderField {\n  /** Order issue comments by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The connection type for Issue. */\nexport type IssueConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Issue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepository = {\n  /** The issue contributions. */\n  contributions: CreatedIssueContributionConnection;\n  /** The repository in which the issues were opened. */\n  repository: Repository;\n};\n\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type IssueEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Issue>;\n};\n\n/** Ways in which to filter lists of issues. */\nexport type IssueFilters = {\n  /**\n   * List issues assigned to given name. Pass in `null` for issues with no assigned\n   * user, and `*` for issues assigned to any user.\n   */\n  assignee?: InputMaybe<Scalars['String']['input']>;\n  /** List issues created by given name. */\n  createdBy?: InputMaybe<Scalars['String']['input']>;\n  /** List issues where the list of label names exist on the issue. */\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** List issues where the given name is mentioned in the issue. */\n  mentioned?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its database ID. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestone?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its number field. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestoneNumber?: InputMaybe<Scalars['String']['input']>;\n  /** List issues that have been updated at or after the given date. */\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  /** List issues filtered by the list of states given. */\n  states?: InputMaybe<Array<IssueState>>;\n  /** List issues subscribed to by viewer. */\n  viewerSubscribed?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Used for return value of Repository.issueOrPullRequest. */\nexport type IssueOrPullRequest = Issue | PullRequest;\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type IssueOrder = {\n  /** The direction in which to order issues by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issues by. */\n  field: IssueOrderField;\n};\n\n/** Properties by which issue connections can be ordered. */\nexport enum IssueOrderField {\n  /** Order issues by comment count */\n  Comments = 'COMMENTS',\n  /** Order issues by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order issues by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible states of an issue. */\nexport enum IssueState {\n  /** An issue that has been closed */\n  Closed = 'CLOSED',\n  /** An issue that is still open */\n  Open = 'OPEN'\n}\n\n/** The possible state reasons of an issue. */\nexport enum IssueStateReason {\n  /** An issue that has been closed as completed */\n  Completed = 'COMPLETED',\n  /** An issue that has been closed as not planned */\n  NotPlanned = 'NOT_PLANNED',\n  /** An issue that has been reopened */\n  Reopened = 'REOPENED'\n}\n\n/** A repository issue template. */\nexport type IssueTemplate = {\n  /** The template purpose. */\n  about?: Maybe<Scalars['String']['output']>;\n  /** The suggested assignees. */\n  assignees: UserConnection;\n  /** The suggested issue body. */\n  body?: Maybe<Scalars['String']['output']>;\n  /** The template filename. */\n  filename: Scalars['String']['output'];\n  /** The suggested issue labels */\n  labels?: Maybe<LabelConnection>;\n  /** The template name. */\n  name: Scalars['String']['output'];\n  /** The suggested issue title. */\n  title?: Maybe<Scalars['String']['output']>;\n};\n\n\n/** A repository issue template. */\nexport type IssueTemplateAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository issue template. */\nexport type IssueTemplateLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** The connection type for IssueTimelineItem. */\nexport type IssueTimelineConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An item in an issue timeline */\nexport type IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** An edge in a connection. */\nexport type IssueTimelineItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItem>;\n};\n\n/** An item in an issue timeline */\nexport type IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** The connection type for IssueTimelineItems. */\nexport type IssueTimelineItemsConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemsEdge>>>;\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars['Int']['output'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItems>>>;\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars['Int']['output'];\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** An edge in a connection. */\nexport type IssueTimelineItemsEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItems>;\n};\n\n/** The possible item types found in a timeline. */\nexport enum IssueTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a 'converted_to_discussion' event on a given issue. */\n  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT'\n}\n\n/** Represents a user signing up for a GitHub account. */\nexport type JoinedGitHubContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type Label = Node & {\n  /** Identifies the label color. */\n  color: Scalars['String']['output'];\n  /** Identifies the date and time when the label was created. */\n  createdAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A brief description of this label. */\n  description?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** Indicates whether or not this is a default label. */\n  isDefault: Scalars['Boolean']['output'];\n  /** A list of issues associated with this label. */\n  issues: IssueConnection;\n  /** Identifies the label name. */\n  name: Scalars['String']['output'];\n  /** A list of pull requests associated with this label. */\n  pullRequests: PullRequestConnection;\n  /** The repository associated with this label. */\n  repository: Repository;\n  /** The HTTP path for this label. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the label was last updated. */\n  updatedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The HTTP URL for this label. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  headRefName?: InputMaybe<Scalars['String']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Label. */\nexport type LabelConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LabelEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Label>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type LabelEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Label>;\n};\n\n/** Ways in which lists of labels can be ordered upon return. */\nexport type LabelOrder = {\n  /** The direction in which to order labels by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order labels by. */\n  field: LabelOrderField;\n};\n\n/** Properties by which label connections can be ordered. */\nexport enum LabelOrderField {\n  /** Order labels by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order labels by name  */\n  Name = 'NAME'\n}\n\n/** An object that can have labels assigned to it. */\nexport type Labelable = {\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n};\n\n\n/** An object that can have labels assigned to it. */\nexport type LabelableLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** Represents a 'labeled' event on a given issue or pull request. */\nexport type LabeledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the label associated with the 'labeled' event. */\n  label: Label;\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable;\n};\n\n/** Represents a given language found in repositories. */\nexport type Language = Node & {\n  /** The color defined for the current language. */\n  color?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The name of the current language. */\n  name: Scalars['String']['output'];\n};\n\n/** A list of languages associated with the parent. */\nexport type LanguageConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LanguageEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Language>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** The total size in bytes of files written in that language. */\n  totalSize: Scalars['Int']['output'];\n};\n\n/** Represents the language of a repository. */\nexport type LanguageEdge = {\n  cursor: Scalars['String']['output'];\n  node: Language;\n  /** The number of bytes of code written in the language. */\n  size: Scalars['Int']['output'];\n};\n\n/** Ordering options for language connections. */\nexport type LanguageOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order languages by. */\n  field: LanguageOrderField;\n};\n\n/** Properties by which language connections can be ordered. */\nexport enum LanguageOrderField {\n  /** Order languages by the size of all files containing the language */\n  Size = 'SIZE'\n}\n\n/** A repository's open source license */\nexport type License = Node & {\n  /** The full text of the license */\n  body: Scalars['String']['output'];\n  /** The conditions set by the license */\n  conditions: Array<Maybe<LicenseRule>>;\n  /** A human-readable description of the license */\n  description?: Maybe<Scalars['String']['output']>;\n  /** Whether the license should be featured */\n  featured: Scalars['Boolean']['output'];\n  /** Whether the license should be displayed in license pickers */\n  hidden: Scalars['Boolean']['output'];\n  id: Scalars['ID']['output'];\n  /** Instructions on how to implement the license */\n  implementation?: Maybe<Scalars['String']['output']>;\n  /** The lowercased SPDX ID of the license */\n  key: Scalars['String']['output'];\n  /** The limitations set by the license */\n  limitations: Array<Maybe<LicenseRule>>;\n  /** The license full name specified by <https://spdx.org/licenses> */\n  name: Scalars['String']['output'];\n  /** Customary short name if applicable (e.g, GPLv3) */\n  nickname?: Maybe<Scalars['String']['output']>;\n  /** The permissions set by the license */\n  permissions: Array<Maybe<LicenseRule>>;\n  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */\n  pseudoLicense: Scalars['Boolean']['output'];\n  /** Short identifier specified by <https://spdx.org/licenses> */\n  spdxId?: Maybe<Scalars['String']['output']>;\n  /** URL to the license on <https://choosealicense.com> */\n  url?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Describes a License's conditions, permissions, and limitations */\nexport type LicenseRule = {\n  /** A description of the rule */\n  description: Scalars['String']['output'];\n  /** The machine-readable rule key */\n  key: Scalars['String']['output'];\n  /** The human-readable rule label */\n  label: Scalars['String']['output'];\n};\n\n/** Autogenerated input type of LinkProjectV2ToRepository */\nexport type LinkProjectV2ToRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the project to link to the repository. */\n  projectId: Scalars['ID']['input'];\n  /** The ID of the repository to link to the project. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of LinkProjectV2ToRepository */\nexport type LinkProjectV2ToRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository the project is linked to. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of LinkProjectV2ToTeam */\nexport type LinkProjectV2ToTeamInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the project to link to the team. */\n  projectId: Scalars['ID']['input'];\n  /** The ID of the team to link to the project. */\n  teamId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of LinkProjectV2ToTeam */\nexport type LinkProjectV2ToTeamPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The team the project is linked to */\n  team?: Maybe<Team>;\n};\n\n/** Autogenerated input type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Project to link to a Repository */\n  projectId: Scalars['ID']['input'];\n  /** The ID of the Repository to link to a Project. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The linked Project. */\n  project?: Maybe<Project>;\n  /** The linked Repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** A branch linked to an issue. */\nexport type LinkedBranch = Node & {\n  id: Scalars['ID']['output'];\n  /** The branch's ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** The connection type for LinkedBranch. */\nexport type LinkedBranchConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LinkedBranchEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<LinkedBranch>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type LinkedBranchEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<LinkedBranch>;\n};\n\n/** Autogenerated input type of LockLockable */\nexport type LockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A reason for why the item will be locked. */\n  lockReason?: InputMaybe<LockReason>;\n  /** ID of the item to be locked. */\n  lockableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of LockLockable */\nexport type LockLockablePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item that was locked. */\n  lockedRecord?: Maybe<Lockable>;\n};\n\n/** The possible reasons that an issue or pull request was locked. */\nexport enum LockReason {\n  /** The issue or pull request was locked because the conversation was off-topic. */\n  OffTopic = 'OFF_TOPIC',\n  /** The issue or pull request was locked because the conversation was resolved. */\n  Resolved = 'RESOLVED',\n  /** The issue or pull request was locked because the conversation was spam. */\n  Spam = 'SPAM',\n  /** The issue or pull request was locked because the conversation was too heated. */\n  TooHeated = 'TOO_HEATED'\n}\n\n/** An object that can be locked. */\nexport type Lockable = {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean']['output'];\n};\n\n/** Represents a 'locked' event on a given issue or pull request. */\nexport type LockedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Reason that the conversation was locked (optional). */\n  lockReason?: Maybe<LockReason>;\n  /** Object that was locked. */\n  lockable: Lockable;\n};\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type Mannequin = Actor & Node & UniformResourceLocatable & {\n  /** A URL pointing to the GitHub App's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** The user that has claimed the data attributed to this mannequin. */\n  claimant?: Maybe<User>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The mannequin's email on the source instance. */\n  email?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The username of the actor. */\n  login: Scalars['String']['output'];\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The URL to this resource. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type MannequinAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for Mannequin. */\nexport type MannequinConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MannequinEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Mannequin>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a mannequin. */\nexport type MannequinEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Mannequin>;\n};\n\n/** Ordering options for mannequins. */\nexport type MannequinOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order mannequins by. */\n  field: MannequinOrderField;\n};\n\n/** Properties by which mannequins can be ordered. */\nexport enum MannequinOrderField {\n  /** Order mannequins why when they were created. */\n  CreatedAt = 'CREATED_AT',\n  /** Order mannequins alphabetically by their source login. */\n  Login = 'LOGIN'\n}\n\n/** Autogenerated input type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion comment to mark as an answer. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion that includes the chosen comment. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of MarkFileAsViewed */\nexport type MarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The path of the file to mark as viewed */\n  path: Scalars['String']['input'];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MarkFileAsViewed */\nexport type MarkFileAsViewedPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of MarkProjectV2AsTemplate */\nexport type MarkProjectV2AsTemplateInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Project to mark as a template. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MarkProjectV2AsTemplate */\nexport type MarkProjectV2AsTemplatePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the pull request to be marked as ready for review. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that is ready for review. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\nexport type MarkedAsDuplicateEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n  id: Scalars['ID']['output'];\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars['Boolean']['output'];\n};\n\n/** A public description of a Marketplace category. */\nexport type MarketplaceCategory = Node & {\n  /** The category's description. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The technical description of how apps listed in this category work with GitHub. */\n  howItWorks?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The category's name. */\n  name: Scalars['String']['output'];\n  /** How many Marketplace listings have this as their primary category. */\n  primaryListingCount: Scalars['Int']['output'];\n  /** The HTTP path for this Marketplace category. */\n  resourcePath: Scalars['URI']['output'];\n  /** How many Marketplace listings have this as their secondary category. */\n  secondaryListingCount: Scalars['Int']['output'];\n  /** The short name of the category used in its URL. */\n  slug: Scalars['String']['output'];\n  /** The HTTP URL for this Marketplace category. */\n  url: Scalars['URI']['output'];\n};\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListing = Node & {\n  /** The GitHub App this listing represents. */\n  app?: Maybe<App>;\n  /** URL to the listing owner's company site. */\n  companyUrl?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP path for configuring access to the listing's integration or OAuth app */\n  configurationResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for configuring access to the listing's integration or OAuth app */\n  configurationUrl: Scalars['URI']['output'];\n  /** URL to the listing's documentation. */\n  documentationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The listing's detailed description. */\n  extendedDescription?: Maybe<Scalars['String']['output']>;\n  /** The listing's detailed description rendered to HTML. */\n  extendedDescriptionHTML: Scalars['HTML']['output'];\n  /** The listing's introductory description. */\n  fullDescription: Scalars['String']['output'];\n  /** The listing's introductory description rendered to HTML. */\n  fullDescriptionHTML: Scalars['HTML']['output'];\n  /** Does this listing have any plans with a free trial? */\n  hasPublishedFreeTrialPlans: Scalars['Boolean']['output'];\n  /** Does this listing have a terms of service link? */\n  hasTermsOfService: Scalars['Boolean']['output'];\n  /** Whether the creator of the app is a verified org */\n  hasVerifiedOwner: Scalars['Boolean']['output'];\n  /** A technical description of how this app works with GitHub. */\n  howItWorks?: Maybe<Scalars['String']['output']>;\n  /** The listing's technical description rendered to HTML. */\n  howItWorksHTML: Scalars['HTML']['output'];\n  id: Scalars['ID']['output'];\n  /** URL to install the product to the viewer's account or organization. */\n  installationUrl?: Maybe<Scalars['URI']['output']>;\n  /** Whether this listing's app has been installed for the current viewer */\n  installedForViewer: Scalars['Boolean']['output'];\n  /** Whether this listing has been removed from the Marketplace. */\n  isArchived: Scalars['Boolean']['output'];\n  /**\n   * Whether this listing is still an editable draft that has not been submitted\n   * for review and is not publicly visible in the Marketplace.\n   */\n  isDraft: Scalars['Boolean']['output'];\n  /** Whether the product this listing represents is available as part of a paid plan. */\n  isPaid: Scalars['Boolean']['output'];\n  /** Whether this listing has been approved for display in the Marketplace. */\n  isPublic: Scalars['Boolean']['output'];\n  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */\n  isRejected: Scalars['Boolean']['output'];\n  /** Whether this listing has been approved for unverified display in the Marketplace. */\n  isUnverified: Scalars['Boolean']['output'];\n  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */\n  isUnverifiedPending: Scalars['Boolean']['output'];\n  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromDraft: Scalars['Boolean']['output'];\n  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromUnverified: Scalars['Boolean']['output'];\n  /** Whether this listing has been approved for verified display in the Marketplace. */\n  isVerified: Scalars['Boolean']['output'];\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars['String']['output'];\n  /** URL for the listing's logo image. */\n  logoUrl?: Maybe<Scalars['URI']['output']>;\n  /** The listing's full name. */\n  name: Scalars['String']['output'];\n  /** The listing's very short description without a trailing period or ampersands. */\n  normalizedShortDescription: Scalars['String']['output'];\n  /** URL to the listing's detailed pricing. */\n  pricingUrl?: Maybe<Scalars['URI']['output']>;\n  /** The category that best describes the listing. */\n  primaryCategory: MarketplaceCategory;\n  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */\n  privacyPolicyUrl: Scalars['URI']['output'];\n  /** The HTTP path for the Marketplace listing. */\n  resourcePath: Scalars['URI']['output'];\n  /** The URLs for the listing's screenshots. */\n  screenshotUrls: Array<Maybe<Scalars['String']['output']>>;\n  /** An alternate category that describes the listing. */\n  secondaryCategory?: Maybe<MarketplaceCategory>;\n  /** The listing's very short description. */\n  shortDescription: Scalars['String']['output'];\n  /** The short name of the listing used in its URL. */\n  slug: Scalars['String']['output'];\n  /** URL to the listing's status page. */\n  statusUrl?: Maybe<Scalars['URI']['output']>;\n  /** An email address for support for this listing's app. */\n  supportEmail?: Maybe<Scalars['String']['output']>;\n  /**\n   * Either a URL or an email address for support for this listing's app, may\n   * return an empty string for listings that do not require a support URL.\n   */\n  supportUrl: Scalars['URI']['output'];\n  /** URL to the listing's terms of service. */\n  termsOfServiceUrl?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the Marketplace listing. */\n  url: Scalars['URI']['output'];\n  /** Can the current viewer add plans for this Marketplace listing. */\n  viewerCanAddPlans: Scalars['Boolean']['output'];\n  /** Can the current viewer approve this Marketplace listing. */\n  viewerCanApprove: Scalars['Boolean']['output'];\n  /** Can the current viewer delist this Marketplace listing. */\n  viewerCanDelist: Scalars['Boolean']['output'];\n  /** Can the current viewer edit this Marketplace listing. */\n  viewerCanEdit: Scalars['Boolean']['output'];\n  /**\n   * Can the current viewer edit the primary and secondary category of this\n   * Marketplace listing.\n   */\n  viewerCanEditCategories: Scalars['Boolean']['output'];\n  /** Can the current viewer edit the plans for this Marketplace listing. */\n  viewerCanEditPlans: Scalars['Boolean']['output'];\n  /**\n   * Can the current viewer return this Marketplace listing to draft state\n   * so it becomes editable again.\n   */\n  viewerCanRedraft: Scalars['Boolean']['output'];\n  /**\n   * Can the current viewer reject this Marketplace listing by returning it to\n   * an editable draft state or rejecting it entirely.\n   */\n  viewerCanReject: Scalars['Boolean']['output'];\n  /**\n   * Can the current viewer request this listing be reviewed for display in\n   * the Marketplace as verified.\n   */\n  viewerCanRequestApproval: Scalars['Boolean']['output'];\n  /** Indicates whether the current user has an active subscription to this Marketplace listing. */\n  viewerHasPurchased: Scalars['Boolean']['output'];\n  /**\n   * Indicates if the current user has purchased a subscription to this Marketplace listing\n   * for all of the organizations the user owns.\n   */\n  viewerHasPurchasedForAllOrganizations: Scalars['Boolean']['output'];\n  /** Does the current viewer role allow them to administer this Marketplace listing. */\n  viewerIsListingAdmin: Scalars['Boolean']['output'];\n};\n\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListingLogoUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Look up Marketplace Listings */\nexport type MarketplaceListingConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MarketplaceListingEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<MarketplaceListing>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type MarketplaceListingEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<MarketplaceListing>;\n};\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusable = {\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n};\n\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusableMemberStatusesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n/** Audit log entry for a members_can_delete_repos.clear event. */\nexport type MembersCanDeleteReposClearAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a members_can_delete_repos.disable event. */\nexport type MembersCanDeleteReposDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a members_can_delete_repos.enable event. */\nexport type MembersCanDeleteReposEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Represents a 'mentioned' event on a given issue or pull request. */\nexport type MentionedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n};\n\n/** Autogenerated input type of MergeBranch */\nexport type MergeBranchInput = {\n  /** The email address to associate with this commit. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the base branch that the provided head will be merged into. */\n  base: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Message to use for the merge commit. If omitted, a default will be used. */\n  commitMessage?: InputMaybe<Scalars['String']['input']>;\n  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */\n  head: Scalars['String']['input'];\n  /** The Node ID of the Repository containing the base branch that will be modified. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MergeBranch */\nexport type MergeBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The resulting merge Commit. */\n  mergeCommit?: Maybe<Commit>;\n};\n\n/** The possible default commit messages for merges. */\nexport enum MergeCommitMessage {\n  /** Default to a blank commit message. */\n  Blank = 'BLANK',\n  /** Default to the pull request's body. */\n  PrBody = 'PR_BODY',\n  /** Default to the pull request's title. */\n  PrTitle = 'PR_TITLE'\n}\n\n/** The possible default commit titles for merges. */\nexport enum MergeCommitTitle {\n  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */\n  MergeMessage = 'MERGE_MESSAGE',\n  /** Default to the pull request's title. */\n  PrTitle = 'PR_TITLE'\n}\n\n/** Autogenerated input type of MergePullRequest */\nexport type MergePullRequestInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Commit body to use for the merge commit; if omitted, a default message will be used */\n  commitBody?: InputMaybe<Scalars['String']['input']>;\n  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */\n  commitHeadline?: InputMaybe<Scalars['String']['input']>;\n  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: InputMaybe<PullRequestMergeMethod>;\n  /** ID of the pull request to be merged. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MergePullRequest */\nexport type MergePullRequestPayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that was merged. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** The queue of pull request entries to be merged into a protected branch in a repository. */\nexport type MergeQueue = Node & {\n  /** The configuration for this merge queue */\n  configuration?: Maybe<MergeQueueConfiguration>;\n  /** The entries in the queue */\n  entries?: Maybe<MergeQueueEntryConnection>;\n  id: Scalars['ID']['output'];\n  /** The estimated time in seconds until a newly added entry would be merged */\n  nextEntryEstimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;\n  /** The repository this merge queue belongs to */\n  repository?: Maybe<Repository>;\n  /** The HTTP path for this merge queue */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this merge queue */\n  url: Scalars['URI']['output'];\n};\n\n\n/** The queue of pull request entries to be merged into a protected branch in a repository. */\nexport type MergeQueueEntriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Configuration for a MergeQueue */\nexport type MergeQueueConfiguration = {\n  /** The amount of time in minutes to wait for a check response before considering it a failure. */\n  checkResponseTimeout?: Maybe<Scalars['Int']['output']>;\n  /** The maximum number of entries to build at once. */\n  maximumEntriesToBuild?: Maybe<Scalars['Int']['output']>;\n  /** The maximum number of entries to merge at once. */\n  maximumEntriesToMerge?: Maybe<Scalars['Int']['output']>;\n  /** The merge method to use for this queue. */\n  mergeMethod?: Maybe<PullRequestMergeMethod>;\n  /** The strategy to use when merging entries. */\n  mergingStrategy?: Maybe<MergeQueueMergingStrategy>;\n  /** The minimum number of entries required to merge at once. */\n  minimumEntriesToMerge?: Maybe<Scalars['Int']['output']>;\n  /**\n   * The amount of time in minutes to wait before ignoring the minumum number of\n   * entries in the queue requirement and merging a collection of entries\n   */\n  minimumEntriesToMergeWaitTime?: Maybe<Scalars['Int']['output']>;\n};\n\n/** Entries in a MergeQueue */\nexport type MergeQueueEntry = Node & {\n  /** The base commit for this entry */\n  baseCommit?: Maybe<Commit>;\n  /** The date and time this entry was added to the merge queue */\n  enqueuedAt: Scalars['DateTime']['output'];\n  /** The actor that enqueued this entry */\n  enqueuer: Actor;\n  /** The estimated time in seconds until this entry will be merged */\n  estimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;\n  /** The head commit for this entry */\n  headCommit?: Maybe<Commit>;\n  id: Scalars['ID']['output'];\n  /** Whether this pull request should jump the queue */\n  jump: Scalars['Boolean']['output'];\n  /** The merge queue that this entry belongs to */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** The position of this entry in the queue */\n  position: Scalars['Int']['output'];\n  /** The pull request that will be added to a merge group */\n  pullRequest?: Maybe<PullRequest>;\n  /** Does this pull request need to be deployed on its own */\n  solo: Scalars['Boolean']['output'];\n  /** The state of this entry in the queue */\n  state: MergeQueueEntryState;\n};\n\n/** The connection type for MergeQueueEntry. */\nexport type MergeQueueEntryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MergeQueueEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<MergeQueueEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type MergeQueueEntryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<MergeQueueEntry>;\n};\n\n/** The possible states for a merge queue entry. */\nexport enum MergeQueueEntryState {\n  /** The entry is currently waiting for checks to pass. */\n  AwaitingChecks = 'AWAITING_CHECKS',\n  /** The entry is currently locked. */\n  Locked = 'LOCKED',\n  /** The entry is currently mergeable. */\n  Mergeable = 'MERGEABLE',\n  /** The entry is currently queued. */\n  Queued = 'QUEUED',\n  /** The entry is currently unmergeable. */\n  Unmergeable = 'UNMERGEABLE'\n}\n\n/** The possible merging strategies for a merge queue. */\nexport enum MergeQueueMergingStrategy {\n  /** Entries only allowed to merge if they are passing. */\n  Allgreen = 'ALLGREEN',\n  /** Failing Entires are allowed to merge if they are with a passing entry. */\n  Headgreen = 'HEADGREEN'\n}\n\n/** Whether or not a PullRequest can be merged. */\nexport enum MergeableState {\n  /** The pull request cannot be merged due to merge conflicts. */\n  Conflicting = 'CONFLICTING',\n  /** The pull request can be merged. */\n  Mergeable = 'MERGEABLE',\n  /** The mergeability of the pull request is still being calculated. */\n  Unknown = 'UNKNOWN'\n}\n\n/** Represents a 'merged' event on a given pull request. */\nexport type MergedEvent = Node & UniformResourceLocatable & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the commit associated with the `merge` event. */\n  commit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the Ref associated with the `merge` event. */\n  mergeRef?: Maybe<Ref>;\n  /** Identifies the name of the Ref associated with the `merge` event. */\n  mergeRefName: Scalars['String']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this merged event. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this merged event. */\n  url: Scalars['URI']['output'];\n};\n\n/** Represents a GitHub Enterprise Importer (GEI) migration. */\nexport type Migration = {\n  /** The migration flag to continue on error. */\n  continueOnError: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['String']['output']>;\n  /** The reason the migration failed. */\n  failureReason?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The URL for the migration log (expires 1 day after migration completes). */\n  migrationLogUrl?: Maybe<Scalars['URI']['output']>;\n  /** The migration source. */\n  migrationSource: MigrationSource;\n  /** The target repository name. */\n  repositoryName: Scalars['String']['output'];\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  sourceUrl: Scalars['URI']['output'];\n  /** The migration state. */\n  state: MigrationState;\n  /**\n   * The number of warnings encountered for this migration. To review the warnings,\n   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).\n   */\n  warningsCount: Scalars['Int']['output'];\n};\n\n/** A GitHub Enterprise Importer (GEI) migration source. */\nexport type MigrationSource = Node & {\n  id: Scalars['ID']['output'];\n  /** The migration source name. */\n  name: Scalars['String']['output'];\n  /** The migration source type. */\n  type: MigrationSourceType;\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  url: Scalars['URI']['output'];\n};\n\n/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */\nexport enum MigrationSourceType {\n  /** An Azure DevOps migration source. */\n  AzureDevops = 'AZURE_DEVOPS',\n  /** A Bitbucket Server migration source. */\n  BitbucketServer = 'BITBUCKET_SERVER',\n  /** A GitHub Migration API source. */\n  GithubArchive = 'GITHUB_ARCHIVE'\n}\n\n/** The GitHub Enterprise Importer (GEI) migration state. */\nexport enum MigrationState {\n  /** The migration has failed. */\n  Failed = 'FAILED',\n  /** The migration has invalid credentials. */\n  FailedValidation = 'FAILED_VALIDATION',\n  /** The migration is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The migration has not started. */\n  NotStarted = 'NOT_STARTED',\n  /** The migration needs to have its credentials validated. */\n  PendingValidation = 'PENDING_VALIDATION',\n  /** The migration has been queued. */\n  Queued = 'QUEUED',\n  /** The migration has succeeded. */\n  Succeeded = 'SUCCEEDED'\n}\n\n/** Represents a Milestone object on a given repository. */\nexport type Milestone = Closable & Node & UniformResourceLocatable & {\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the actor who created the milestone. */\n  creator?: Maybe<Actor>;\n  /** Identifies the description of the milestone. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** Identifies the due date of the milestone. */\n  dueOn?: Maybe<Scalars['DateTime']['output']>;\n  id: Scalars['ID']['output'];\n  /** A list of issues associated with the milestone. */\n  issues: IssueConnection;\n  /** Identifies the number of the milestone. */\n  number: Scalars['Int']['output'];\n  /** Identifies the percentage complete for the milestone */\n  progressPercentage: Scalars['Float']['output'];\n  /** A list of pull requests associated with the milestone. */\n  pullRequests: PullRequestConnection;\n  /** The repository associated with this milestone. */\n  repository: Repository;\n  /** The HTTP path for this milestone */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the state of the milestone. */\n  state: MilestoneState;\n  /** Identifies the title of the milestone. */\n  title: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this milestone */\n  url: Scalars['URI']['output'];\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestoneIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestonePullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  headRefName?: InputMaybe<Scalars['String']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Milestone. */\nexport type MilestoneConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Milestone>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type MilestoneEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Milestone>;\n};\n\n/** Types that can be inside a Milestone. */\nexport type MilestoneItem = Issue | PullRequest;\n\n/** Ordering options for milestone connections. */\nexport type MilestoneOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order milestones by. */\n  field: MilestoneOrderField;\n};\n\n/** Properties by which milestone connections can be ordered. */\nexport enum MilestoneOrderField {\n  /** Order milestones by when they were created. */\n  CreatedAt = 'CREATED_AT',\n  /** Order milestones by when they are due. */\n  DueDate = 'DUE_DATE',\n  /** Order milestones by their number. */\n  Number = 'NUMBER',\n  /** Order milestones by when they were last updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible states of a milestone. */\nexport enum MilestoneState {\n  /** A milestone that has been closed. */\n  Closed = 'CLOSED',\n  /** A milestone that is still open. */\n  Open = 'OPEN'\n}\n\n/** Represents a 'milestoned' event on a given issue or pull request. */\nexport type MilestonedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the milestone title associated with the 'milestoned' event. */\n  milestoneTitle: Scalars['String']['output'];\n  /** Object referenced by event. */\n  subject: MilestoneItem;\n};\n\n/** Entities that can be minimized. */\nexport type Minimizable = {\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']['output'];\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']['output']>;\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']['output'];\n};\n\n/** Autogenerated input type of MinimizeComment */\nexport type MinimizeCommentInput = {\n  /** The classification of comment */\n  classifier: ReportedContentClassifiers;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MinimizeComment */\nexport type MinimizeCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The comment that was minimized. */\n  minimizedComment?: Maybe<Minimizable>;\n};\n\n/** Autogenerated input type of MoveProjectCard */\nexport type MoveProjectCardInput = {\n  /** Place the new card after the card with this id. Pass null to place it at the top. */\n  afterCardId?: InputMaybe<Scalars['ID']['input']>;\n  /** The id of the card to move. */\n  cardId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the column to move it into. */\n  columnId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MoveProjectCard */\nexport type MoveProjectCardPayload = {\n  /** The new edge of the moved card. */\n  cardEdge?: Maybe<ProjectCardEdge>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of MoveProjectColumn */\nexport type MoveProjectColumnInput = {\n  /** Place the new column after the column with this id. Pass null to place it at the front. */\n  afterColumnId?: InputMaybe<Scalars['ID']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The id of the column to move. */\n  columnId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of MoveProjectColumn */\nexport type MoveProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new edge of the moved column. */\n  columnEdge?: Maybe<ProjectColumnEdge>;\n};\n\n/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\nexport type MovedColumnsInProjectEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type Mutation = {\n  /** Clear all of a customer's queued migrations */\n  abortQueuedMigrations?: Maybe<AbortQueuedMigrationsPayload>;\n  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */\n  acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>;\n  /** Applies a suggested topic to the repository. */\n  acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>;\n  /** Adds assignees to an assignable object. */\n  addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>;\n  /** Adds a comment to an Issue or Pull Request. */\n  addComment?: Maybe<AddCommentPayload>;\n  /** Adds a comment to a Discussion, possibly as a reply to another comment. */\n  addDiscussionComment?: Maybe<AddDiscussionCommentPayload>;\n  /** Vote for an option in a discussion poll. */\n  addDiscussionPollVote?: Maybe<AddDiscussionPollVotePayload>;\n  /** Adds enterprise members to an organization within the enterprise. */\n  addEnterpriseOrganizationMember?: Maybe<AddEnterpriseOrganizationMemberPayload>;\n  /** Adds a support entitlement to an enterprise member. */\n  addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>;\n  /** Adds labels to a labelable object. */\n  addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>;\n  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */\n  addProjectCard?: Maybe<AddProjectCardPayload>;\n  /** Adds a column to a Project. */\n  addProjectColumn?: Maybe<AddProjectColumnPayload>;\n  /** Creates a new draft issue and add it to a Project. */\n  addProjectV2DraftIssue?: Maybe<AddProjectV2DraftIssuePayload>;\n  /** Links an existing content instance to a Project. */\n  addProjectV2ItemById?: Maybe<AddProjectV2ItemByIdPayload>;\n  /** Adds a review to a Pull Request. */\n  addPullRequestReview?: Maybe<AddPullRequestReviewPayload>;\n  /** Adds a comment to a review. */\n  addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>;\n  /** Adds a new thread to a pending Pull Request Review. */\n  addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>;\n  /** Adds a reaction to a subject. */\n  addReaction?: Maybe<AddReactionPayload>;\n  /** Adds a star to a Starrable. */\n  addStar?: Maybe<AddStarPayload>;\n  /** Add an upvote to a discussion or discussion comment. */\n  addUpvote?: Maybe<AddUpvotePayload>;\n  /** Adds a verifiable domain to an owning account. */\n  addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>;\n  /** Approve all pending deployments under one or more environments */\n  approveDeployments?: Maybe<ApproveDeploymentsPayload>;\n  /** Approve a verifiable domain for notification delivery. */\n  approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>;\n  /** Archives a ProjectV2Item */\n  archiveProjectV2Item?: Maybe<ArchiveProjectV2ItemPayload>;\n  /** Marks a repository as archived. */\n  archiveRepository?: Maybe<ArchiveRepositoryPayload>;\n  /** Cancels a pending invitation for an administrator to join an enterprise. */\n  cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>;\n  /** Cancel an active sponsorship. */\n  cancelSponsorship?: Maybe<CancelSponsorshipPayload>;\n  /** Update your status on GitHub. */\n  changeUserStatus?: Maybe<ChangeUserStatusPayload>;\n  /** Clears all labels from a labelable object. */\n  clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>;\n  /**\n   * This mutation clears the value of a field for an item in a Project. Currently\n   * only text, number, date, assignees, labels, single-select, iteration and\n   * milestone fields are supported.\n   */\n  clearProjectV2ItemFieldValue?: Maybe<ClearProjectV2ItemFieldValuePayload>;\n  /** Creates a new project by cloning configuration from an existing project. */\n  cloneProject?: Maybe<CloneProjectPayload>;\n  /** Create a new repository with the same files and directory structure as a template repository. */\n  cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>;\n  /** Close a discussion. */\n  closeDiscussion?: Maybe<CloseDiscussionPayload>;\n  /** Close an issue. */\n  closeIssue?: Maybe<CloseIssuePayload>;\n  /** Close a pull request. */\n  closePullRequest?: Maybe<ClosePullRequestPayload>;\n  /** Convert a project note card to one associated with a newly created issue. */\n  convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>;\n  /** Converts a pull request to draft */\n  convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>;\n  /** Copy a project. */\n  copyProjectV2?: Maybe<CopyProjectV2Payload>;\n  /** Invites a user to claim reattributable data */\n  createAttributionInvitation?: Maybe<CreateAttributionInvitationPayload>;\n  /** Create a new branch protection rule */\n  createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>;\n  /** Create a check run. */\n  createCheckRun?: Maybe<CreateCheckRunPayload>;\n  /** Create a check suite */\n  createCheckSuite?: Maybe<CreateCheckSuitePayload>;\n  /**\n   * Appends a commit to the given branch as the authenticated user.\n   *\n   * This mutation creates a commit whose parent is the HEAD of the provided\n   * branch and also updates that branch to point to the new commit.\n   * It can be thought of as similar to `git commit`.\n   *\n   * ### Locating a Branch\n   *\n   * Commits are appended to a `branch` of type `Ref`.\n   * This must refer to a git branch (i.e.  the fully qualified path must\n   * begin with `refs/heads/`, although including this prefix is optional.\n   *\n   * Callers may specify the `branch` to commit to either by its global node\n   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For\n   * more details see the documentation for `CommittableBranch`.\n   *\n   * ### Describing Changes\n   *\n   * `fileChanges` are specified as a `FilesChanges` object describing\n   * `FileAdditions` and `FileDeletions`.\n   *\n   * Please see the documentation for `FileChanges` for more information on\n   * how to use this argument to describe any set of file changes.\n   *\n   * ### Authorship\n   *\n   * Similar to the web commit interface, this mutation does not support\n   * specifying the author or committer of the commit and will not add\n   * support for this in the future.\n   *\n   * A commit created by a successful execution of this mutation will be\n   * authored by the owner of the credential which authenticates the API\n   * request.  The committer will be identical to that of commits authored\n   * using the web interface.\n   *\n   * If you need full control over author and committer information, please\n   * use the Git Database REST API instead.\n   *\n   * ### Commit Signing\n   *\n   * Commits made using this mutation are automatically signed by GitHub if\n   * supported and will be marked as verified in the user interface.\n   */\n  createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>;\n  /** Create a discussion. */\n  createDiscussion?: Maybe<CreateDiscussionPayload>;\n  /** Creates an organization as part of an enterprise account. */\n  createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>;\n  /** Creates an environment or simply returns it if already exists. */\n  createEnvironment?: Maybe<CreateEnvironmentPayload>;\n  /** Creates a new IP allow list entry. */\n  createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>;\n  /** Creates a new issue. */\n  createIssue?: Maybe<CreateIssuePayload>;\n  /** Create a branch linked to an issue. */\n  createLinkedBranch?: Maybe<CreateLinkedBranchPayload>;\n  /** Creates a GitHub Enterprise Importer (GEI) migration source. */\n  createMigrationSource?: Maybe<CreateMigrationSourcePayload>;\n  /** Creates a new project. */\n  createProject?: Maybe<CreateProjectPayload>;\n  /** Creates a new project. */\n  createProjectV2?: Maybe<CreateProjectV2Payload>;\n  /** Create a new project field. */\n  createProjectV2Field?: Maybe<CreateProjectV2FieldPayload>;\n  /** Create a new pull request */\n  createPullRequest?: Maybe<CreatePullRequestPayload>;\n  /** Create a new Git Ref. */\n  createRef?: Maybe<CreateRefPayload>;\n  /** Create a new repository. */\n  createRepository?: Maybe<CreateRepositoryPayload>;\n  /** Create a repository ruleset */\n  createRepositoryRuleset?: Maybe<CreateRepositoryRulesetPayload>;\n  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */\n  createSponsorsListing?: Maybe<CreateSponsorsListingPayload>;\n  /** Create a new payment tier for your GitHub Sponsors profile. */\n  createSponsorsTier?: Maybe<CreateSponsorsTierPayload>;\n  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */\n  createSponsorship?: Maybe<CreateSponsorshipPayload>;\n  /**\n   * Make many one-time sponsorships for different sponsorable users or\n   * organizations at once. Can only sponsor those who have a public GitHub\n   * Sponsors profile.\n   */\n  createSponsorships?: Maybe<CreateSponsorshipsPayload>;\n  /** Creates a new team discussion. */\n  createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>;\n  /** Creates a new team discussion comment. */\n  createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>;\n  /** Rejects a suggested topic for the repository. */\n  declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>;\n  /** Delete a branch protection rule */\n  deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>;\n  /** Deletes a deployment. */\n  deleteDeployment?: Maybe<DeleteDeploymentPayload>;\n  /** Delete a discussion and all of its replies. */\n  deleteDiscussion?: Maybe<DeleteDiscussionPayload>;\n  /** Delete a discussion comment. If it has replies, wipe it instead. */\n  deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>;\n  /** Deletes an environment */\n  deleteEnvironment?: Maybe<DeleteEnvironmentPayload>;\n  /** Deletes an IP allow list entry. */\n  deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>;\n  /** Deletes an Issue object. */\n  deleteIssue?: Maybe<DeleteIssuePayload>;\n  /** Deletes an IssueComment object. */\n  deleteIssueComment?: Maybe<DeleteIssueCommentPayload>;\n  /** Unlink a branch from an issue. */\n  deleteLinkedBranch?: Maybe<DeleteLinkedBranchPayload>;\n  /** Deletes a project. */\n  deleteProject?: Maybe<DeleteProjectPayload>;\n  /** Deletes a project card. */\n  deleteProjectCard?: Maybe<DeleteProjectCardPayload>;\n  /** Deletes a project column. */\n  deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>;\n  /** Delete a project. */\n  deleteProjectV2?: Maybe<DeleteProjectV2Payload>;\n  /** Delete a project field. */\n  deleteProjectV2Field?: Maybe<DeleteProjectV2FieldPayload>;\n  /** Deletes an item from a Project. */\n  deleteProjectV2Item?: Maybe<DeleteProjectV2ItemPayload>;\n  /** Deletes a project workflow. */\n  deleteProjectV2Workflow?: Maybe<DeleteProjectV2WorkflowPayload>;\n  /** Deletes a pull request review. */\n  deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>;\n  /** Deletes a pull request review comment. */\n  deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>;\n  /** Delete a Git Ref. */\n  deleteRef?: Maybe<DeleteRefPayload>;\n  /** Delete a repository ruleset */\n  deleteRepositoryRuleset?: Maybe<DeleteRepositoryRulesetPayload>;\n  /** Deletes a team discussion. */\n  deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>;\n  /** Deletes a team discussion comment. */\n  deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>;\n  /** Deletes a verifiable domain. */\n  deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>;\n  /** Remove a pull request from the merge queue. */\n  dequeuePullRequest?: Maybe<DequeuePullRequestPayload>;\n  /** Disable auto merge on the given pull request */\n  disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>;\n  /** Dismisses an approved or rejected pull request review. */\n  dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>;\n  /** Dismisses the Dependabot alert. */\n  dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>;\n  /** Enable the default auto-merge on a pull request. */\n  enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>;\n  /** Add a pull request to the merge queue. */\n  enqueuePullRequest?: Maybe<EnqueuePullRequestPayload>;\n  /** Follow an organization. */\n  followOrganization?: Maybe<FollowOrganizationPayload>;\n  /** Follow a user. */\n  followUser?: Maybe<FollowUserPayload>;\n  /** Grant the migrator role to a user for all organizations under an enterprise account. */\n  grantEnterpriseOrganizationsMigratorRole?: Maybe<GrantEnterpriseOrganizationsMigratorRolePayload>;\n  /** Grant the migrator role to a user or a team. */\n  grantMigratorRole?: Maybe<GrantMigratorRolePayload>;\n  /** Invite someone to become an administrator of the enterprise. */\n  inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>;\n  /** Links a project to a repository. */\n  linkProjectV2ToRepository?: Maybe<LinkProjectV2ToRepositoryPayload>;\n  /** Links a project to a team. */\n  linkProjectV2ToTeam?: Maybe<LinkProjectV2ToTeamPayload>;\n  /** Creates a repository link for a project. */\n  linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>;\n  /** Lock a lockable object */\n  lockLockable?: Maybe<LockLockablePayload>;\n  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */\n  markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>;\n  /** Mark a pull request file as viewed */\n  markFileAsViewed?: Maybe<MarkFileAsViewedPayload>;\n  /** Mark a project as a template. Note that only projects which are owned by an Organization can be marked as a template. */\n  markProjectV2AsTemplate?: Maybe<MarkProjectV2AsTemplatePayload>;\n  /** Marks a pull request ready for review. */\n  markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>;\n  /** Merge a head into a branch. */\n  mergeBranch?: Maybe<MergeBranchPayload>;\n  /** Merge a pull request. */\n  mergePullRequest?: Maybe<MergePullRequestPayload>;\n  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  minimizeComment?: Maybe<MinimizeCommentPayload>;\n  /** Moves a project card to another place. */\n  moveProjectCard?: Maybe<MoveProjectCardPayload>;\n  /** Moves a project column to another place. */\n  moveProjectColumn?: Maybe<MoveProjectColumnPayload>;\n  /** Pin an issue to a repository */\n  pinIssue?: Maybe<PinIssuePayload>;\n  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */\n  publishSponsorsTier?: Maybe<PublishSponsorsTierPayload>;\n  /** Regenerates the identity provider recovery codes for an enterprise */\n  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;\n  /** Regenerates a verifiable domain's verification token. */\n  regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>;\n  /** Reject all pending deployments under one or more environments */\n  rejectDeployments?: Maybe<RejectDeploymentsPayload>;\n  /** Removes assignees from an assignable object. */\n  removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>;\n  /** Removes an administrator from the enterprise. */\n  removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>;\n  /** Removes the identity provider from an enterprise */\n  removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>;\n  /** Removes a user from all organizations within the enterprise */\n  removeEnterpriseMember?: Maybe<RemoveEnterpriseMemberPayload>;\n  /** Removes an organization from the enterprise */\n  removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>;\n  /** Removes a support entitlement from an enterprise member. */\n  removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>;\n  /** Removes labels from a Labelable object. */\n  removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>;\n  /** Removes outside collaborator from all repositories in an organization. */\n  removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>;\n  /** Removes a reaction from a subject. */\n  removeReaction?: Maybe<RemoveReactionPayload>;\n  /** Removes a star from a Starrable. */\n  removeStar?: Maybe<RemoveStarPayload>;\n  /** Remove an upvote to a discussion or discussion comment. */\n  removeUpvote?: Maybe<RemoveUpvotePayload>;\n  /** Reopen a discussion. */\n  reopenDiscussion?: Maybe<ReopenDiscussionPayload>;\n  /** Reopen a issue. */\n  reopenIssue?: Maybe<ReopenIssuePayload>;\n  /** Reopen a pull request. */\n  reopenPullRequest?: Maybe<ReopenPullRequestPayload>;\n  /** Set review requests on a pull request. */\n  requestReviews?: Maybe<RequestReviewsPayload>;\n  /** Rerequests an existing check suite. */\n  rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>;\n  /** Marks a review thread as resolved. */\n  resolveReviewThread?: Maybe<ResolveReviewThreadPayload>;\n  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */\n  retireSponsorsTier?: Maybe<RetireSponsorsTierPayload>;\n  /** Create a pull request that reverts the changes from a merged pull request. */\n  revertPullRequest?: Maybe<RevertPullRequestPayload>;\n  /** Revoke the migrator role to a user for all organizations under an enterprise account. */\n  revokeEnterpriseOrganizationsMigratorRole?: Maybe<RevokeEnterpriseOrganizationsMigratorRolePayload>;\n  /** Revoke the migrator role from a user or a team. */\n  revokeMigratorRole?: Maybe<RevokeMigratorRolePayload>;\n  /** Creates or updates the identity provider for an enterprise. */\n  setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>;\n  /** Set an organization level interaction limit for an organization's public repositories. */\n  setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>;\n  /** Sets an interaction limit setting for a repository. */\n  setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>;\n  /** Set a user level interaction limit for an user's public repositories. */\n  setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>;\n  /** Starts a GitHub Enterprise Importer organization migration. */\n  startOrganizationMigration?: Maybe<StartOrganizationMigrationPayload>;\n  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */\n  startRepositoryMigration?: Maybe<StartRepositoryMigrationPayload>;\n  /** Submits a pending pull request review. */\n  submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>;\n  /** Transfer an organization from one enterprise to another enterprise. */\n  transferEnterpriseOrganization?: Maybe<TransferEnterpriseOrganizationPayload>;\n  /** Transfer an issue to a different repository */\n  transferIssue?: Maybe<TransferIssuePayload>;\n  /** Unarchives a ProjectV2Item */\n  unarchiveProjectV2Item?: Maybe<UnarchiveProjectV2ItemPayload>;\n  /** Unarchives a repository. */\n  unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>;\n  /** Unfollow an organization. */\n  unfollowOrganization?: Maybe<UnfollowOrganizationPayload>;\n  /** Unfollow a user. */\n  unfollowUser?: Maybe<UnfollowUserPayload>;\n  /** Unlinks a project from a repository. */\n  unlinkProjectV2FromRepository?: Maybe<UnlinkProjectV2FromRepositoryPayload>;\n  /** Unlinks a project to a team. */\n  unlinkProjectV2FromTeam?: Maybe<UnlinkProjectV2FromTeamPayload>;\n  /** Deletes a repository link from a project. */\n  unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>;\n  /** Unlock a lockable object */\n  unlockLockable?: Maybe<UnlockLockablePayload>;\n  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */\n  unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>;\n  /** Unmark a pull request file as viewed */\n  unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>;\n  /** Unmark an issue as a duplicate of another issue. */\n  unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>;\n  /** Unmark a project as a template. */\n  unmarkProjectV2AsTemplate?: Maybe<UnmarkProjectV2AsTemplatePayload>;\n  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  unminimizeComment?: Maybe<UnminimizeCommentPayload>;\n  /** Unpin a pinned issue from a repository */\n  unpinIssue?: Maybe<UnpinIssuePayload>;\n  /** Marks a review thread as unresolved. */\n  unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>;\n  /** Update a branch protection rule */\n  updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>;\n  /** Update a check run */\n  updateCheckRun?: Maybe<UpdateCheckRunPayload>;\n  /** Modifies the settings of an existing check suite */\n  updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>;\n  /** Update a discussion */\n  updateDiscussion?: Maybe<UpdateDiscussionPayload>;\n  /** Update the contents of a comment on a Discussion */\n  updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>;\n  /** Updates the role of an enterprise administrator. */\n  updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>;\n  /** Sets whether private repository forks are enabled for an enterprise. */\n  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;\n  /** Sets the base repository permission for organizations in an enterprise. */\n  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;\n  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */\n  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;\n  /** Sets the members can create repositories setting for an enterprise. */\n  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;\n  /** Sets the members can delete issues setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;\n  /** Sets the members can delete repositories setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;\n  /** Sets whether members can invite collaborators are enabled for an enterprise. */\n  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;\n  /** Sets whether or not an organization admin can make purchases. */\n  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;\n  /** Sets the members can update protected branches setting for an enterprise. */\n  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;\n  /** Sets the members can view dependency insights for an enterprise. */\n  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;\n  /** Sets whether organization projects are enabled for an enterprise. */\n  updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>;\n  /** Updates the role of an enterprise owner with an organization. */\n  updateEnterpriseOwnerOrganizationRole?: Maybe<UpdateEnterpriseOwnerOrganizationRolePayload>;\n  /** Updates an enterprise's profile. */\n  updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>;\n  /** Sets whether repository projects are enabled for a enterprise. */\n  updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>;\n  /** Sets whether team discussions are enabled for an enterprise. */\n  updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>;\n  /** Sets whether two factor authentication is required for all users in an enterprise. */\n  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;\n  /** Updates an environment. */\n  updateEnvironment?: Maybe<UpdateEnvironmentPayload>;\n  /** Sets whether an IP allow list is enabled on an owner. */\n  updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>;\n  /** Updates an IP allow list entry. */\n  updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>;\n  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */\n  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;\n  /** Updates an Issue. */\n  updateIssue?: Maybe<UpdateIssuePayload>;\n  /** Updates an IssueComment object. */\n  updateIssueComment?: Maybe<UpdateIssueCommentPayload>;\n  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */\n  updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>;\n  /** Sets whether private repository forks are enabled for an organization. */\n  updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;\n  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */\n  updateOrganizationWebCommitSignoffSetting?: Maybe<UpdateOrganizationWebCommitSignoffSettingPayload>;\n  /** Updates an existing project. */\n  updateProject?: Maybe<UpdateProjectPayload>;\n  /** Updates an existing project card. */\n  updateProjectCard?: Maybe<UpdateProjectCardPayload>;\n  /** Updates an existing project column. */\n  updateProjectColumn?: Maybe<UpdateProjectColumnPayload>;\n  /** Updates an existing project (beta). */\n  updateProjectV2?: Maybe<UpdateProjectV2Payload>;\n  /** Update the collaborators on a team or a project */\n  updateProjectV2Collaborators?: Maybe<UpdateProjectV2CollaboratorsPayload>;\n  /** Updates a draft issue within a Project. */\n  updateProjectV2DraftIssue?: Maybe<UpdateProjectV2DraftIssuePayload>;\n  /**\n   * This mutation updates the value of a field for an item in a Project. Currently\n   * only single-select, text, number, date, and iteration fields are supported.\n   */\n  updateProjectV2ItemFieldValue?: Maybe<UpdateProjectV2ItemFieldValuePayload>;\n  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */\n  updateProjectV2ItemPosition?: Maybe<UpdateProjectV2ItemPositionPayload>;\n  /** Update a pull request */\n  updatePullRequest?: Maybe<UpdatePullRequestPayload>;\n  /** Merge or Rebase HEAD from upstream branch into pull request branch */\n  updatePullRequestBranch?: Maybe<UpdatePullRequestBranchPayload>;\n  /** Updates the body of a pull request review. */\n  updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>;\n  /** Updates a pull request review comment. */\n  updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>;\n  /** Update a Git Ref. */\n  updateRef?: Maybe<UpdateRefPayload>;\n  /** Update information about a repository. */\n  updateRepository?: Maybe<UpdateRepositoryPayload>;\n  /** Update a repository ruleset */\n  updateRepositoryRuleset?: Maybe<UpdateRepositoryRulesetPayload>;\n  /** Sets whether contributors are required to sign off on web-based commits for a repository. */\n  updateRepositoryWebCommitSignoffSetting?: Maybe<UpdateRepositoryWebCommitSignoffSettingPayload>;\n  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */\n  updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>;\n  /** Updates the state for subscribable subjects. */\n  updateSubscription?: Maybe<UpdateSubscriptionPayload>;\n  /** Updates a team discussion. */\n  updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>;\n  /** Updates a discussion comment. */\n  updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>;\n  /** Update team repository. */\n  updateTeamsRepository?: Maybe<UpdateTeamsRepositoryPayload>;\n  /** Replaces the repository's topics with the given topics. */\n  updateTopics?: Maybe<UpdateTopicsPayload>;\n  /** Verify that a verifiable domain has the expected DNS record. */\n  verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAbortQueuedMigrationsArgs = {\n  input: AbortQueuedMigrationsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptEnterpriseAdministratorInvitationArgs = {\n  input: AcceptEnterpriseAdministratorInvitationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptTopicSuggestionArgs = {\n  input: AcceptTopicSuggestionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddAssigneesToAssignableArgs = {\n  input: AddAssigneesToAssignableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddCommentArgs = {\n  input: AddCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddDiscussionCommentArgs = {\n  input: AddDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddDiscussionPollVoteArgs = {\n  input: AddDiscussionPollVoteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddEnterpriseOrganizationMemberArgs = {\n  input: AddEnterpriseOrganizationMemberInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddEnterpriseSupportEntitlementArgs = {\n  input: AddEnterpriseSupportEntitlementInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddLabelsToLabelableArgs = {\n  input: AddLabelsToLabelableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectCardArgs = {\n  input: AddProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectColumnArgs = {\n  input: AddProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectV2DraftIssueArgs = {\n  input: AddProjectV2DraftIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectV2ItemByIdArgs = {\n  input: AddProjectV2ItemByIdInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewArgs = {\n  input: AddPullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewCommentArgs = {\n  input: AddPullRequestReviewCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewThreadArgs = {\n  input: AddPullRequestReviewThreadInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddReactionArgs = {\n  input: AddReactionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddStarArgs = {\n  input: AddStarInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddUpvoteArgs = {\n  input: AddUpvoteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddVerifiableDomainArgs = {\n  input: AddVerifiableDomainInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveDeploymentsArgs = {\n  input: ApproveDeploymentsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveVerifiableDomainArgs = {\n  input: ApproveVerifiableDomainInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationArchiveProjectV2ItemArgs = {\n  input: ArchiveProjectV2ItemInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationArchiveRepositoryArgs = {\n  input: ArchiveRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelEnterpriseAdminInvitationArgs = {\n  input: CancelEnterpriseAdminInvitationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelSponsorshipArgs = {\n  input: CancelSponsorshipInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationChangeUserStatusArgs = {\n  input: ChangeUserStatusInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClearLabelsFromLabelableArgs = {\n  input: ClearLabelsFromLabelableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClearProjectV2ItemFieldValueArgs = {\n  input: ClearProjectV2ItemFieldValueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneProjectArgs = {\n  input: CloneProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneTemplateRepositoryArgs = {\n  input: CloneTemplateRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloseDiscussionArgs = {\n  input: CloseDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloseIssueArgs = {\n  input: CloseIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClosePullRequestArgs = {\n  input: ClosePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertProjectCardNoteToIssueArgs = {\n  input: ConvertProjectCardNoteToIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertPullRequestToDraftArgs = {\n  input: ConvertPullRequestToDraftInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCopyProjectV2Args = {\n  input: CopyProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateAttributionInvitationArgs = {\n  input: CreateAttributionInvitationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateBranchProtectionRuleArgs = {\n  input: CreateBranchProtectionRuleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckRunArgs = {\n  input: CreateCheckRunInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckSuiteArgs = {\n  input: CreateCheckSuiteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCommitOnBranchArgs = {\n  input: CreateCommitOnBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDiscussionArgs = {\n  input: CreateDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnterpriseOrganizationArgs = {\n  input: CreateEnterpriseOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnvironmentArgs = {\n  input: CreateEnvironmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIpAllowListEntryArgs = {\n  input: CreateIpAllowListEntryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIssueArgs = {\n  input: CreateIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateLinkedBranchArgs = {\n  input: CreateLinkedBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateMigrationSourceArgs = {\n  input: CreateMigrationSourceInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectArgs = {\n  input: CreateProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectV2Args = {\n  input: CreateProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectV2FieldArgs = {\n  input: CreateProjectV2FieldInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreatePullRequestArgs = {\n  input: CreatePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRefArgs = {\n  input: CreateRefInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRepositoryArgs = {\n  input: CreateRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRepositoryRulesetArgs = {\n  input: CreateRepositoryRulesetInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorsListingArgs = {\n  input: CreateSponsorsListingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorsTierArgs = {\n  input: CreateSponsorsTierInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorshipArgs = {\n  input: CreateSponsorshipInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorshipsArgs = {\n  input: CreateSponsorshipsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionArgs = {\n  input: CreateTeamDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionCommentArgs = {\n  input: CreateTeamDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeclineTopicSuggestionArgs = {\n  input: DeclineTopicSuggestionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteBranchProtectionRuleArgs = {\n  input: DeleteBranchProtectionRuleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDeploymentArgs = {\n  input: DeleteDeploymentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionArgs = {\n  input: DeleteDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionCommentArgs = {\n  input: DeleteDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteEnvironmentArgs = {\n  input: DeleteEnvironmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIpAllowListEntryArgs = {\n  input: DeleteIpAllowListEntryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueArgs = {\n  input: DeleteIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueCommentArgs = {\n  input: DeleteIssueCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteLinkedBranchArgs = {\n  input: DeleteLinkedBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectArgs = {\n  input: DeleteProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectCardArgs = {\n  input: DeleteProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectColumnArgs = {\n  input: DeleteProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2Args = {\n  input: DeleteProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2FieldArgs = {\n  input: DeleteProjectV2FieldInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2ItemArgs = {\n  input: DeleteProjectV2ItemInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2WorkflowArgs = {\n  input: DeleteProjectV2WorkflowInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewArgs = {\n  input: DeletePullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewCommentArgs = {\n  input: DeletePullRequestReviewCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteRefArgs = {\n  input: DeleteRefInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteRepositoryRulesetArgs = {\n  input: DeleteRepositoryRulesetInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionArgs = {\n  input: DeleteTeamDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionCommentArgs = {\n  input: DeleteTeamDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteVerifiableDomainArgs = {\n  input: DeleteVerifiableDomainInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDequeuePullRequestArgs = {\n  input: DequeuePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDisablePullRequestAutoMergeArgs = {\n  input: DisablePullRequestAutoMergeInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissPullRequestReviewArgs = {\n  input: DismissPullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissRepositoryVulnerabilityAlertArgs = {\n  input: DismissRepositoryVulnerabilityAlertInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationEnablePullRequestAutoMergeArgs = {\n  input: EnablePullRequestAutoMergeInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationEnqueuePullRequestArgs = {\n  input: EnqueuePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowOrganizationArgs = {\n  input: FollowOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowUserArgs = {\n  input: FollowUserInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationGrantEnterpriseOrganizationsMigratorRoleArgs = {\n  input: GrantEnterpriseOrganizationsMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationGrantMigratorRoleArgs = {\n  input: GrantMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationInviteEnterpriseAdminArgs = {\n  input: InviteEnterpriseAdminInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkProjectV2ToRepositoryArgs = {\n  input: LinkProjectV2ToRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkProjectV2ToTeamArgs = {\n  input: LinkProjectV2ToTeamInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkRepositoryToProjectArgs = {\n  input: LinkRepositoryToProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLockLockableArgs = {\n  input: LockLockableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkDiscussionCommentAsAnswerArgs = {\n  input: MarkDiscussionCommentAsAnswerInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkFileAsViewedArgs = {\n  input: MarkFileAsViewedInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkProjectV2AsTemplateArgs = {\n  input: MarkProjectV2AsTemplateInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkPullRequestReadyForReviewArgs = {\n  input: MarkPullRequestReadyForReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergeBranchArgs = {\n  input: MergeBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergePullRequestArgs = {\n  input: MergePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMinimizeCommentArgs = {\n  input: MinimizeCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectCardArgs = {\n  input: MoveProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectColumnArgs = {\n  input: MoveProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationPinIssueArgs = {\n  input: PinIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationPublishSponsorsTierArgs = {\n  input: PublishSponsorsTierInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {\n  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateVerifiableDomainTokenArgs = {\n  input: RegenerateVerifiableDomainTokenInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRejectDeploymentsArgs = {\n  input: RejectDeploymentsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveAssigneesFromAssignableArgs = {\n  input: RemoveAssigneesFromAssignableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseAdminArgs = {\n  input: RemoveEnterpriseAdminInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseIdentityProviderArgs = {\n  input: RemoveEnterpriseIdentityProviderInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseMemberArgs = {\n  input: RemoveEnterpriseMemberInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseOrganizationArgs = {\n  input: RemoveEnterpriseOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseSupportEntitlementArgs = {\n  input: RemoveEnterpriseSupportEntitlementInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveLabelsFromLabelableArgs = {\n  input: RemoveLabelsFromLabelableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveOutsideCollaboratorArgs = {\n  input: RemoveOutsideCollaboratorInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveReactionArgs = {\n  input: RemoveReactionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveStarArgs = {\n  input: RemoveStarInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveUpvoteArgs = {\n  input: RemoveUpvoteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenDiscussionArgs = {\n  input: ReopenDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenIssueArgs = {\n  input: ReopenIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenPullRequestArgs = {\n  input: ReopenPullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRequestReviewsArgs = {\n  input: RequestReviewsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRerequestCheckSuiteArgs = {\n  input: RerequestCheckSuiteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationResolveReviewThreadArgs = {\n  input: ResolveReviewThreadInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRetireSponsorsTierArgs = {\n  input: RetireSponsorsTierInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevertPullRequestArgs = {\n  input: RevertPullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevokeEnterpriseOrganizationsMigratorRoleArgs = {\n  input: RevokeEnterpriseOrganizationsMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevokeMigratorRoleArgs = {\n  input: RevokeMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetEnterpriseIdentityProviderArgs = {\n  input: SetEnterpriseIdentityProviderInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetOrganizationInteractionLimitArgs = {\n  input: SetOrganizationInteractionLimitInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetRepositoryInteractionLimitArgs = {\n  input: SetRepositoryInteractionLimitInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetUserInteractionLimitArgs = {\n  input: SetUserInteractionLimitInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationStartOrganizationMigrationArgs = {\n  input: StartOrganizationMigrationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationStartRepositoryMigrationArgs = {\n  input: StartRepositoryMigrationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSubmitPullRequestReviewArgs = {\n  input: SubmitPullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationTransferEnterpriseOrganizationArgs = {\n  input: TransferEnterpriseOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationTransferIssueArgs = {\n  input: TransferIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnarchiveProjectV2ItemArgs = {\n  input: UnarchiveProjectV2ItemInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnarchiveRepositoryArgs = {\n  input: UnarchiveRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowOrganizationArgs = {\n  input: UnfollowOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowUserArgs = {\n  input: UnfollowUserInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkProjectV2FromRepositoryArgs = {\n  input: UnlinkProjectV2FromRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkProjectV2FromTeamArgs = {\n  input: UnlinkProjectV2FromTeamInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkRepositoryFromProjectArgs = {\n  input: UnlinkRepositoryFromProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlockLockableArgs = {\n  input: UnlockLockableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkDiscussionCommentAsAnswerArgs = {\n  input: UnmarkDiscussionCommentAsAnswerInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkFileAsViewedArgs = {\n  input: UnmarkFileAsViewedInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkIssueAsDuplicateArgs = {\n  input: UnmarkIssueAsDuplicateInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkProjectV2AsTemplateArgs = {\n  input: UnmarkProjectV2AsTemplateInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnminimizeCommentArgs = {\n  input: UnminimizeCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnpinIssueArgs = {\n  input: UnpinIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnresolveReviewThreadArgs = {\n  input: UnresolveReviewThreadInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateBranchProtectionRuleArgs = {\n  input: UpdateBranchProtectionRuleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckRunArgs = {\n  input: UpdateCheckRunInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckSuitePreferencesArgs = {\n  input: UpdateCheckSuitePreferencesInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionArgs = {\n  input: UpdateDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionCommentArgs = {\n  input: UpdateDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAdministratorRoleArgs = {\n  input: UpdateEnterpriseAdministratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {\n  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {\n  input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {\n  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {\n  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {\n  input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {\n  input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOrganizationProjectsSettingArgs = {\n  input: UpdateEnterpriseOrganizationProjectsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOwnerOrganizationRoleArgs = {\n  input: UpdateEnterpriseOwnerOrganizationRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseProfileArgs = {\n  input: UpdateEnterpriseProfileInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseRepositoryProjectsSettingArgs = {\n  input: UpdateEnterpriseRepositoryProjectsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTeamDiscussionsSettingArgs = {\n  input: UpdateEnterpriseTeamDiscussionsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {\n  input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnvironmentArgs = {\n  input: UpdateEnvironmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEnabledSettingArgs = {\n  input: UpdateIpAllowListEnabledSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEntryArgs = {\n  input: UpdateIpAllowListEntryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs = {\n  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueArgs = {\n  input: UpdateIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueCommentArgs = {\n  input: UpdateIssueCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateNotificationRestrictionSettingArgs = {\n  input: UpdateNotificationRestrictionSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateOrganizationWebCommitSignoffSettingArgs = {\n  input: UpdateOrganizationWebCommitSignoffSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectArgs = {\n  input: UpdateProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectCardArgs = {\n  input: UpdateProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectColumnArgs = {\n  input: UpdateProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2Args = {\n  input: UpdateProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2CollaboratorsArgs = {\n  input: UpdateProjectV2CollaboratorsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2DraftIssueArgs = {\n  input: UpdateProjectV2DraftIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2ItemFieldValueArgs = {\n  input: UpdateProjectV2ItemFieldValueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2ItemPositionArgs = {\n  input: UpdateProjectV2ItemPositionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestArgs = {\n  input: UpdatePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestBranchArgs = {\n  input: UpdatePullRequestBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewArgs = {\n  input: UpdatePullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewCommentArgs = {\n  input: UpdatePullRequestReviewCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefArgs = {\n  input: UpdateRefInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryArgs = {\n  input: UpdateRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryRulesetArgs = {\n  input: UpdateRepositoryRulesetInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryWebCommitSignoffSettingArgs = {\n  input: UpdateRepositoryWebCommitSignoffSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSponsorshipPreferencesArgs = {\n  input: UpdateSponsorshipPreferencesInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSubscriptionArgs = {\n  input: UpdateSubscriptionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionArgs = {\n  input: UpdateTeamDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionCommentArgs = {\n  input: UpdateTeamDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamsRepositoryArgs = {\n  input: UpdateTeamsRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTopicsArgs = {\n  input: UpdateTopicsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationVerifyVerifiableDomainArgs = {\n  input: VerifyVerifiableDomainInput;\n};\n\n/** An object with an ID. */\nexport type Node = {\n  /** ID of the object. */\n  id: Scalars['ID']['output'];\n};\n\n/** The possible values for the notification restriction setting. */\nexport enum NotificationRestrictionSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n/**\n * An OIDC identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type OidcProvider = Node & {\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>;\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars['ID']['output'];\n  /** The OIDC identity provider type */\n  providerType: OidcProviderType;\n  /** The id of the tenant this provider is attached to */\n  tenantId: Scalars['String']['output'];\n};\n\n\n/**\n * An OIDC identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type OidcProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  login?: InputMaybe<Scalars['String']['input']>;\n  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  userName?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The OIDC identity provider type */\nexport enum OidcProviderType {\n  /** Azure Active Directory */\n  Aad = 'AAD'\n}\n\n/** Metadata for an audit entry with action oauth_application.* */\nexport type OauthApplicationAuditEntryData = {\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a oauth_application.create event. */\nexport type OauthApplicationCreateAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The application URL of the OAuth application. */\n  applicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The callback URL of the OAuth application. */\n  callbackUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The rate limit of the OAuth application. */\n  rateLimit?: Maybe<Scalars['Int']['output']>;\n  /** The state of the OAuth application. */\n  state?: Maybe<OauthApplicationCreateAuditEntryState>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The state of an OAuth application when it was created. */\nexport enum OauthApplicationCreateAuditEntryState {\n  /** The OAuth application was active and allowed to have OAuth Accesses. */\n  Active = 'ACTIVE',\n  /** The OAuth application was in the process of being deleted. */\n  PendingDeletion = 'PENDING_DELETION',\n  /** The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns. */\n  Suspended = 'SUSPENDED'\n}\n\n/** The corresponding operation type for the action */\nexport enum OperationType {\n  /** An existing resource was accessed */\n  Access = 'ACCESS',\n  /** A resource performed an authentication event */\n  Authentication = 'AUTHENTICATION',\n  /** A new resource was created */\n  Create = 'CREATE',\n  /** An existing resource was modified */\n  Modify = 'MODIFY',\n  /** An existing resource was removed */\n  Remove = 'REMOVE',\n  /** An existing resource was restored */\n  Restore = 'RESTORE',\n  /** An existing resource was transferred between multiple resources */\n  Transfer = 'TRANSFER'\n}\n\n/** Possible directions in which to order a list of items when provided an `orderBy` argument. */\nexport enum OrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC'\n}\n\n/** Audit log entry for a org.add_billing_manager */\nexport type OrgAddBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The email address used to invite a billing manager for the organization. */\n  invitationEmail?: Maybe<Scalars['String']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.add_member */\nexport type OrgAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The permission level of the member added to the organization. */\n  permission?: Maybe<OrgAddMemberAuditEntryPermission>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The permissions available to members on an Organization. */\nexport enum OrgAddMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ'\n}\n\n/** Audit log entry for a org.block_user */\nexport type OrgBlockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The blocked user. */\n  blockedUser?: Maybe<User>;\n  /** The username of the blocked user. */\n  blockedUserName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the blocked user. */\n  blockedUserResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the blocked user. */\n  blockedUserUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.config.disable_collaborators_only event. */\nexport type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.config.enable_collaborators_only event. */\nexport type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.create event. */\nexport type OrgCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The billing plan for the Organization. */\n  billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The billing plans available for organizations. */\nexport enum OrgCreateAuditEntryBillingPlan {\n  /** Team Plan */\n  Business = 'BUSINESS',\n  /** Enterprise Cloud Plan */\n  BusinessPlus = 'BUSINESS_PLUS',\n  /** Free Plan */\n  Free = 'FREE',\n  /** Tiered Per Seat Plan */\n  TieredPerSeat = 'TIERED_PER_SEAT',\n  /** Legacy Unlimited Plan */\n  Unlimited = 'UNLIMITED'\n}\n\n/** Audit log entry for a org.disable_oauth_app_restrictions event. */\nexport type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.disable_saml event. */\nexport type OrgDisableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The SAML provider's digest algorithm URL. */\n  digestMethodUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The SAML provider's issuer URL. */\n  issuerUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The SAML provider's signature algorithm URL. */\n  signatureMethodUrl?: Maybe<Scalars['URI']['output']>;\n  /** The SAML provider's single sign-on URL. */\n  singleSignOnUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.disable_two_factor_requirement event. */\nexport type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.enable_oauth_app_restrictions event. */\nexport type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.enable_saml event. */\nexport type OrgEnableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The SAML provider's digest algorithm URL. */\n  digestMethodUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The SAML provider's issuer URL. */\n  issuerUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The SAML provider's signature algorithm URL. */\n  signatureMethodUrl?: Maybe<Scalars['URI']['output']>;\n  /** The SAML provider's single sign-on URL. */\n  singleSignOnUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.enable_two_factor_requirement event. */\nexport type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Ordering options for an organization's enterprise owner connections. */\nexport type OrgEnterpriseOwnerOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise owners by. */\n  field: OrgEnterpriseOwnerOrderField;\n};\n\n/** Properties by which enterprise owners can be ordered. */\nexport enum OrgEnterpriseOwnerOrderField {\n  /** Order enterprise owners by login. */\n  Login = 'LOGIN'\n}\n\n/** Audit log entry for a org.invite_member event. */\nexport type OrgInviteMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The email address of the organization invitation. */\n  email?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The organization invitation. */\n  organizationInvitation?: Maybe<OrganizationInvitation>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.invite_to_business event. */\nexport type OrgInviteToBusinessAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_approved event. */\nexport type OrgOauthAppAccessApprovedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_blocked event. */\nexport type OrgOauthAppAccessBlockedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_denied event. */\nexport type OrgOauthAppAccessDeniedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_requested event. */\nexport type OrgOauthAppAccessRequestedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_unblocked event. */\nexport type OrgOauthAppAccessUnblockedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The name of the OAuth application. */\n  oauthApplicationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the OAuth application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the OAuth application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.remove_billing_manager event. */\nexport type OrgRemoveBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The reason for the billing manager being removed. */\n  reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The reason a billing manager was removed from an Organization. */\nexport enum OrgRemoveBillingManagerAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'\n}\n\n/** Audit log entry for a org.remove_member event. */\nexport type OrgRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The types of membership the member has with the organization. */\n  membershipTypes?: Maybe<Array<OrgRemoveMemberAuditEntryMembershipType>>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The reason for the member being removed. */\n  reason?: Maybe<OrgRemoveMemberAuditEntryReason>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveMemberAuditEntryMembershipType {\n  /**\n   * Organization administrators have full access and can change several settings,\n   * including the names of repositories that belong to the Organization and Owners\n   * team membership. In addition, organization admins can delete the organization\n   * and all of its repositories.\n   */\n  Admin = 'ADMIN',\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /** A direct member is a user that is a member of the Organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /** A suspended member. */\n  Suspended = 'SUSPENDED',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the Organization.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The reason a member was removed from an Organization. */\nexport enum OrgRemoveMemberAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** User was removed from organization during account recovery */\n  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',\n  /** User account has been deleted */\n  UserAccountDeleted = 'USER_ACCOUNT_DELETED'\n}\n\n/** Audit log entry for a org.remove_outside_collaborator event. */\nexport type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The types of membership the outside collaborator has with the organization. */\n  membershipTypes?: Maybe<Array<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The reason for the outside collaborator being removed from the Organization. */\n  reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the organization.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The reason an outside collaborator was removed from an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'\n}\n\n/** Audit log entry for a org.restore_member event. */\nexport type OrgRestoreMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The number of custom email routings for the restored member. */\n  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']['output']>;\n  /** The number of issue assignments for the restored member. */\n  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']['output']>;\n  /** Restored organization membership objects. */\n  restoredMemberships?: Maybe<Array<OrgRestoreMemberAuditEntryMembership>>;\n  /** The number of restored memberships. */\n  restoredMembershipsCount?: Maybe<Scalars['Int']['output']>;\n  /** The number of repositories of the restored member. */\n  restoredRepositoriesCount?: Maybe<Scalars['Int']['output']>;\n  /** The number of starred repositories for the restored member. */\n  restoredRepositoryStarsCount?: Maybe<Scalars['Int']['output']>;\n  /** The number of watched repositories for the restored member. */\n  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Types of memberships that can be restored for an Organization member. */\nexport type OrgRestoreMemberAuditEntryMembership = OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData;\n\n/** Metadata for an organization membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipOrganizationAuditEntryData = OrganizationAuditEntryData & {\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Metadata for a repository membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipRepositoryAuditEntryData = RepositoryAuditEntryData & {\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Metadata for a team membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipTeamAuditEntryData = TeamAuditEntryData & {\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.unblock_user */\nexport type OrgUnblockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user being unblocked by the organization. */\n  blockedUser?: Maybe<User>;\n  /** The username of the blocked user. */\n  blockedUserName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the blocked user. */\n  blockedUserResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the blocked user. */\n  blockedUserUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a org.update_default_repository_permission */\nexport type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The new base repository permission level for the organization. */\n  permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;\n  /** The former base repository permission level for the organization. */\n  permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The default permission a repository can have in an Organization. */\nexport enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** No default permission value. */\n  None = 'NONE',\n  /** Can read and clone repositories. */\n  Read = 'READ',\n  /** Can read, clone and push to repositories. */\n  Write = 'WRITE'\n}\n\n/** Audit log entry for a org.update_member event. */\nexport type OrgUpdateMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The new member permission level for the organization. */\n  permission?: Maybe<OrgUpdateMemberAuditEntryPermission>;\n  /** The former member permission level for the organization. */\n  permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The permissions available to members on an Organization. */\nexport enum OrgUpdateMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ'\n}\n\n/** Audit log entry for a org.update_member_repository_creation_permission event. */\nexport type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** Can members create repositories in the organization. */\n  canCreateRepositories?: Maybe<Scalars['Boolean']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The permission for visibility level of repositories for this organization. */\n  visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;\n};\n\n/** The permissions available for repository creation on an Organization. */\nexport enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {\n  /** All organization members are restricted from creating any repositories. */\n  All = 'ALL',\n  /** All organization members are restricted from creating internal repositories. */\n  Internal = 'INTERNAL',\n  /** All organization members are allowed to create any repositories. */\n  None = 'NONE',\n  /** All organization members are restricted from creating private repositories. */\n  Private = 'PRIVATE',\n  /** All organization members are restricted from creating private or internal repositories. */\n  PrivateInternal = 'PRIVATE_INTERNAL',\n  /** All organization members are restricted from creating public repositories. */\n  Public = 'PUBLIC',\n  /** All organization members are restricted from creating public or internal repositories. */\n  PublicInternal = 'PUBLIC_INTERNAL',\n  /** All organization members are restricted from creating public or private repositories. */\n  PublicPrivate = 'PUBLIC_PRIVATE'\n}\n\n/** Audit log entry for a org.update_member_repository_invitation_permission event. */\nexport type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** Can outside collaborators be invited to repositories in the organization. */\n  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type Organization = Actor & AnnouncementBanner & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {\n  /** The text of the announcement */\n  announcement?: Maybe<Scalars['String']['output']>;\n  /** The expiration date of the announcement, if any */\n  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Whether the announcement can be dismissed by the user */\n  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean']['output'];\n  /** Audit log entries of the organization */\n  auditLog: OrganizationAuditEntryConnection;\n  /** A URL pointing to the organization's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The organization's public profile description. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The organization's public profile description rendered to HTML. */\n  descriptionHTML?: Maybe<Scalars['String']['output']>;\n  /** A list of domains owned by the organization. */\n  domains?: Maybe<VerifiableDomainConnection>;\n  /** The organization's public email. */\n  email?: Maybe<Scalars['String']['output']>;\n  /** A list of owners of the organization's enterprise account. */\n  enterpriseOwners: OrganizationEnterpriseOwnerConnection;\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean']['output'];\n  id: Scalars['ID']['output'];\n  /** The interaction ability settings for this organization. */\n  interactionAbility?: Maybe<RepositoryInteractionAbility>;\n  /** The setting value for whether the organization has an IP allow list enabled. */\n  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;\n  /** The IP addresses that are allowed to access resources owned by the organization. */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */\n  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;\n  /** Whether the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean']['output'];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean']['output'];\n  /** Whether the organization has verified its profile email and website. */\n  isVerified: Scalars['Boolean']['output'];\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The organization's public profile location. */\n  location?: Maybe<Scalars['String']['output']>;\n  /** The organization's login name. */\n  login: Scalars['String']['output'];\n  /** A list of all mannequins for this organization. */\n  mannequins: MannequinConnection;\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n  /** Members can fork private repositories in this organization */\n  membersCanForkPrivateRepositories: Scalars['Boolean']['output'];\n  /** A list of users who are members of this organization. */\n  membersWithRole: OrganizationMemberConnection;\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];\n  /** The organization's public profile name. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path creating a new team */\n  newTeamResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL creating a new team */\n  newTeamUrl: Scalars['URI']['output'];\n  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */\n  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;\n  /** The billing email for the organization. */\n  organizationBillingEmail?: Maybe<Scalars['String']['output']>;\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n  /** A list of users who have been invited to join this organization. */\n  pendingMembers: UserConnection;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int']['output'];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing organization's projects */\n  projectsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL listing organization's projects */\n  projectsUrl: Scalars['URI']['output'];\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n  /** A list of all repository migrations for this organization. */\n  repositoryMigrations: RepositoryMigrationConnection;\n  /**\n   * When true the organization requires all members, billing managers, and outside\n   * collaborators to enable two-factor authentication.\n   */\n  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']['output']>;\n  /** The HTTP path for this organization. */\n  resourcePath: Scalars['URI']['output'];\n  /** Returns a single ruleset from the current organization by ID. */\n  ruleset?: Maybe<RepositoryRuleset>;\n  /** A list of rulesets for this organization. */\n  rulesets?: Maybe<RepositoryRulesetConnection>;\n  /**\n   * The Organization's SAML identity provider. Visible to (1) organization owners,\n   * (2) organization owners' personal access tokens (classic) with read:org or\n   * admin:org scope, (3) GitHub App with an installation token with read or write\n   * access to members.\n   */\n  samlIdentityProvider?: Maybe<OrganizationIdentityProvider>;\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** The sponsorships where this user or organization is the maintainer receiving the funds. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** The sponsorships where this user or organization is the funder. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /** Find an organization's team by its slug. */\n  team?: Maybe<Team>;\n  /** A list of teams in this organization. */\n  teams: TeamConnection;\n  /** The HTTP path listing organization's teams */\n  teamsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL listing organization's teams */\n  teamsUrl: Scalars['URI']['output'];\n  /**\n   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has\n   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the\n   * user themselves or by a user who can manage sponsorships for the requested organization.\n   */\n  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;\n  /** The organization's Twitter username. */\n  twitterUsername?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this organization. */\n  url: Scalars['URI']['output'];\n  /** Organization is adminable by the viewer. */\n  viewerCanAdminister: Scalars['Boolean']['output'];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean']['output'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean']['output'];\n  /** Viewer can create repositories on this organization */\n  viewerCanCreateRepositories: Scalars['Boolean']['output'];\n  /** Viewer can create teams on this organization. */\n  viewerCanCreateTeams: Scalars['Boolean']['output'];\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean']['output'];\n  /** Viewer is an active member of this organization. */\n  viewerIsAMember: Scalars['Boolean']['output'];\n  /** Whether or not this Organization is followed by the viewer. */\n  viewerIsFollowing: Scalars['Boolean']['output'];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean']['output'];\n  /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */\n  webCommitSignoffRequired: Scalars['Boolean']['output'];\n  /** The organization's public profile URL. */\n  websiteUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAuditLogArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<AuditLogOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationDomainsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isApproved?: InputMaybe<Scalars['Boolean']['input']>;\n  isVerified?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<VerifiableDomainOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationEnterpriseOwnersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrgEnterpriseOwnerOrder>;\n  organizationRole?: InputMaybe<RoleInOrganization>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIsSponsoredByArgs = {\n  accountLogin: Scalars['String']['input'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMannequinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<MannequinOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMemberStatusesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMembersWithRoleArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPackagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPendingMembersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnableItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnedItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']['input']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isArchived?: InputMaybe<Scalars['Boolean']['input']>;\n  isFork?: InputMaybe<Scalars['Boolean']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']['input']>;\n  name: Scalars['String']['input'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  answered?: InputMaybe<Scalars['Boolean']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryMigrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryMigrationOrder>;\n  repositoryName?: InputMaybe<Scalars['String']['input']>;\n  state?: InputMaybe<MigrationState>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRulesetArgs = {\n  databaseId: Scalars['Int']['input'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRulesetsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeParents?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsoringArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsActivitiesArgs = {\n  actions?: InputMaybe<Array<SponsorsActivityAction>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  until?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipForViewerAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipForViewerAsSponsorableArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsMaintainerArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamArgs = {\n  slug: Scalars['String']['input'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  ldapMapped?: InputMaybe<Scalars['Boolean']['input']>;\n  notificationSetting?: InputMaybe<TeamNotificationSetting>;\n  orderBy?: InputMaybe<TeamOrder>;\n  privacy?: InputMaybe<TeamPrivacy>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<TeamRole>;\n  rootTeamsOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  userLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTotalSponsorshipAmountAsSponsorInCentsArgs = {\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  until?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n/** An audit entry in an organization audit log. */\nexport type OrganizationAuditEntry = MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry;\n\n/** The connection type for OrganizationAuditEntry. */\nexport type OrganizationAuditEntryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationAuditEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationAuditEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Metadata for an audit entry with action org.* */\nexport type OrganizationAuditEntryData = {\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** An edge in a connection. */\nexport type OrganizationAuditEntryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationAuditEntry>;\n};\n\n/** A list of organizations managed by an enterprise. */\nexport type OrganizationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type OrganizationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>;\n};\n\n/** The connection type for User. */\nexport type OrganizationEnterpriseOwnerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEnterpriseOwnerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An enterprise owner in the context of an organization that is part of the enterprise. */\nexport type OrganizationEnterpriseOwnerEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role of the owner with respect to the organization. */\n  organizationRole: RoleInOrganization;\n};\n\n/**\n * An Identity Provider configured to provision SAML and SCIM identities for\n * Organizations. Visible to (1) organization owners, (2) organization owners'\n * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub\n * App with an installation token with read or write access to members.\n */\nexport type OrganizationIdentityProvider = Node & {\n  /** The digest algorithm used to sign SAML requests for the Identity Provider. */\n  digestMethod?: Maybe<Scalars['URI']['output']>;\n  /** External Identities provisioned by this Identity Provider */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars['ID']['output'];\n  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars['X509Certificate']['output']>;\n  /** The Issuer Entity ID for the SAML Identity Provider */\n  issuer?: Maybe<Scalars['String']['output']>;\n  /** Organization this Identity Provider belongs to */\n  organization?: Maybe<Organization>;\n  /** The signature algorithm used to sign SAML requests for the Identity Provider. */\n  signatureMethod?: Maybe<Scalars['URI']['output']>;\n  /** The URL endpoint for the Identity Provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/**\n * An Identity Provider configured to provision SAML and SCIM identities for\n * Organizations. Visible to (1) organization owners, (2) organization owners'\n * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub\n * App with an installation token with read or write access to members.\n */\nexport type OrganizationIdentityProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  login?: InputMaybe<Scalars['String']['input']>;\n  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  userName?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** An Invitation for a user to an organization. */\nexport type OrganizationInvitation = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The email address of the user invited to the organization. */\n  email?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The source of the invitation. */\n  invitationSource: OrganizationInvitationSource;\n  /** The type of invitation that was sent (e.g. email, user). */\n  invitationType: OrganizationInvitationType;\n  /** The user who was invited to the organization. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter: User;\n  /** The organization the invite is for */\n  organization: Organization;\n  /** The user's pending role in the organization (e.g. member, owner). */\n  role: OrganizationInvitationRole;\n};\n\n/** The connection type for OrganizationInvitation. */\nexport type OrganizationInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type OrganizationInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/** The possible organization invitation roles. */\nexport enum OrganizationInvitationRole {\n  /** The user is invited to be an admin of the organization. */\n  Admin = 'ADMIN',\n  /** The user is invited to be a billing manager of the organization. */\n  BillingManager = 'BILLING_MANAGER',\n  /** The user is invited to be a direct member of the organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /** The user's previous role will be reinstated. */\n  Reinstate = 'REINSTATE'\n}\n\n/** The possible organization invitation sources. */\nexport enum OrganizationInvitationSource {\n  /** The invitation was created from the web interface or from API */\n  Member = 'MEMBER',\n  /** The invitation was created from SCIM */\n  Scim = 'SCIM',\n  /** The invitation was sent before this feature was added */\n  Unknown = 'UNKNOWN'\n}\n\n/** The possible organization invitation types. */\nexport enum OrganizationInvitationType {\n  /** The invitation was to an email address. */\n  Email = 'EMAIL',\n  /** The invitation was to an existing user. */\n  User = 'USER'\n}\n\n/** The connection type for User. */\nexport type OrganizationMemberConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a user within an organization. */\nexport type OrganizationMemberEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */\n  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']['output']>;\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role this user has in the organization. */\n  role?: Maybe<OrganizationMemberRole>;\n};\n\n/** The possible roles within an organization for its members. */\nexport enum OrganizationMemberRole {\n  /** The user is an administrator of the organization. */\n  Admin = 'ADMIN',\n  /** The user is a member of the organization. */\n  Member = 'MEMBER'\n}\n\n/** The possible values for the members can create repositories setting on an organization. */\nexport enum OrganizationMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Members will be able to create only internal repositories. */\n  Internal = 'INTERNAL',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE'\n}\n\n/** A GitHub Enterprise Importer (GEI) organization migration. */\nexport type OrganizationMigration = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['String']['output']>;\n  /** The reason the organization migration failed. */\n  failureReason?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The remaining amount of repos to be migrated. */\n  remainingRepositoriesCount?: Maybe<Scalars['Int']['output']>;\n  /** The name of the source organization to be migrated. */\n  sourceOrgName: Scalars['String']['output'];\n  /** The URL of the source organization to migrate. */\n  sourceOrgUrl: Scalars['URI']['output'];\n  /** The migration state. */\n  state: OrganizationMigrationState;\n  /** The name of the target organization. */\n  targetOrgName: Scalars['String']['output'];\n  /** The total amount of repositories to be migrated. */\n  totalRepositoriesCount?: Maybe<Scalars['Int']['output']>;\n};\n\n/** The Octoshift Organization migration state. */\nexport enum OrganizationMigrationState {\n  /** The Octoshift migration has failed. */\n  Failed = 'FAILED',\n  /** The Octoshift migration has invalid credentials. */\n  FailedValidation = 'FAILED_VALIDATION',\n  /** The Octoshift migration is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The Octoshift migration has not started. */\n  NotStarted = 'NOT_STARTED',\n  /** The Octoshift migration needs to have its credentials validated. */\n  PendingValidation = 'PENDING_VALIDATION',\n  /** The Octoshift migration is performing post repository migrations. */\n  PostRepoMigration = 'POST_REPO_MIGRATION',\n  /** The Octoshift migration is performing pre repository migrations. */\n  PreRepoMigration = 'PRE_REPO_MIGRATION',\n  /** The Octoshift migration has been queued. */\n  Queued = 'QUEUED',\n  /** The Octoshift org migration is performing repository migrations. */\n  RepoMigration = 'REPO_MIGRATION',\n  /** The Octoshift migration has succeeded. */\n  Succeeded = 'SUCCEEDED'\n}\n\n/** Used for argument of CreateProjectV2 mutation. */\nexport type OrganizationOrUser = Organization | User;\n\n/** Ordering options for organization connections. */\nexport type OrganizationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order organizations by. */\n  field: OrganizationOrderField;\n};\n\n/** Properties by which organization connections can be ordered. */\nexport enum OrganizationOrderField {\n  /** Order organizations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order organizations by login */\n  Login = 'LOGIN'\n}\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']['output'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']['output'];\n  /** Teams in this organization the user is a member of that are relevant */\n  relevantTeams: TeamConnection;\n  /** The path for the full team list for this user */\n  teamsResourcePath: Scalars['URI']['output'];\n  /** The URL for the full team list for this user */\n  teamsUrl: Scalars['URI']['output'];\n  /** The total number of teams the user is on in the organization */\n  totalTeamCount: Scalars['Int']['output'];\n};\n\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContextRelevantTeamsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']['output'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']['output'];\n  /** Organizations this user is a member of that are relevant */\n  relevantOrganizations: OrganizationConnection;\n  /** The total number of organizations this user is in */\n  totalOrganizationCount: Scalars['Int']['output'];\n};\n\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContextRelevantOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n};\n\n/** Information for an uploaded package. */\nexport type Package = Node & {\n  id: Scalars['ID']['output'];\n  /** Find the latest version for the package. */\n  latestVersion?: Maybe<PackageVersion>;\n  /** Identifies the name of the package. */\n  name: Scalars['String']['output'];\n  /** Identifies the type of the package. */\n  packageType: PackageType;\n  /** The repository this package belongs to. */\n  repository?: Maybe<Repository>;\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageStatistics>;\n  /** Find package version by version string. */\n  version?: Maybe<PackageVersion>;\n  /** list of versions for this package */\n  versions: PackageVersionConnection;\n};\n\n\n/** Information for an uploaded package. */\nexport type PackageVersionArgs = {\n  version: Scalars['String']['input'];\n};\n\n\n/** Information for an uploaded package. */\nexport type PackageVersionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<PackageVersionOrder>;\n};\n\n/** The connection type for Package. */\nexport type PackageConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Package>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PackageEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Package>;\n};\n\n/** A file in a package version. */\nexport type PackageFile = Node & {\n  id: Scalars['ID']['output'];\n  /** MD5 hash of the file. */\n  md5?: Maybe<Scalars['String']['output']>;\n  /** Name of the file. */\n  name: Scalars['String']['output'];\n  /** The package version this file belongs to. */\n  packageVersion?: Maybe<PackageVersion>;\n  /** SHA1 hash of the file. */\n  sha1?: Maybe<Scalars['String']['output']>;\n  /** SHA256 hash of the file. */\n  sha256?: Maybe<Scalars['String']['output']>;\n  /** Size of the file in bytes. */\n  size?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** URL to download the asset. */\n  url?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The connection type for PackageFile. */\nexport type PackageFileConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageFile>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PackageFileEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageFile>;\n};\n\n/** Ways in which lists of package files can be ordered upon return. */\nexport type PackageFileOrder = {\n  /** The direction in which to order package files by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order package files by. */\n  field?: InputMaybe<PackageFileOrderField>;\n};\n\n/** Properties by which package file connections can be ordered. */\nexport enum PackageFileOrderField {\n  /** Order package files by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Ways in which lists of packages can be ordered upon return. */\nexport type PackageOrder = {\n  /** The direction in which to order packages by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order packages by. */\n  field?: InputMaybe<PackageOrderField>;\n};\n\n/** Properties by which package connections can be ordered. */\nexport enum PackageOrderField {\n  /** Order packages by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Represents an owner of a package. */\nexport type PackageOwner = {\n  id: Scalars['ID']['output'];\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n};\n\n\n/** Represents an owner of a package. */\nexport type PackageOwnerPackagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Represents a object that contains package activity statistics such as downloads. */\nexport type PackageStatistics = {\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars['Int']['output'];\n};\n\n/** A version tag contains the mapping between a tag name and a version. */\nexport type PackageTag = Node & {\n  id: Scalars['ID']['output'];\n  /** Identifies the tag name of the version. */\n  name: Scalars['String']['output'];\n  /** Version that the tag is associated with. */\n  version?: Maybe<PackageVersion>;\n};\n\n/** The possible types of a package. */\nexport enum PackageType {\n  /** A debian package. */\n  Debian = 'DEBIAN',\n  /**\n   * A docker image.\n   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.\n   */\n  Docker = 'DOCKER',\n  /**\n   * A maven package.\n   * @deprecated MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC.\n   */\n  Maven = 'MAVEN',\n  /**\n   * An npm package.\n   * @deprecated NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.\n   */\n  Npm = 'NPM',\n  /**\n   * A nuget package.\n   * @deprecated NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.\n   */\n  Nuget = 'NUGET',\n  /** A python package. */\n  Pypi = 'PYPI',\n  /**\n   * A rubygems package.\n   * @deprecated RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC.\n   */\n  Rubygems = 'RUBYGEMS'\n}\n\n/** Information about a specific package version. */\nexport type PackageVersion = Node & {\n  /** List of files associated with this package version */\n  files: PackageFileConnection;\n  id: Scalars['ID']['output'];\n  /** The package associated with this version. */\n  package?: Maybe<Package>;\n  /** The platform this version was built for. */\n  platform?: Maybe<Scalars['String']['output']>;\n  /** Whether or not this version is a pre-release. */\n  preRelease: Scalars['Boolean']['output'];\n  /** The README of this package version. */\n  readme?: Maybe<Scalars['String']['output']>;\n  /** The release associated with this package version. */\n  release?: Maybe<Release>;\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageVersionStatistics>;\n  /** The package version summary. */\n  summary?: Maybe<Scalars['String']['output']>;\n  /** The version string. */\n  version: Scalars['String']['output'];\n};\n\n\n/** Information about a specific package version. */\nexport type PackageVersionFilesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<PackageFileOrder>;\n};\n\n/** The connection type for PackageVersion. */\nexport type PackageVersionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageVersionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageVersion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PackageVersionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageVersion>;\n};\n\n/** Ways in which lists of package versions can be ordered upon return. */\nexport type PackageVersionOrder = {\n  /** The direction in which to order package versions by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order package versions by. */\n  field?: InputMaybe<PackageVersionOrderField>;\n};\n\n/** Properties by which package version connections can be ordered. */\nexport enum PackageVersionOrderField {\n  /** Order package versions by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Represents a object that contains package version activity statistics such as downloads. */\nexport type PackageVersionStatistics = {\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars['Int']['output'];\n};\n\n/** Information about pagination in a connection. */\nexport type PageInfo = {\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']['output']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean']['output'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean']['output'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']['output']>;\n};\n\n/** The possible types of patch statuses. */\nexport enum PatchStatus {\n  /** The file was added. Git status 'A'. */\n  Added = 'ADDED',\n  /** The file's type was changed. Git status 'T'. */\n  Changed = 'CHANGED',\n  /** The file was copied. Git status 'C'. */\n  Copied = 'COPIED',\n  /** The file was deleted. Git status 'D'. */\n  Deleted = 'DELETED',\n  /** The file's contents were changed. Git status 'M'. */\n  Modified = 'MODIFIED',\n  /** The file was renamed. Git status 'R'. */\n  Renamed = 'RENAMED'\n}\n\n/** Types that can grant permissions on a repository to a user */\nexport type PermissionGranter = Organization | Repository | Team;\n\n/** A level of permission and source for a user's access to a repository. */\nexport type PermissionSource = {\n  /** The organization the repository belongs to. */\n  organization: Organization;\n  /** The level of access this source has granted to the user. */\n  permission: DefaultRepositoryPermissionField;\n  /** The source of this permission. */\n  source: PermissionGranter;\n};\n\n/** Autogenerated input type of PinIssue */\nexport type PinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the issue to be pinned */\n  issueId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of PinIssue */\nexport type PinIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue that was pinned */\n  issue?: Maybe<Issue>;\n};\n\n/** Types that can be pinned to a profile page. */\nexport type PinnableItem = Gist | Repository;\n\n/** The connection type for PinnableItem. */\nexport type PinnableItemConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnableItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnableItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PinnableItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnableItem>;\n};\n\n/** Represents items that can be pinned to a profile page or dashboard. */\nexport enum PinnableItemType {\n  /** A gist. */\n  Gist = 'GIST',\n  /** An issue. */\n  Issue = 'ISSUE',\n  /** An organization. */\n  Organization = 'ORGANIZATION',\n  /** A project. */\n  Project = 'PROJECT',\n  /** A pull request. */\n  PullRequest = 'PULL_REQUEST',\n  /** A repository. */\n  Repository = 'REPOSITORY',\n  /** A team. */\n  Team = 'TEAM',\n  /** A user. */\n  User = 'USER'\n}\n\n/** A Pinned Discussion is a discussion pinned to a repository's index page. */\nexport type PinnedDiscussion = Node & RepositoryNode & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The discussion that was pinned. */\n  discussion: Discussion;\n  /** Color stops of the chosen gradient */\n  gradientStopColors: Array<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** Background texture pattern */\n  pattern: PinnedDiscussionPattern;\n  /** The actor that pinned this discussion. */\n  pinnedBy: Actor;\n  /** Preconfigured background gradient option */\n  preconfiguredGradient?: Maybe<PinnedDiscussionGradient>;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for PinnedDiscussion. */\nexport type PinnedDiscussionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedDiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedDiscussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PinnedDiscussionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedDiscussion>;\n};\n\n/** Preconfigured gradients that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionGradient {\n  /** A gradient of blue to mint */\n  BlueMint = 'BLUE_MINT',\n  /** A gradient of blue to purple */\n  BluePurple = 'BLUE_PURPLE',\n  /** A gradient of pink to blue */\n  PinkBlue = 'PINK_BLUE',\n  /** A gradient of purple to coral */\n  PurpleCoral = 'PURPLE_CORAL',\n  /** A gradient of red to orange */\n  RedOrange = 'RED_ORANGE'\n}\n\n/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionPattern {\n  /** An upward-facing chevron pattern */\n  ChevronUp = 'CHEVRON_UP',\n  /** A hollow dot pattern */\n  Dot = 'DOT',\n  /** A solid dot pattern */\n  DotFill = 'DOT_FILL',\n  /** A heart pattern */\n  HeartFill = 'HEART_FILL',\n  /** A plus sign pattern */\n  Plus = 'PLUS',\n  /** A lightning bolt pattern */\n  Zap = 'ZAP'\n}\n\n/** Represents a 'pinned' event on a given issue or pull request. */\nexport type PinnedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** A Pinned Issue is a issue pinned to a repository's index page. */\nexport type PinnedIssue = Node & {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the primary key from the database as a BigInt. */\n  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;\n  id: Scalars['ID']['output'];\n  /** The issue that was pinned. */\n  issue: Issue;\n  /** The actor that pinned this issue. */\n  pinnedBy: Actor;\n  /** The repository that this issue was pinned to. */\n  repository: Repository;\n};\n\n/** The connection type for PinnedIssue. */\nexport type PinnedIssueConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedIssueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedIssue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PinnedIssueEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedIssue>;\n};\n\n/** Audit log entry for a private_repository_forking.disable event. */\nexport type PrivateRepositoryForkingDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a private_repository_forking.enable event. */\nexport type PrivateRepositoryForkingEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcase = {\n  /** Whether or not the owner has pinned any repositories or gists. */\n  hasPinnedItems: Scalars['Boolean']['output'];\n  /**\n   * The repositories and gists in the showcase. If the profile owner has any\n   * pinned items, those will be returned. Otherwise, the profile owner's popular\n   * repositories will be returned.\n   */\n  items: PinnableItemConnection;\n};\n\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcaseItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwner = {\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean']['output'];\n  /** The public profile email. */\n  email?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The public profile location. */\n  location?: Maybe<Scalars['String']['output']>;\n  /** The username used to login. */\n  login: Scalars['String']['output'];\n  /** The public profile name. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int']['output'];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean']['output'];\n  /** The public profile website URL. */\n  websiteUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnableItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnedItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type Project = Closable & Node & Updatable & {\n  /** The project's description body. */\n  body?: Maybe<Scalars['String']['output']>;\n  /** The projects description body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** List of columns in the project */\n  columns: ProjectColumnConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who originally created the project. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The project's name. */\n  name: Scalars['String']['output'];\n  /** The project's number. */\n  number: Scalars['Int']['output'];\n  /** The project's owner. Currently limited to repositories, organizations, and users. */\n  owner: ProjectOwner;\n  /** List of pending cards in this project */\n  pendingCards: ProjectCardConnection;\n  /** Project progress details. */\n  progress: ProjectProgress;\n  /** The HTTP path for this project */\n  resourcePath: Scalars['URI']['output'];\n  /** Whether the project is open or closed. */\n  state: ProjectState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this project */\n  url: Scalars['URI']['output'];\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n};\n\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectColumnsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectPendingCardsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A card in a project. */\nexport type ProjectCard = Node & {\n  /**\n   * The project column this card is associated under. A card may only belong to one\n   * project column at a time. The column field will be null if the card is created\n   * in a pending state and has yet to be associated with a column. Once cards are\n   * associated with a column, they will not become pending in the future.\n   */\n  column?: Maybe<ProjectColumn>;\n  /** The card content item */\n  content?: Maybe<ProjectCardItem>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created this card */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** Whether the card is archived */\n  isArchived: Scalars['Boolean']['output'];\n  /** The card note */\n  note?: Maybe<Scalars['String']['output']>;\n  /** The project that contains this card. */\n  project: Project;\n  /** The HTTP path for this card */\n  resourcePath: Scalars['URI']['output'];\n  /** The state of ProjectCard */\n  state?: Maybe<ProjectCardState>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this card */\n  url: Scalars['URI']['output'];\n};\n\n/** The possible archived states of a project card. */\nexport enum ProjectCardArchivedState {\n  /** A project card that is archived */\n  Archived = 'ARCHIVED',\n  /** A project card that is not archived */\n  NotArchived = 'NOT_ARCHIVED'\n}\n\n/** The connection type for ProjectCard. */\nexport type ProjectCardConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectCardEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectCard>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectCardEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectCard>;\n};\n\n/** Types that can be inside Project Cards. */\nexport type ProjectCardItem = Issue | PullRequest;\n\n/** Various content states of a ProjectCard */\nexport enum ProjectCardState {\n  /** The card has content only. */\n  ContentOnly = 'CONTENT_ONLY',\n  /** The card has a note only. */\n  NoteOnly = 'NOTE_ONLY',\n  /** The card is redacted. */\n  Redacted = 'REDACTED'\n}\n\n/** A column inside a project. */\nexport type ProjectColumn = Node & {\n  /** List of cards in the column */\n  cards: ProjectCardConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The project column's name. */\n  name: Scalars['String']['output'];\n  /** The project that contains this column. */\n  project: Project;\n  /** The semantic purpose of the column */\n  purpose?: Maybe<ProjectColumnPurpose>;\n  /** The HTTP path for this project column */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this project column */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A column inside a project. */\nexport type ProjectColumnCardsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for ProjectColumn. */\nexport type ProjectColumnConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectColumnEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectColumn>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectColumnEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectColumn>;\n};\n\n/** The semantic purpose of the column - todo, in progress, or done. */\nexport enum ProjectColumnPurpose {\n  /** The column contains cards which are complete */\n  Done = 'DONE',\n  /** The column contains cards which are currently being worked on */\n  InProgress = 'IN_PROGRESS',\n  /** The column contains cards still to be worked on */\n  Todo = 'TODO'\n}\n\n/** A list of projects associated with the owner. */\nexport type ProjectConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Project>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Project>;\n};\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectOrder = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order projects by. */\n  field: ProjectOrderField;\n};\n\n/** Properties by which project connections can be ordered. */\nexport enum ProjectOrderField {\n  /** Order projects by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order projects by name */\n  Name = 'NAME',\n  /** Order projects by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectOwner = {\n  id: Scalars['ID']['output'];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing owners projects */\n  projectsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL listing owners projects */\n  projectsUrl: Scalars['URI']['output'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean']['output'];\n};\n\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']['input']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n/** Project progress stats. */\nexport type ProjectProgress = {\n  /** The number of done cards. */\n  doneCount: Scalars['Int']['output'];\n  /** The percentage of done cards. */\n  donePercentage: Scalars['Float']['output'];\n  /** Whether progress tracking is enabled and cards with purpose exist for this project */\n  enabled: Scalars['Boolean']['output'];\n  /** The number of in-progress cards. */\n  inProgressCount: Scalars['Int']['output'];\n  /** The percentage of in-progress cards. */\n  inProgressPercentage: Scalars['Float']['output'];\n  /** The number of to do cards. */\n  todoCount: Scalars['Int']['output'];\n  /** The percentage of to do cards. */\n  todoPercentage: Scalars['Float']['output'];\n};\n\n/** State of the project; either 'open' or 'closed' */\nexport enum ProjectState {\n  /** The project is closed. */\n  Closed = 'CLOSED',\n  /** The project is open. */\n  Open = 'OPEN'\n}\n\n/** GitHub-provided templates for Projects */\nexport enum ProjectTemplate {\n  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */\n  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',\n  /** Create a board with triggers to automatically move cards across columns with review automation. */\n  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',\n  /** Create a board with columns for To do, In progress and Done. */\n  BasicKanban = 'BASIC_KANBAN',\n  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */\n  BugTriage = 'BUG_TRIAGE'\n}\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2 = Closable & Node & Updatable & {\n  /** Returns true if the project is closed. */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who originally created the project. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** A field of the project */\n  field?: Maybe<ProjectV2FieldConfiguration>;\n  /** List of fields and their constraints in the project */\n  fields: ProjectV2FieldConfigurationConnection;\n  id: Scalars['ID']['output'];\n  /** List of items in the project */\n  items: ProjectV2ItemConnection;\n  /** The project's number. */\n  number: Scalars['Int']['output'];\n  /** The project's owner. Currently limited to organizations and users. */\n  owner: ProjectV2Owner;\n  /** Returns true if the project is public. */\n  public: Scalars['Boolean']['output'];\n  /** The project's readme. */\n  readme?: Maybe<Scalars['String']['output']>;\n  /** The repositories the project is linked to. */\n  repositories: RepositoryConnection;\n  /** The HTTP path for this project */\n  resourcePath: Scalars['URI']['output'];\n  /** The project's short description. */\n  shortDescription?: Maybe<Scalars['String']['output']>;\n  /** The teams the project is linked to. */\n  teams: TeamConnection;\n  /** Returns true if this project is a template. */\n  template: Scalars['Boolean']['output'];\n  /** The project's name. */\n  title: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this project */\n  url: Scalars['URI']['output'];\n  /** A view of the project */\n  view?: Maybe<ProjectV2View>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** List of views in the project */\n  views: ProjectV2ViewConnection;\n  /** A workflow of the project */\n  workflow?: Maybe<ProjectV2Workflow>;\n  /** List of the workflows in the project */\n  workflows: ProjectV2WorkflowConnection;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2FieldArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2FieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2ItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2ItemOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2RepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2TeamsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<TeamOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2ViewArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2ViewsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2ViewOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2WorkflowArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2WorkflowsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2WorkflowOrder>;\n};\n\n/** Possible collaborators for a project. */\nexport type ProjectV2Actor = Team | User;\n\n/** The connection type for ProjectV2Actor. */\nexport type ProjectV2ActorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Actor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2ActorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Actor>;\n};\n\n/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */\nexport type ProjectV2Collaborator = {\n  /** The role to grant the collaborator */\n  role: ProjectV2Roles;\n  /** The ID of the team as a collaborator. */\n  teamId?: InputMaybe<Scalars['ID']['input']>;\n  /** The ID of the user as a collaborator. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** The connection type for ProjectV2. */\nexport type ProjectV2Connection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2Edge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** The type of a project field. */\nexport enum ProjectV2CustomFieldType {\n  /** Date */\n  Date = 'DATE',\n  /** Number */\n  Number = 'NUMBER',\n  /** Single Select */\n  SingleSelect = 'SINGLE_SELECT',\n  /** Text */\n  Text = 'TEXT'\n}\n\n/** An edge in a connection. */\nexport type ProjectV2Edge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2>;\n};\n\n/** A field inside a project. */\nexport type ProjectV2Field = Node & ProjectV2FieldCommon & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The project field's name. */\n  name: Scalars['String']['output'];\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** Common fields across different project field types */\nexport type ProjectV2FieldCommon = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The project field's name. */\n  name: Scalars['String']['output'];\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** Configurations for project fields. */\nexport type ProjectV2FieldConfiguration = ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField;\n\n/** The connection type for ProjectV2FieldConfiguration. */\nexport type ProjectV2FieldConfigurationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2FieldConfigurationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2FieldConfiguration>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2FieldConfigurationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2FieldConfiguration>;\n};\n\n/** The connection type for ProjectV2Field. */\nexport type ProjectV2FieldConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2FieldEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Field>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2FieldEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Field>;\n};\n\n/** Ordering options for project v2 field connections */\nexport type ProjectV2FieldOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 fields by. */\n  field: ProjectV2FieldOrderField;\n};\n\n/** Properties by which project v2 field connections can be ordered. */\nexport enum ProjectV2FieldOrderField {\n  /** Order project v2 fields by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order project v2 fields by name */\n  Name = 'NAME',\n  /** Order project v2 fields by position */\n  Position = 'POSITION'\n}\n\n/** The type of a project field. */\nexport enum ProjectV2FieldType {\n  /** Assignees */\n  Assignees = 'ASSIGNEES',\n  /** Date */\n  Date = 'DATE',\n  /** Iteration */\n  Iteration = 'ITERATION',\n  /** Labels */\n  Labels = 'LABELS',\n  /** Linked Pull Requests */\n  LinkedPullRequests = 'LINKED_PULL_REQUESTS',\n  /** Milestone */\n  Milestone = 'MILESTONE',\n  /** Number */\n  Number = 'NUMBER',\n  /** Repository */\n  Repository = 'REPOSITORY',\n  /** Reviewers */\n  Reviewers = 'REVIEWERS',\n  /** Single Select */\n  SingleSelect = 'SINGLE_SELECT',\n  /** Text */\n  Text = 'TEXT',\n  /** Title */\n  Title = 'TITLE',\n  /** Tracked by */\n  TrackedBy = 'TRACKED_BY',\n  /** Tracks */\n  Tracks = 'TRACKS'\n}\n\n/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */\nexport type ProjectV2FieldValue = {\n  /** The ISO 8601 date to set on the field. */\n  date?: InputMaybe<Scalars['Date']['input']>;\n  /** The id of the iteration to set on the field. */\n  iterationId?: InputMaybe<Scalars['String']['input']>;\n  /** The number to set on the field. */\n  number?: InputMaybe<Scalars['Float']['input']>;\n  /** The id of the single select option to set on the field. */\n  singleSelectOptionId?: InputMaybe<Scalars['String']['input']>;\n  /** The text to set on the field. */\n  text?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Ways in which to filter lists of projects. */\nexport type ProjectV2Filters = {\n  /** List project v2 filtered by the state given. */\n  state?: InputMaybe<ProjectV2State>;\n};\n\n/** An item within a Project. */\nexport type ProjectV2Item = Node & {\n  /** The content of the referenced draft issue, issue, or pull request */\n  content?: Maybe<ProjectV2ItemContent>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The field value of the first project field which matches the 'name' argument that is set on the item. */\n  fieldValueByName?: Maybe<ProjectV2ItemFieldValue>;\n  /** The field values that are set on the item. */\n  fieldValues: ProjectV2ItemFieldValueConnection;\n  id: Scalars['ID']['output'];\n  /** Whether the item is archived. */\n  isArchived: Scalars['Boolean']['output'];\n  /** The project that contains this item. */\n  project: ProjectV2;\n  /** The type of the item. */\n  type: ProjectV2ItemType;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n\n/** An item within a Project. */\nexport type ProjectV2ItemFieldValueByNameArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/** An item within a Project. */\nexport type ProjectV2ItemFieldValuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2ItemFieldValueOrder>;\n};\n\n/** The connection type for ProjectV2Item. */\nexport type ProjectV2ItemConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Item>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Types that can be inside Project Items. */\nexport type ProjectV2ItemContent = DraftIssue | Issue | PullRequest;\n\n/** An edge in a connection. */\nexport type ProjectV2ItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Item>;\n};\n\n/** The value of a date field in a Project item. */\nexport type ProjectV2ItemFieldDateValue = Node & ProjectV2ItemFieldValueCommon & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** Date value for the field */\n  date?: Maybe<Scalars['Date']['output']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID']['output'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The value of an iteration field in a Project item. */\nexport type ProjectV2ItemFieldIterationValue = Node & ProjectV2ItemFieldValueCommon & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The duration of the iteration in days. */\n  duration: Scalars['Int']['output'];\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID']['output'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** The ID of the iteration. */\n  iterationId: Scalars['String']['output'];\n  /** The start date of the iteration. */\n  startDate: Scalars['Date']['output'];\n  /** The title of the iteration. */\n  title: Scalars['String']['output'];\n  /** The title of the iteration, with HTML. */\n  titleHTML: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The value of the labels field in a Project item. */\nexport type ProjectV2ItemFieldLabelValue = {\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** Labels value of a field */\n  labels?: Maybe<LabelConnection>;\n};\n\n\n/** The value of the labels field in a Project item. */\nexport type ProjectV2ItemFieldLabelValueLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The value of a milestone field in a Project item. */\nexport type ProjectV2ItemFieldMilestoneValue = {\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** Milestone value of a field */\n  milestone?: Maybe<Milestone>;\n};\n\n/** The value of a number field in a Project item. */\nexport type ProjectV2ItemFieldNumberValue = Node & ProjectV2ItemFieldValueCommon & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID']['output'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Number as a float(8) */\n  number?: Maybe<Scalars['Float']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The value of a pull request field in a Project item. */\nexport type ProjectV2ItemFieldPullRequestValue = {\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The pull requests for this field */\n  pullRequests?: Maybe<PullRequestConnection>;\n};\n\n\n/** The value of a pull request field in a Project item. */\nexport type ProjectV2ItemFieldPullRequestValuePullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<PullRequestOrder>;\n};\n\n/** The value of a repository field in a Project item. */\nexport type ProjectV2ItemFieldRepositoryValue = {\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The repository for this field. */\n  repository?: Maybe<Repository>;\n};\n\n/** The value of a reviewers field in a Project item. */\nexport type ProjectV2ItemFieldReviewerValue = {\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The reviewers for this field. */\n  reviewers?: Maybe<RequestedReviewerConnection>;\n};\n\n\n/** The value of a reviewers field in a Project item. */\nexport type ProjectV2ItemFieldReviewerValueReviewersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The value of a single select field in a Project item. */\nexport type ProjectV2ItemFieldSingleSelectValue = Node & ProjectV2ItemFieldValueCommon & {\n  /** The color applied to the selected single-select option. */\n  color: ProjectV2SingleSelectFieldOptionColor;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** A plain-text description of the selected single-select option, such as what the option means. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The description of the selected single-select option, including HTML tags. */\n  descriptionHTML?: Maybe<Scalars['String']['output']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID']['output'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** The name of the selected single select option. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** The html name of the selected single select option. */\n  nameHTML?: Maybe<Scalars['String']['output']>;\n  /** The id of the selected single select option. */\n  optionId?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The value of a text field in a Project item. */\nexport type ProjectV2ItemFieldTextValue = Node & ProjectV2ItemFieldValueCommon & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID']['output'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Text value of a field */\n  text?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The value of a user field in a Project item. */\nexport type ProjectV2ItemFieldUserValue = {\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The users for this field */\n  users?: Maybe<UserConnection>;\n};\n\n\n/** The value of a user field in a Project item. */\nexport type ProjectV2ItemFieldUserValueUsersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Project field values */\nexport type ProjectV2ItemFieldValue = ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldLabelValue | ProjectV2ItemFieldMilestoneValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldPullRequestValue | ProjectV2ItemFieldRepositoryValue | ProjectV2ItemFieldReviewerValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2ItemFieldUserValue;\n\n/** Common fields across different project field value types */\nexport type ProjectV2ItemFieldValueCommon = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID']['output'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for ProjectV2ItemFieldValue. */\nexport type ProjectV2ItemFieldValueConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ItemFieldValueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2ItemFieldValue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2ItemFieldValueEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2ItemFieldValue>;\n};\n\n/** Ordering options for project v2 item field value connections */\nexport type ProjectV2ItemFieldValueOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 item field values by. */\n  field: ProjectV2ItemFieldValueOrderField;\n};\n\n/** Properties by which project v2 item field value connections can be ordered. */\nexport enum ProjectV2ItemFieldValueOrderField {\n  /** Order project v2 item field values by the their position in the project */\n  Position = 'POSITION'\n}\n\n/** Ordering options for project v2 item connections */\nexport type ProjectV2ItemOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 items by. */\n  field: ProjectV2ItemOrderField;\n};\n\n/** Properties by which project v2 item connections can be ordered. */\nexport enum ProjectV2ItemOrderField {\n  /** Order project v2 items by the their position in the project */\n  Position = 'POSITION'\n}\n\n/** The type of a project item. */\nexport enum ProjectV2ItemType {\n  /** Draft Issue */\n  DraftIssue = 'DRAFT_ISSUE',\n  /** Issue */\n  Issue = 'ISSUE',\n  /** Pull Request */\n  PullRequest = 'PULL_REQUEST',\n  /** Redacted Item */\n  Redacted = 'REDACTED'\n}\n\n/** An iteration field inside a project. */\nexport type ProjectV2IterationField = Node & ProjectV2FieldCommon & {\n  /** Iteration configuration settings */\n  configuration: ProjectV2IterationFieldConfiguration;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The project field's name. */\n  name: Scalars['String']['output'];\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** Iteration field configuration for a project. */\nexport type ProjectV2IterationFieldConfiguration = {\n  /** The iteration's completed iterations */\n  completedIterations: Array<ProjectV2IterationFieldIteration>;\n  /** The iteration's duration in days */\n  duration: Scalars['Int']['output'];\n  /** The iteration's iterations */\n  iterations: Array<ProjectV2IterationFieldIteration>;\n  /** The iteration's start day of the week */\n  startDay: Scalars['Int']['output'];\n};\n\n/** Iteration field iteration settings for a project. */\nexport type ProjectV2IterationFieldIteration = {\n  /** The iteration's duration in days */\n  duration: Scalars['Int']['output'];\n  /** The iteration's ID. */\n  id: Scalars['String']['output'];\n  /** The iteration's start date */\n  startDate: Scalars['Date']['output'];\n  /** The iteration's title. */\n  title: Scalars['String']['output'];\n  /** The iteration's html title. */\n  titleHTML: Scalars['String']['output'];\n};\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectV2Order = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order projects by. */\n  field: ProjectV2OrderField;\n};\n\n/** Properties by which projects can be ordered. */\nexport enum ProjectV2OrderField {\n  /** The project's date and time of creation */\n  CreatedAt = 'CREATED_AT',\n  /** The project's number */\n  Number = 'NUMBER',\n  /** The project's title */\n  Title = 'TITLE',\n  /** The project's date and time of update */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2Owner = {\n  id: Scalars['ID']['output'];\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n};\n\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2OwnerProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2OwnerProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Recent projects for the owner. */\nexport type ProjectV2Recent = {\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n};\n\n\n/** Recent projects for the owner. */\nexport type ProjectV2RecentRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The possible roles of a collaborator on a project. */\nexport enum ProjectV2Roles {\n  /** The collaborator can view, edit, and maange the settings of the project */\n  Admin = 'ADMIN',\n  /** The collaborator has no direct access to the project */\n  None = 'NONE',\n  /** The collaborator can view the project */\n  Reader = 'READER',\n  /** The collaborator can view and edit the project */\n  Writer = 'WRITER'\n}\n\n/** A single select field inside a project. */\nexport type ProjectV2SingleSelectField = Node & ProjectV2FieldCommon & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The project field's name. */\n  name: Scalars['String']['output'];\n  /** Options for the single select field */\n  options: Array<ProjectV2SingleSelectFieldOption>;\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n\n/** A single select field inside a project. */\nexport type ProjectV2SingleSelectFieldOptionsArgs = {\n  names?: InputMaybe<Array<Scalars['String']['input']>>;\n};\n\n/** Single select field option for a configuration for a project. */\nexport type ProjectV2SingleSelectFieldOption = {\n  /** The option's display color. */\n  color: ProjectV2SingleSelectFieldOptionColor;\n  /** The option's plain-text description. */\n  description: Scalars['String']['output'];\n  /** The option's description, possibly containing HTML. */\n  descriptionHTML: Scalars['String']['output'];\n  /** The option's ID. */\n  id: Scalars['String']['output'];\n  /** The option's name. */\n  name: Scalars['String']['output'];\n  /** The option's html name. */\n  nameHTML: Scalars['String']['output'];\n};\n\n/** The display color of a single-select field option. */\nexport enum ProjectV2SingleSelectFieldOptionColor {\n  /** BLUE */\n  Blue = 'BLUE',\n  /** GRAY */\n  Gray = 'GRAY',\n  /** GREEN */\n  Green = 'GREEN',\n  /** ORANGE */\n  Orange = 'ORANGE',\n  /** PINK */\n  Pink = 'PINK',\n  /** PURPLE */\n  Purple = 'PURPLE',\n  /** RED */\n  Red = 'RED',\n  /** YELLOW */\n  Yellow = 'YELLOW'\n}\n\n/** Represents a single select field option */\nexport type ProjectV2SingleSelectFieldOptionInput = {\n  /** The display color of the option */\n  color: ProjectV2SingleSelectFieldOptionColor;\n  /** The description text of the option */\n  description: Scalars['String']['input'];\n  /** The name of the option */\n  name: Scalars['String']['input'];\n};\n\n/** Represents a sort by field and direction. */\nexport type ProjectV2SortBy = {\n  /** The direction of the sorting. Possible values are ASC and DESC. */\n  direction: OrderDirection;\n  /** The field by which items are sorted. */\n  field: ProjectV2Field;\n};\n\n/** The connection type for ProjectV2SortBy. */\nexport type ProjectV2SortByConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2SortByEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2SortBy>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2SortByEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2SortBy>;\n};\n\n/** Represents a sort by field and direction. */\nexport type ProjectV2SortByField = {\n  /** The direction of the sorting. Possible values are ASC and DESC. */\n  direction: OrderDirection;\n  /** The field by which items are sorted. */\n  field: ProjectV2FieldConfiguration;\n};\n\n/** The connection type for ProjectV2SortByField. */\nexport type ProjectV2SortByFieldConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2SortByFieldEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2SortByField>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2SortByFieldEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2SortByField>;\n};\n\n/** The possible states of a project v2. */\nexport enum ProjectV2State {\n  /** A project v2 that has been closed */\n  Closed = 'CLOSED',\n  /** A project v2 that is still open */\n  Open = 'OPEN'\n}\n\n/** A view within a ProjectV2. */\nexport type ProjectV2View = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The view's visible fields. */\n  fields?: Maybe<ProjectV2FieldConfigurationConnection>;\n  /** The project view's filter. */\n  filter?: Maybe<Scalars['String']['output']>;\n  /**\n   * The view's group-by field.\n   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.\n   */\n  groupBy?: Maybe<ProjectV2FieldConnection>;\n  /** The view's group-by field. */\n  groupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;\n  id: Scalars['ID']['output'];\n  /** The project view's layout. */\n  layout: ProjectV2ViewLayout;\n  /** The project view's name. */\n  name: Scalars['String']['output'];\n  /** The project view's number. */\n  number: Scalars['Int']['output'];\n  /** The project that contains this view. */\n  project: ProjectV2;\n  /**\n   * The view's sort-by config.\n   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.\n   */\n  sortBy?: Maybe<ProjectV2SortByConnection>;\n  /** The view's sort-by config. */\n  sortByFields?: Maybe<ProjectV2SortByFieldConnection>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /**\n   * The view's vertical-group-by field.\n   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.\n   */\n  verticalGroupBy?: Maybe<ProjectV2FieldConnection>;\n  /** The view's vertical-group-by field. */\n  verticalGroupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;\n  /**\n   * The view's visible fields.\n   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.\n   */\n  visibleFields?: Maybe<ProjectV2FieldConnection>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewGroupByArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewGroupByFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewSortByArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewSortByFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewVerticalGroupByArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewVerticalGroupByFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewVisibleFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n/** The connection type for ProjectV2View. */\nexport type ProjectV2ViewConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ViewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2View>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2ViewEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2View>;\n};\n\n/** The layout of a project v2 view. */\nexport enum ProjectV2ViewLayout {\n  /** Board layout */\n  BoardLayout = 'BOARD_LAYOUT',\n  /** Roadmap layout */\n  RoadmapLayout = 'ROADMAP_LAYOUT',\n  /** Table layout */\n  TableLayout = 'TABLE_LAYOUT'\n}\n\n/** Ordering options for project v2 view connections */\nexport type ProjectV2ViewOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 views by. */\n  field: ProjectV2ViewOrderField;\n};\n\n/** Properties by which project v2 view connections can be ordered. */\nexport enum ProjectV2ViewOrderField {\n  /** Order project v2 views by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order project v2 views by name */\n  Name = 'NAME',\n  /** Order project v2 views by position */\n  Position = 'POSITION'\n}\n\n/** A workflow inside a project. */\nexport type ProjectV2Workflow = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The workflows' enabled state. */\n  enabled: Scalars['Boolean']['output'];\n  id: Scalars['ID']['output'];\n  /** The workflows' name. */\n  name: Scalars['String']['output'];\n  /** The workflows' number. */\n  number: Scalars['Int']['output'];\n  /** The project that contains this workflow. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for ProjectV2Workflow. */\nexport type ProjectV2WorkflowConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2WorkflowEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Workflow>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2WorkflowEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Workflow>;\n};\n\n/** Ordering options for project v2 workflows connections */\nexport type ProjectV2WorkflowOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 workflows by. */\n  field: ProjectV2WorkflowsOrderField;\n};\n\n/** Properties by which project workflows can be ordered. */\nexport enum ProjectV2WorkflowsOrderField {\n  /** The workflows' date and time of creation */\n  CreatedAt = 'CREATED_AT',\n  /** The workflows' name */\n  Name = 'NAME',\n  /** The workflows' number */\n  Number = 'NUMBER',\n  /** The workflows' date and time of update */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** A user's public key. */\nexport type PublicKey = Node & {\n  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */\n  accessedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Identifies the date and time when the key was created. Keys created before\n   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.\n   */\n  createdAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The fingerprint for this PublicKey. */\n  fingerprint: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */\n  isReadOnly?: Maybe<Scalars['Boolean']['output']>;\n  /** The public key string. */\n  key: Scalars['String']['output'];\n  /**\n   * Identifies the date and time when the key was updated. Keys created before\n   * March 5th, 2014 may have inaccurate values. Values will be null for keys not\n   * owned by the user.\n   */\n  updatedAt?: Maybe<Scalars['DateTime']['output']>;\n};\n\n/** The connection type for PublicKey. */\nexport type PublicKeyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PublicKeyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PublicKey>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PublicKeyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PublicKey>;\n};\n\n/** Autogenerated input type of PublishSponsorsTier */\nexport type PublishSponsorsTierInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the draft tier to publish. */\n  tierId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of PublishSponsorsTier */\nexport type PublishSponsorsTierPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The tier that was published. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** A repository pull request. */\nexport type PullRequest = Assignable & Closable & Comment & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** The number of additions in this pull request. */\n  additions: Scalars['Int']['output'];\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Returns the auto-merge request object if one exists for this pull request. */\n  autoMergeRequest?: Maybe<AutoMergeRequest>;\n  /** Identifies the base Ref associated with the pull request. */\n  baseRef?: Maybe<Ref>;\n  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */\n  baseRefName: Scalars['String']['output'];\n  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */\n  baseRefOid: Scalars['GitObjectID']['output'];\n  /** The repository associated with this pull request's base Ref. */\n  baseRepository?: Maybe<Repository>;\n  /** The body as Markdown. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /** The number of changed files in this pull request. */\n  changedFiles: Scalars['Int']['output'];\n  /** The HTTP path for the checks of this pull request. */\n  checksResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for the checks of this pull request. */\n  checksUrl: Scalars['URI']['output'];\n  /** `true` if the pull request is closed */\n  closed: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** List of issues that were may be closed by this pull request */\n  closingIssuesReferences?: Maybe<IssueConnection>;\n  /** A list of comments associated with the pull request. */\n  comments: IssueCommentConnection;\n  /** A list of commits present in this pull request's head branch not present in the base branch. */\n  commits: PullRequestCommitConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The number of deletions in this pull request. */\n  deletions: Scalars['Int']['output'];\n  /** The actor who edited this pull request's body. */\n  editor?: Maybe<Actor>;\n  /** Lists the files changed within this pull request. */\n  files?: Maybe<PullRequestChangedFileConnection>;\n  /** Identifies the head Ref associated with the pull request. */\n  headRef?: Maybe<Ref>;\n  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */\n  headRefName: Scalars['String']['output'];\n  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */\n  headRefOid: Scalars['GitObjectID']['output'];\n  /** The repository associated with this pull request's head Ref. */\n  headRepository?: Maybe<Repository>;\n  /** The owner of the repository associated with this pull request's head Ref. */\n  headRepositoryOwner?: Maybe<RepositoryOwner>;\n  /** The hovercard information for this issue */\n  hovercard: Hovercard;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** The head and base repositories are different. */\n  isCrossRepository: Scalars['Boolean']['output'];\n  /** Identifies if the pull request is a draft. */\n  isDraft: Scalars['Boolean']['output'];\n  /** Is this pull request read by the viewer */\n  isReadByViewer?: Maybe<Scalars['Boolean']['output']>;\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of latest reviews per user associated with the pull request. */\n  latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>;\n  /** A list of latest reviews per user associated with the pull request that are not also pending review. */\n  latestReviews?: Maybe<PullRequestReviewConnection>;\n  /** `true` if the pull request is locked */\n  locked: Scalars['Boolean']['output'];\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify: Scalars['Boolean']['output'];\n  /** The commit that was created when this pull request was merged. */\n  mergeCommit?: Maybe<Commit>;\n  /** The merge queue entry of the pull request in the base branch's merge queue */\n  mergeQueueEntry?: Maybe<MergeQueueEntry>;\n  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */\n  mergeable: MergeableState;\n  /** Whether or not the pull request was merged. */\n  merged: Scalars['Boolean']['output'];\n  /** The date and time that the pull request was merged. */\n  mergedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The actor who merged the pull request. */\n  mergedBy?: Maybe<Actor>;\n  /** Identifies the milestone associated with the pull request. */\n  milestone?: Maybe<Milestone>;\n  /** Identifies the pull request number. */\n  number: Scalars['Int']['output'];\n  /** A list of Users that are participating in the Pull Request conversation. */\n  participants: UserConnection;\n  /** The permalink to the pull request. */\n  permalink: Scalars['URI']['output'];\n  /**\n   * The commit that GitHub automatically generated to test if this pull request\n   * could be merged. This field will not return a value if the pull request is\n   * merged, or if the test merge commit is still being generated. See the\n   * `mergeable` field for more details on the mergeability of the pull request.\n   */\n  potentialMergeCommit?: Maybe<Commit>;\n  /** List of project cards associated with this pull request. */\n  projectCards: ProjectCardConnection;\n  /** List of project items associated with this pull request. */\n  projectItems: ProjectV2ItemConnection;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path for this pull request. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP path for reverting this pull request. */\n  revertResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for reverting this pull request. */\n  revertUrl: Scalars['URI']['output'];\n  /** The current status of this pull request with respect to code review. */\n  reviewDecision?: Maybe<PullRequestReviewDecision>;\n  /** A list of review requests associated with the pull request. */\n  reviewRequests?: Maybe<ReviewRequestConnection>;\n  /** The list of all review threads for this pull request. */\n  reviewThreads: PullRequestReviewThreadConnection;\n  /** A list of reviews associated with the pull request. */\n  reviews?: Maybe<PullRequestReviewConnection>;\n  /** Identifies the state of the pull request. */\n  state: PullRequestState;\n  /** A list of reviewer suggestions based on commit history and past review comments. */\n  suggestedReviewers: Array<Maybe<SuggestedReviewer>>;\n  /**\n   * A list of events, comments, commits, etc. associated with the pull request.\n   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.\n   */\n  timeline: PullRequestTimelineConnection;\n  /** A list of events, comments, commits, etc. associated with the pull request. */\n  timelineItems: PullRequestTimelineItemsConnection;\n  /** Identifies the pull request title. */\n  title: Scalars['String']['output'];\n  /** Identifies the pull request title rendered to HTML. */\n  titleHTML: Scalars['HTML']['output'];\n  /** Returns a count of how many comments this pull request has received. */\n  totalCommentsCount?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this pull request. */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Whether or not the viewer can apply suggestion. */\n  viewerCanApplySuggestion: Scalars['Boolean']['output'];\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean']['output'];\n  /** Check if the viewer can restore the deleted head ref. */\n  viewerCanDeleteHeadRef: Scalars['Boolean']['output'];\n  /** Whether or not the viewer can disable auto-merge */\n  viewerCanDisableAutoMerge: Scalars['Boolean']['output'];\n  /** Can the viewer edit files within this pull request. */\n  viewerCanEditFiles: Scalars['Boolean']['output'];\n  /** Whether or not the viewer can enable auto-merge */\n  viewerCanEnableAutoMerge: Scalars['Boolean']['output'];\n  /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */\n  viewerCanMergeAsAdmin: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /**\n   * Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.\n   * If the head ref is up to date or unable to be updated by this user, this will return false.\n   */\n  viewerCanUpdateBranch: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n  /** The latest review given from the viewer. */\n  viewerLatestReview?: Maybe<PullRequestReview>;\n  /** The person who has requested the viewer for review on this pull request. */\n  viewerLatestReviewRequest?: Maybe<ReviewRequest>;\n  /** The merge body text for the viewer and method. */\n  viewerMergeBodyText: Scalars['String']['output'];\n  /** The merge headline text for the viewer and method. */\n  viewerMergeHeadlineText: Scalars['String']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestClosingIssuesReferencesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  userLinkedOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestCommitsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestFilesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestHovercardArgs = {\n  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestLatestOpinionatedReviewsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  writersOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestLatestReviewsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestParticipantsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectCardsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReviewRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReviewThreadsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReviewsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  author?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  states?: InputMaybe<Array<PullRequestReviewState>>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestTimelineArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestTimelineItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  itemTypes?: InputMaybe<Array<PullRequestTimelineItemsItemType>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  skip?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeBodyTextArgs = {\n  mergeType?: InputMaybe<PullRequestMergeMethod>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeHeadlineTextArgs = {\n  mergeType?: InputMaybe<PullRequestMergeMethod>;\n};\n\n/** A file changed in a pull request. */\nexport type PullRequestChangedFile = {\n  /** The number of additions to the file. */\n  additions: Scalars['Int']['output'];\n  /** How the file was changed in this PullRequest */\n  changeType: PatchStatus;\n  /** The number of deletions to the file. */\n  deletions: Scalars['Int']['output'];\n  /** The path of the file. */\n  path: Scalars['String']['output'];\n  /** The state of the file for the viewer. */\n  viewerViewedState: FileViewedState;\n};\n\n/** The connection type for PullRequestChangedFile. */\nexport type PullRequestChangedFileConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestChangedFileEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestChangedFile>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestChangedFileEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestChangedFile>;\n};\n\n/** Represents a Git commit part of a pull request. */\nexport type PullRequestCommit = Node & UniformResourceLocatable & {\n  /** The Git commit object */\n  commit: Commit;\n  id: Scalars['ID']['output'];\n  /** The pull request this commit belongs to */\n  pullRequest: PullRequest;\n  /** The HTTP path for this pull request commit */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this pull request commit */\n  url: Scalars['URI']['output'];\n};\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThread = Node & RepositoryNode & {\n  /** The comments that exist in this thread. */\n  comments: CommitCommentConnection;\n  /** The commit the comments were made on. */\n  commit: Commit;\n  id: Scalars['ID']['output'];\n  /** The file the comments were made on. */\n  path?: Maybe<Scalars['String']['output']>;\n  /** The position in the diff for the commit that the comment was made on. */\n  position?: Maybe<Scalars['Int']['output']>;\n  /** The pull request this commit comment thread belongs to */\n  pullRequest: PullRequest;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for PullRequestCommit. */\nexport type PullRequestCommitConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestCommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestCommit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestCommitEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestCommit>;\n};\n\n/** The connection type for PullRequest. */\nexport type PullRequestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepository = {\n  /** The pull request contributions. */\n  contributions: CreatedPullRequestContributionConnection;\n  /** The repository in which the pull requests were opened. */\n  repository: Repository;\n};\n\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type PullRequestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequest>;\n};\n\n/** Represents available types of methods to use when merging a pull request. */\nexport enum PullRequestMergeMethod {\n  /** Add all commits from the head branch to the base branch with a merge commit. */\n  Merge = 'MERGE',\n  /** Add all commits from the head branch onto the base branch individually. */\n  Rebase = 'REBASE',\n  /** Combine all commits from the head branch into a single commit in the base branch. */\n  Squash = 'SQUASH'\n}\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type PullRequestOrder = {\n  /** The direction in which to order pull requests by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order pull requests by. */\n  field: PullRequestOrderField;\n};\n\n/** Properties by which pull_requests connections can be ordered. */\nexport enum PullRequestOrderField {\n  /** Order pull_requests by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order pull_requests by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */\nexport type PullRequestParameters = {\n  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */\n  dismissStaleReviewsOnPush: Scalars['Boolean']['output'];\n  /** Require an approving review in pull requests that modify files that have a designated code owner. */\n  requireCodeOwnerReview: Scalars['Boolean']['output'];\n  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */\n  requireLastPushApproval: Scalars['Boolean']['output'];\n  /** The number of approving reviews that are required before a pull request can be merged. */\n  requiredApprovingReviewCount: Scalars['Int']['output'];\n  /** All conversations on code must be resolved before a pull request can be merged. */\n  requiredReviewThreadResolution: Scalars['Boolean']['output'];\n};\n\n/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */\nexport type PullRequestParametersInput = {\n  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */\n  dismissStaleReviewsOnPush: Scalars['Boolean']['input'];\n  /** Require an approving review in pull requests that modify files that have a designated code owner. */\n  requireCodeOwnerReview: Scalars['Boolean']['input'];\n  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */\n  requireLastPushApproval: Scalars['Boolean']['input'];\n  /** The number of approving reviews that are required before a pull request can be merged. */\n  requiredApprovingReviewCount: Scalars['Int']['input'];\n  /** All conversations on code must be resolved before a pull request can be merged. */\n  requiredReviewThreadResolution: Scalars['Boolean']['input'];\n};\n\n/** A review object for a given pull request. */\nexport type PullRequestReview = Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Indicates whether the author of this review has push access to the repository. */\n  authorCanPushToRepository: Scalars['Boolean']['output'];\n  /** Identifies the pull request review body. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body of this review rendered as plain text. */\n  bodyText: Scalars['String']['output'];\n  /** A list of review comments for the current pull request review. */\n  comments: PullRequestReviewCommentConnection;\n  /** Identifies the commit associated with this pull request review. */\n  commit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of teams that this review was made on behalf of. */\n  onBehalfOf: TeamConnection;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the pull request associated with this pull request review. */\n  pullRequest: PullRequest;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path permalink for this PullRequestReview. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the current state of the pull request review. */\n  state: PullRequestReviewState;\n  /** Identifies when the Pull Request Review was submitted */\n  submittedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL permalink for this PullRequestReview. */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewOnBehalfOfArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The comment body of this review comment. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The comment body of this review comment rendered as plain text. */\n  bodyText: Scalars['String']['output'];\n  /** Identifies the commit associated with the comment. */\n  commit?: Maybe<Commit>;\n  /** Identifies when the comment was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The diff hunk to which the comment applies. */\n  diffHunk: Scalars['String']['output'];\n  /** Identifies when the comment was created in a draft state. */\n  draftedAt: Scalars['DateTime']['output'];\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The end line number on the file to which the comment applies */\n  line?: Maybe<Scalars['Int']['output']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']['output']>;\n  /** Identifies the original commit associated with the comment. */\n  originalCommit?: Maybe<Commit>;\n  /** The end line number on the file to which the comment applied when it was first created */\n  originalLine?: Maybe<Scalars['Int']['output']>;\n  /**\n   * The original line index in the diff to which the comment applies.\n   * @deprecated We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.\n   */\n  originalPosition: Scalars['Int']['output'];\n  /** The start line number on the file to which the comment applied when it was first created */\n  originalStartLine?: Maybe<Scalars['Int']['output']>;\n  /** Identifies when the comment body is outdated */\n  outdated: Scalars['Boolean']['output'];\n  /** The path to which the comment applies. */\n  path: Scalars['String']['output'];\n  /**\n   * The line index in the diff to which the comment applies.\n   * @deprecated We are phasing out diff-relative positioning for PR comments Use the `line` and `startLine` fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC.\n   */\n  position?: Maybe<Scalars['Int']['output']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The pull request associated with this review comment. */\n  pullRequest: PullRequest;\n  /** The pull request review associated with this review comment. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The comment this is a reply to. */\n  replyTo?: Maybe<PullRequestReviewComment>;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path permalink for this review comment. */\n  resourcePath: Scalars['URI']['output'];\n  /** The start line number on the file to which the comment applies */\n  startLine?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the state of the comment. */\n  state: PullRequestReviewCommentState;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType: PullRequestReviewThreadSubjectType;\n  /** Identifies when the comment was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL permalink for this review comment. */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for PullRequestReviewComment. */\nexport type PullRequestReviewCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestReviewCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewComment>;\n};\n\n/** The possible states of a pull request review comment. */\nexport enum PullRequestReviewCommentState {\n  /** A comment that is part of a pending review */\n  Pending = 'PENDING',\n  /** A comment that is part of a submitted review */\n  Submitted = 'SUBMITTED'\n}\n\n/** The connection type for PullRequestReview. */\nexport type PullRequestReviewConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReview>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepository = {\n  /** The pull request review contributions. */\n  contributions: CreatedPullRequestReviewContributionConnection;\n  /** The repository in which the pull request reviews were made. */\n  repository: Repository;\n};\n\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** The review status of a pull request. */\nexport enum PullRequestReviewDecision {\n  /** The pull request has received an approving review. */\n  Approved = 'APPROVED',\n  /** Changes have been requested on the pull request. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** A review is required before the pull request can be merged. */\n  ReviewRequired = 'REVIEW_REQUIRED'\n}\n\n/** An edge in a connection. */\nexport type PullRequestReviewEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReview>;\n};\n\n/** The possible events to perform on a pull request review. */\nexport enum PullRequestReviewEvent {\n  /** Submit feedback and approve merging these changes. */\n  Approve = 'APPROVE',\n  /** Submit general feedback without explicit approval. */\n  Comment = 'COMMENT',\n  /** Dismiss review so it now longer effects merging. */\n  Dismiss = 'DISMISS',\n  /** Submit feedback that must be addressed before merging. */\n  RequestChanges = 'REQUEST_CHANGES'\n}\n\n/** The possible states of a pull request review. */\nexport enum PullRequestReviewState {\n  /** A review allowing the pull request to merge. */\n  Approved = 'APPROVED',\n  /** A review blocking the pull request from merging. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** An informational review. */\n  Commented = 'COMMENTED',\n  /** A review that has been dismissed. */\n  Dismissed = 'DISMISSED',\n  /** A review that has not yet been submitted. */\n  Pending = 'PENDING'\n}\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThread = Node & {\n  /** A list of pull request comments associated with the thread. */\n  comments: PullRequestReviewCommentConnection;\n  /** The side of the diff on which this thread was placed. */\n  diffSide: DiffSide;\n  id: Scalars['ID']['output'];\n  /** Whether or not the thread has been collapsed (resolved) */\n  isCollapsed: Scalars['Boolean']['output'];\n  /** Indicates whether this thread was outdated by newer changes. */\n  isOutdated: Scalars['Boolean']['output'];\n  /** Whether this thread has been resolved */\n  isResolved: Scalars['Boolean']['output'];\n  /** The line in the file to which this thread refers */\n  line?: Maybe<Scalars['Int']['output']>;\n  /** The original line in the file to which this thread refers. */\n  originalLine?: Maybe<Scalars['Int']['output']>;\n  /** The original start line in the file to which this thread refers (multi-line only). */\n  originalStartLine?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the file path of this thread. */\n  path: Scalars['String']['output'];\n  /** Identifies the pull request associated with this thread. */\n  pullRequest: PullRequest;\n  /** Identifies the repository associated with this thread. */\n  repository: Repository;\n  /** The user who resolved this thread */\n  resolvedBy?: Maybe<User>;\n  /** The side of the diff that the first line of the thread starts on (multi-line only) */\n  startDiffSide?: Maybe<DiffSide>;\n  /** The start line in the file to which this thread refers (multi-line only) */\n  startLine?: Maybe<Scalars['Int']['output']>;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType: PullRequestReviewThreadSubjectType;\n  /** Indicates whether the current viewer can reply to this thread. */\n  viewerCanReply: Scalars['Boolean']['output'];\n  /** Whether or not the viewer can resolve this thread */\n  viewerCanResolve: Scalars['Boolean']['output'];\n  /** Whether or not the viewer can unresolve this thread */\n  viewerCanUnresolve: Scalars['Boolean']['output'];\n};\n\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  skip?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Review comment threads for a pull request review. */\nexport type PullRequestReviewThreadConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewThreadEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewThread>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestReviewThreadEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewThread>;\n};\n\n/** The possible subject types of a pull request review comment. */\nexport enum PullRequestReviewThreadSubjectType {\n  /** A comment that has been made against the file of a pull request */\n  File = 'FILE',\n  /** A comment that has been made against the line of a pull request */\n  Line = 'LINE'\n}\n\n/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\nexport type PullRequestRevisionMarker = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The last commit the viewer has seen. */\n  lastSeenCommit: Commit;\n  /** The pull request to which the marker belongs. */\n  pullRequest: PullRequest;\n};\n\n/** The possible states of a pull request. */\nexport enum PullRequestState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that has been closed by being merged. */\n  Merged = 'MERGED',\n  /** A pull request that is still open. */\n  Open = 'OPEN'\n}\n\n/** A repository pull request template. */\nexport type PullRequestTemplate = {\n  /** The body of the template */\n  body?: Maybe<Scalars['String']['output']>;\n  /** The filename of the template */\n  filename?: Maybe<Scalars['String']['output']>;\n  /** The repository the template belongs to */\n  repository: Repository;\n};\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestThread = Node & {\n  /** A list of pull request comments associated with the thread. */\n  comments: PullRequestReviewCommentConnection;\n  /** The side of the diff on which this thread was placed. */\n  diffSide: DiffSide;\n  id: Scalars['ID']['output'];\n  /** Whether or not the thread has been collapsed (resolved) */\n  isCollapsed: Scalars['Boolean']['output'];\n  /** Indicates whether this thread was outdated by newer changes. */\n  isOutdated: Scalars['Boolean']['output'];\n  /** Whether this thread has been resolved */\n  isResolved: Scalars['Boolean']['output'];\n  /** The line in the file to which this thread refers */\n  line?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the file path of this thread. */\n  path: Scalars['String']['output'];\n  /** Identifies the pull request associated with this thread. */\n  pullRequest: PullRequest;\n  /** Identifies the repository associated with this thread. */\n  repository: Repository;\n  /** The user who resolved this thread */\n  resolvedBy?: Maybe<User>;\n  /** The side of the diff that the first line of the thread starts on (multi-line only) */\n  startDiffSide?: Maybe<DiffSide>;\n  /** The line of the first file diff in the thread. */\n  startLine?: Maybe<Scalars['Int']['output']>;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType: PullRequestReviewThreadSubjectType;\n  /** Indicates whether the current viewer can reply to this thread. */\n  viewerCanReply: Scalars['Boolean']['output'];\n  /** Whether or not the viewer can resolve this thread */\n  viewerCanResolve: Scalars['Boolean']['output'];\n  /** Whether or not the viewer can unresolve this thread */\n  viewerCanUnresolve: Scalars['Boolean']['output'];\n};\n\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  skip?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for PullRequestTimelineItem. */\nexport type PullRequestTimelineConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItem = AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItem>;\n};\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItems = AddedToMergeQueueEvent | AddedToProjectEvent | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** The connection type for PullRequestTimelineItems. */\nexport type PullRequestTimelineItemsConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemsEdge>>>;\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars['Int']['output'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItems>>>;\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars['Int']['output'];\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemsEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItems>;\n};\n\n/** The possible item types found in a timeline. */\nexport enum PullRequestTimelineItemsItemType {\n  /** Represents an 'added_to_merge_queue' event on a given pull request. */\n  AddedToMergeQueueEvent = 'ADDED_TO_MERGE_QUEUE_EVENT',\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'automatic_base_change_failed' event on a given pull request. */\n  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',\n  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\n  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',\n  /** Represents a 'auto_merge_disabled' event on a given pull request. */\n  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',\n  /** Represents a 'auto_merge_enabled' event on a given pull request. */\n  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',\n  /** Represents a 'auto_rebase_enabled' event on a given pull request. */\n  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',\n  /** Represents a 'auto_squash_enabled' event on a given pull request. */\n  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',\n  /** Represents a 'base_ref_changed' event on a given issue or pull request. */\n  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',\n  /** Represents a 'base_ref_deleted' event on a given pull request. */\n  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',\n  /** Represents a 'base_ref_force_pushed' event on a given pull request. */\n  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a 'converted_to_discussion' event on a given issue. */\n  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',\n  /** Represents a 'convert_to_draft' event on a given pull request. */\n  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'deployed' event on a given pull request. */\n  DeployedEvent = 'DEPLOYED_EVENT',\n  /** Represents a 'deployment_environment_changed' event on a given pull request. */\n  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a 'head_ref_deleted' event on a given pull request. */\n  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',\n  /** Represents a 'head_ref_force_pushed' event on a given pull request. */\n  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'head_ref_restored' event on a given pull request. */\n  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'merged' event on a given pull request. */\n  MergedEvent = 'MERGED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a Git commit part of a pull request. */\n  PullRequestCommit = 'PULL_REQUEST_COMMIT',\n  /** Represents a commit comment thread part of a pull request. */\n  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',\n  /** A review object for a given pull request. */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** A threaded list of comments for a given pull request. */\n  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',\n  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\n  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',\n  /** Represents a 'ready_for_review' event on a given pull request. */\n  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_merge_queue' event on a given pull request. */\n  RemovedFromMergeQueueEvent = 'REMOVED_FROM_MERGE_QUEUE_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'review_dismissed' event on a given issue or pull request. */\n  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',\n  /** Represents an 'review_requested' event on a given pull request. */\n  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',\n  /** Represents an 'review_request_removed' event on a given pull request. */\n  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT'\n}\n\n/** The possible target states when updating a pull request. */\nexport enum PullRequestUpdateState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that is still open. */\n  Open = 'OPEN'\n}\n\n/** A Git push. */\nexport type Push = Node & {\n  id: Scalars['ID']['output'];\n  /** The SHA after the push */\n  nextSha?: Maybe<Scalars['GitObjectID']['output']>;\n  /** The permalink for this push. */\n  permalink: Scalars['URI']['output'];\n  /** The SHA before the push */\n  previousSha?: Maybe<Scalars['GitObjectID']['output']>;\n  /** The actor who pushed */\n  pusher: Actor;\n  /** The repository that was pushed to */\n  repository: Repository;\n};\n\n/** A team, user, or app who has the ability to push to a protected branch. */\nexport type PushAllowance = Node & {\n  /** The actor that can push. */\n  actor?: Maybe<PushAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID']['output'];\n};\n\n/** Types that can be an actor. */\nexport type PushAllowanceActor = App | Team | User;\n\n/** The connection type for PushAllowance. */\nexport type PushAllowanceConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PushAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PushAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type PushAllowanceEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PushAllowance>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type Query = {\n  /** Look up a code of conduct by its key */\n  codeOfConduct?: Maybe<CodeOfConduct>;\n  /** Look up a code of conduct by its key */\n  codesOfConduct?: Maybe<Array<Maybe<CodeOfConduct>>>;\n  /** Look up an enterprise by URL slug. */\n  enterprise?: Maybe<Enterprise>;\n  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */\n  enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** Look up a pending enterprise administrator invitation by invitation token. */\n  enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>;\n  /** Look up an open source license by its key */\n  license?: Maybe<License>;\n  /** Return a list of known open source licenses */\n  licenses: Array<Maybe<License>>;\n  /** Get alphabetically sorted list of Marketplace categories */\n  marketplaceCategories: Array<MarketplaceCategory>;\n  /** Look up a Marketplace category by its slug. */\n  marketplaceCategory?: Maybe<MarketplaceCategory>;\n  /** Look up a single Marketplace listing */\n  marketplaceListing?: Maybe<MarketplaceListing>;\n  /** Look up Marketplace listings */\n  marketplaceListings: MarketplaceListingConnection;\n  /** Return information about the GitHub instance */\n  meta: GitHubMetadata;\n  /** Fetches an object given its ID. */\n  node?: Maybe<Node>;\n  /** Lookup nodes by a list of IDs. */\n  nodes: Array<Maybe<Node>>;\n  /** Lookup a organization by login. */\n  organization?: Maybe<Organization>;\n  /** The client's rate limit information. */\n  rateLimit?: Maybe<RateLimit>;\n  /**\n   * Workaround for re-exposing the root query object. (Refer to\n   * https://github.com/facebook/relay/issues/112 for more information.)\n   */\n  relay: Query;\n  /** Lookup a given repository by the owner and repository name. */\n  repository?: Maybe<Repository>;\n  /** Lookup a repository owner (ie. either a User or an Organization) by login. */\n  repositoryOwner?: Maybe<RepositoryOwner>;\n  /** Lookup resource by a URL. */\n  resource?: Maybe<UniformResourceLocatable>;\n  /** Perform a search across resources, returning a maximum of 1,000 results. */\n  search: SearchResultItemConnection;\n  /** GitHub Security Advisories */\n  securityAdvisories: SecurityAdvisoryConnection;\n  /** Fetch a Security Advisory by its GHSA ID */\n  securityAdvisory?: Maybe<SecurityAdvisory>;\n  /** Software Vulnerabilities documented by GitHub Security Advisories */\n  securityVulnerabilities: SecurityVulnerabilityConnection;\n  /** Users and organizations who can be sponsored via GitHub Sponsors. */\n  sponsorables: SponsorableItemConnection;\n  /** Look up a topic by name. */\n  topic?: Maybe<Topic>;\n  /** Lookup a user by login. */\n  user?: Maybe<User>;\n  /** The currently authenticated user. */\n  viewer: User;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryCodeOfConductArgs = {\n  key: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseArgs = {\n  invitationToken?: InputMaybe<Scalars['String']['input']>;\n  slug: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationArgs = {\n  enterpriseSlug: Scalars['String']['input'];\n  role: EnterpriseAdministratorRole;\n  userLogin: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationByTokenArgs = {\n  invitationToken: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryLicenseArgs = {\n  key: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoriesArgs = {\n  excludeEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  excludeSubcategories?: InputMaybe<Scalars['Boolean']['input']>;\n  includeCategories?: InputMaybe<Array<Scalars['String']['input']>>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoryArgs = {\n  slug: Scalars['String']['input'];\n  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingArgs = {\n  slug: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingsArgs = {\n  adminId?: InputMaybe<Scalars['ID']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  allStates?: InputMaybe<Scalars['Boolean']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  categorySlug?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  organizationId?: InputMaybe<Scalars['ID']['input']>;\n  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  slugs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;\n  viewerCanAdmin?: InputMaybe<Scalars['Boolean']['input']>;\n  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodeArgs = {\n  id: Scalars['ID']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodesArgs = {\n  ids: Array<Scalars['ID']['input']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryOrganizationArgs = {\n  login: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRateLimitArgs = {\n  dryRun?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']['input']>;\n  name: Scalars['String']['input'];\n  owner: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryOwnerArgs = {\n  login: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryResourceArgs = {\n  url: Scalars['URI']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySearchArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  query: Scalars['String']['input'];\n  type: SearchType;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  identifier?: InputMaybe<SecurityAdvisoryIdentifierFilter>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SecurityAdvisoryOrder>;\n  publishedSince?: InputMaybe<Scalars['DateTime']['input']>;\n  updatedSince?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoryArgs = {\n  ghsaId: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityVulnerabilitiesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;\n  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;\n  package?: InputMaybe<Scalars['String']['input']>;\n  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySponsorablesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  dependencyEcosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  ecosystem?: InputMaybe<DependencyGraphEcosystem>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  onlyDependencies?: InputMaybe<Scalars['Boolean']['input']>;\n  orderBy?: InputMaybe<SponsorableOrder>;\n  orgLoginForDependencies?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryTopicArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryUserArgs = {\n  login: Scalars['String']['input'];\n};\n\n/** Represents the client's rate limit. */\nexport type RateLimit = {\n  /** The point cost for the current query counting against the rate limit. */\n  cost: Scalars['Int']['output'];\n  /** The maximum number of points the client is permitted to consume in a 60 minute window. */\n  limit: Scalars['Int']['output'];\n  /** The maximum number of nodes this query may return */\n  nodeCount: Scalars['Int']['output'];\n  /** The number of points remaining in the current rate limit window. */\n  remaining: Scalars['Int']['output'];\n  /** The time at which the current rate limit window resets in UTC epoch seconds. */\n  resetAt: Scalars['DateTime']['output'];\n  /** The number of points used in the current rate limit window. */\n  used: Scalars['Int']['output'];\n};\n\n/** Represents a subject that can be reacted on. */\nexport type Reactable = {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a subject that can be reacted on. */\nexport type ReactableReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** The connection type for User. */\nexport type ReactingUserConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactingUserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a user that's made a reaction. */\nexport type ReactingUserEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  node: User;\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars['DateTime']['output'];\n};\n\n/** An emoji reaction to a particular piece of content. */\nexport type Reaction = Node & {\n  /** Identifies the emoji reaction. */\n  content: ReactionContent;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The reactable piece of content */\n  reactable: Reactable;\n  /** Identifies the user who created this reaction. */\n  user?: Maybe<User>;\n};\n\n/** A list of reactions that have been left on the subject. */\nexport type ReactionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reaction>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars['Boolean']['output'];\n};\n\n/** Emojis that can be attached to Issues, Pull Requests and Comments. */\nexport enum ReactionContent {\n  /** Represents the `:confused:` emoji. */\n  Confused = 'CONFUSED',\n  /** Represents the `:eyes:` emoji. */\n  Eyes = 'EYES',\n  /** Represents the `:heart:` emoji. */\n  Heart = 'HEART',\n  /** Represents the `:hooray:` emoji. */\n  Hooray = 'HOORAY',\n  /** Represents the `:laugh:` emoji. */\n  Laugh = 'LAUGH',\n  /** Represents the `:rocket:` emoji. */\n  Rocket = 'ROCKET',\n  /** Represents the `:-1:` emoji. */\n  ThumbsDown = 'THUMBS_DOWN',\n  /** Represents the `:+1:` emoji. */\n  ThumbsUp = 'THUMBS_UP'\n}\n\n/** An edge in a connection. */\nexport type ReactionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Reaction>;\n};\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroup = {\n  /** Identifies the emoji reaction. */\n  content: ReactionContent;\n  /** Identifies when the reaction was created. */\n  createdAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Reactors to the reaction subject with the emotion represented by this reaction group. */\n  reactors: ReactorConnection;\n  /** The subject that was reacted to. */\n  subject: Reactable;\n  /**\n   * Users who have reacted to the reaction subject with the emotion represented by this reaction group\n   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.\n   */\n  users: ReactingUserConnection;\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars['Boolean']['output'];\n};\n\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupReactorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupUsersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Ways in which lists of reactions can be ordered upon return. */\nexport type ReactionOrder = {\n  /** The direction in which to order reactions by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order reactions by. */\n  field: ReactionOrderField;\n};\n\n/** A list of fields that reactions can be ordered by. */\nexport enum ReactionOrderField {\n  /** Allows ordering a list of reactions by when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Types that can be assigned to reactions. */\nexport type Reactor = Bot | Mannequin | Organization | User;\n\n/** The connection type for Reactor. */\nexport type ReactorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reactor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents an author of a reaction. */\nexport type ReactorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The author of the reaction. */\n  node: Reactor;\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars['DateTime']['output'];\n};\n\n/** Represents a 'ready_for_review' event on a given pull request. */\nexport type ReadyForReviewEvent = Node & UniformResourceLocatable & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this ready for review event. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this ready for review event. */\n  url: Scalars['URI']['output'];\n};\n\n/** Represents a Git reference. */\nexport type Ref = Node & {\n  /** A list of pull requests with this ref as the head ref. */\n  associatedPullRequests: PullRequestConnection;\n  /** Branch protection rules for this ref */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */\n  compare?: Maybe<Comparison>;\n  id: Scalars['ID']['output'];\n  /** The ref name. */\n  name: Scalars['String']['output'];\n  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */\n  prefix: Scalars['String']['output'];\n  /** Branch protection rules that are viewable by non-admins */\n  refUpdateRule?: Maybe<RefUpdateRule>;\n  /** The repository the ref belongs to. */\n  repository: Repository;\n  /** The object the ref points to. Returns null when object does not exist. */\n  target?: Maybe<GitObject>;\n};\n\n\n/** Represents a Git reference. */\nexport type RefAssociatedPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  headRefName?: InputMaybe<Scalars['String']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n\n/** Represents a Git reference. */\nexport type RefCompareArgs = {\n  headRef: Scalars['String']['input'];\n};\n\n/** The connection type for Ref. */\nexport type RefConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RefEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Ref>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RefEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Ref>;\n};\n\n/** Parameters to be used for the ref_name condition */\nexport type RefNameConditionTarget = {\n  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']['output']>;\n  /**\n   * Array of ref names or patterns to include. One of these patterns must match\n   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the\n   * default branch or `~ALL` to include all branches.\n   */\n  include: Array<Scalars['String']['output']>;\n};\n\n/** Parameters to be used for the ref_name condition */\nexport type RefNameConditionTargetInput = {\n  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']['input']>;\n  /**\n   * Array of ref names or patterns to include. One of these patterns must match\n   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the\n   * default branch or `~ALL` to include all branches.\n   */\n  include: Array<Scalars['String']['input']>;\n};\n\n/** Ways in which lists of git refs can be ordered upon return. */\nexport type RefOrder = {\n  /** The direction in which to order refs by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order refs by. */\n  field: RefOrderField;\n};\n\n/** Properties by which ref connections can be ordered. */\nexport enum RefOrderField {\n  /** Order refs by their alphanumeric name */\n  Alphabetical = 'ALPHABETICAL',\n  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */\n  TagCommitDate = 'TAG_COMMIT_DATE'\n}\n\n/** A ref update rules for a viewer. */\nexport type RefUpdateRule = {\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars['Boolean']['output'];\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars['Boolean']['output'];\n  /** Can matching branches be created. */\n  blocksCreations: Scalars['Boolean']['output'];\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars['String']['output'];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars['Boolean']['output'];\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars['Boolean']['output'];\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars['Boolean']['output'];\n  /** Are commits required to be signed. */\n  requiresSignatures: Scalars['Boolean']['output'];\n  /** Is the viewer allowed to dismiss reviews. */\n  viewerAllowedToDismissReviews: Scalars['Boolean']['output'];\n  /** Can the viewer push to the branch */\n  viewerCanPush: Scalars['Boolean']['output'];\n};\n\n/** Represents a 'referenced' event on a given `ReferencedSubject`. */\nexport type ReferencedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the commit associated with the 'referenced' event. */\n  commit?: Maybe<Commit>;\n  /** Identifies the repository associated with the 'referenced' event. */\n  commitRepository: Repository;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']['output'];\n  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */\n  isDirectReference: Scalars['Boolean']['output'];\n  /** Object referenced by event. */\n  subject: ReferencedSubject;\n};\n\n/** Any referencable object */\nexport type ReferencedSubject = Issue | PullRequest;\n\n/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the verifiable domain to regenerate the verification token of. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The verification token that was generated. */\n  verificationToken?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of RejectDeployments */\nexport type RejectDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Optional comment for rejecting deployments */\n  comment?: InputMaybe<Scalars['String']['input']>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']['input']>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RejectDeployments */\nexport type RejectDeploymentsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>;\n};\n\n/** A release contains the content for a release. */\nexport type Release = Node & Reactable & UniformResourceLocatable & {\n  /** The author of the release */\n  author?: Maybe<User>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The description of the release. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The description of this release rendered to HTML. */\n  descriptionHTML?: Maybe<Scalars['HTML']['output']>;\n  id: Scalars['ID']['output'];\n  /** Whether or not the release is a draft */\n  isDraft: Scalars['Boolean']['output'];\n  /** Whether or not the release is the latest releast */\n  isLatest: Scalars['Boolean']['output'];\n  /** Whether or not the release is a prerelease */\n  isPrerelease: Scalars['Boolean']['output'];\n  /** A list of users mentioned in the release description */\n  mentions?: Maybe<UserConnection>;\n  /** The title of the release. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the release was created. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** List of releases assets which are dependent on this release. */\n  releaseAssets: ReleaseAssetConnection;\n  /** The repository that the release belongs to. */\n  repository: Repository;\n  /** The HTTP path for this issue */\n  resourcePath: Scalars['URI']['output'];\n  /** A description of the release, rendered to HTML without any links in it. */\n  shortDescriptionHTML?: Maybe<Scalars['HTML']['output']>;\n  /** The Git tag the release points to */\n  tag?: Maybe<Ref>;\n  /** The tag commit for this release. */\n  tagCommit?: Maybe<Commit>;\n  /** The name of the release's Git tag */\n  tagName: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this issue */\n  url: Scalars['URI']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseMentionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseReleaseAssetsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  name?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A release asset contains the content for a release asset. */\nexport type ReleaseAsset = Node & {\n  /** The asset's content-type */\n  contentType: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The number of times this asset was downloaded */\n  downloadCount: Scalars['Int']['output'];\n  /** Identifies the URL where you can download the release asset via the browser. */\n  downloadUrl: Scalars['URI']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the title of the release asset. */\n  name: Scalars['String']['output'];\n  /** Release that the asset is associated with */\n  release?: Maybe<Release>;\n  /** The size (in bytes) of the asset */\n  size: Scalars['Int']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The user that performed the upload */\n  uploadedBy: User;\n  /** Identifies the URL of the release asset. */\n  url: Scalars['URI']['output'];\n};\n\n/** The connection type for ReleaseAsset. */\nexport type ReleaseAssetConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseAssetEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReleaseAsset>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ReleaseAssetEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReleaseAsset>;\n};\n\n/** The connection type for Release. */\nexport type ReleaseConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Release>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ReleaseEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Release>;\n};\n\n/** Ways in which lists of releases can be ordered upon return. */\nexport type ReleaseOrder = {\n  /** The direction in which to order releases by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order releases by. */\n  field: ReleaseOrderField;\n};\n\n/** Properties by which release connections can be ordered. */\nexport enum ReleaseOrderField {\n  /** Order releases by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order releases alphabetically by name */\n  Name = 'NAME'\n}\n\n/** Autogenerated input type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignableInput = {\n  /** The id of the assignable object to remove assignees from. */\n  assignableId: Scalars['ID']['input'];\n  /** The id of users to remove as assignees. */\n  assigneeIds: Array<Scalars['ID']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignablePayload = {\n  /** The item that was unassigned. */\n  assignable?: Maybe<Assignable>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Enterprise ID from which to remove the administrator. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of the user to remove as an administrator. */\n  login: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminPayload = {\n  /** The user who was removed as an administrator. */\n  admin?: Maybe<User>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of removing an administrator. */\n  message?: Maybe<Scalars['String']['output']>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise from which to remove the identity provider. */\n  enterpriseId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The identity provider that was removed from the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseMember */\nexport type RemoveEnterpriseMemberInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise from which the user should be removed. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The ID of the user to remove from the enterprise. */\n  userId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseMember */\nexport type RemoveEnterpriseMemberPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** The user that was removed from the enterprise. */\n  user?: Maybe<User>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise from which the organization should be removed. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The ID of the organization to remove from the enterprise. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** The organization that was removed from the enterprise. */\n  organization?: Maybe<Organization>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of a member who will lose the support entitlement. */\n  login: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of removing the support entitlement. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ids of labels to remove. */\n  labelIds: Array<Scalars['ID']['input']>;\n  /** The id of the Labelable to remove labels from. */\n  labelableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelablePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The Labelable the labels were removed from. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the organization to remove the outside collaborator from. */\n  organizationId: Scalars['ID']['input'];\n  /** The ID of the outside collaborator to remove. */\n  userId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The user that was removed as an outside collaborator. */\n  removedUser?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveReaction */\nexport type RemoveReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the emoji reaction to remove. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveReaction */\nexport type RemoveReactionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>;\n  /** The reaction groups for the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>;\n};\n\n/** Autogenerated input type of RemoveStar */\nexport type RemoveStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Starrable ID to unstar. */\n  starrableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveStar */\nexport type RemoveStarPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The starrable. */\n  starrable?: Maybe<Starrable>;\n};\n\n/** Autogenerated input type of RemoveUpvote */\nexport type RemoveUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion or comment to remove upvote. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RemoveUpvote */\nexport type RemoveUpvotePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The votable subject. */\n  subject?: Maybe<Votable>;\n};\n\n/** Represents a 'removed_from_merge_queue' event on a given pull request. */\nexport type RemovedFromMergeQueueEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the before commit SHA for the 'removed_from_merge_queue' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The user who removed this Pull Request from the merge queue */\n  enqueuer?: Maybe<User>;\n  id: Scalars['ID']['output'];\n  /** The merge queue where this pull request was removed from. */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The reason this pull request was removed from the queue. */\n  reason?: Maybe<Scalars['String']['output']>;\n};\n\n/** Represents a 'removed_from_project' event on a given issue or pull request. */\nexport type RemovedFromProjectEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n};\n\n/** Represents a 'renamed' event on a given issue or pull request */\nexport type RenamedTitleEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the current title of the issue or pull request. */\n  currentTitle: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the previous title of the issue or pull request. */\n  previousTitle: Scalars['String']['output'];\n  /** Subject that was renamed. */\n  subject: RenamedTitleSubject;\n};\n\n/** An object which has a renamable title */\nexport type RenamedTitleSubject = Issue | PullRequest;\n\n/** Autogenerated input type of ReopenDiscussion */\nexport type ReopenDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the discussion to be reopened. */\n  discussionId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ReopenDiscussion */\nexport type ReopenDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion that was reopened. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of ReopenIssue */\nexport type ReopenIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the issue to be opened. */\n  issueId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ReopenIssue */\nexport type ReopenIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue that was opened. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of ReopenPullRequest */\nexport type ReopenPullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the pull request to be reopened. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ReopenPullRequest */\nexport type ReopenPullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that was reopened. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'reopened' event on any `Closable`. */\nexport type ReopenedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Object that was reopened. */\n  closable: Closable;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The reason the issue state was changed to open. */\n  stateReason?: Maybe<IssueStateReason>;\n};\n\n/** Audit log entry for a repo.access event. */\nexport type RepoAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoAccessAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoAccessAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.add_member event. */\nexport type RepoAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoAddMemberAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoAddMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.add_topic event. */\nexport type RepoAddTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.archived event. */\nexport type RepoArchivedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoArchivedAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoArchivedAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.change_merge_setting event. */\nexport type RepoChangeMergeSettingAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the change was to enable (true) or disable (false) the merge type */\n  isEnabled?: Maybe<Scalars['Boolean']['output']>;\n  /** The merge method affected by the change */\n  mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The merge options available for pull requests to this repository. */\nexport enum RepoChangeMergeSettingAuditEntryMergeType {\n  /** The pull request is added to the base branch in a merge commit. */\n  Merge = 'MERGE',\n  /** Commits from the pull request are added onto the base branch individually without a merge commit. */\n  Rebase = 'REBASE',\n  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */\n  Squash = 'SQUASH'\n}\n\n/** Audit log entry for a repo.config.disable_anonymous_git_access event. */\nexport type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.disable_collaborators_only event. */\nexport type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.disable_contributors_only event. */\nexport type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */\nexport type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.enable_anonymous_git_access event. */\nexport type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.enable_collaborators_only event. */\nexport type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.enable_contributors_only event. */\nexport type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */\nexport type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.lock_anonymous_git_access event. */\nexport type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */\nexport type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repo.create event. */\nexport type RepoCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The name of the parent repository for this forked repository. */\n  forkParentName?: Maybe<Scalars['String']['output']>;\n  /** The name of the root repository for this network. */\n  forkSourceName?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoCreateAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoCreateAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.destroy event. */\nexport type RepoDestroyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoDestroyAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoDestroyAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.remove_member event. */\nexport type RepoRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoRemoveMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.remove_topic event. */\nexport type RepoRemoveTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The reasons a piece of content can be reported or minimized. */\nexport enum ReportedContentClassifiers {\n  /** An abusive or harassing piece of content */\n  Abuse = 'ABUSE',\n  /** A duplicated piece of content */\n  Duplicate = 'DUPLICATE',\n  /** An irrelevant piece of content */\n  OffTopic = 'OFF_TOPIC',\n  /** An outdated piece of content */\n  Outdated = 'OUTDATED',\n  /** The content has been resolved */\n  Resolved = 'RESOLVED',\n  /** A spammy piece of content */\n  Spam = 'SPAM'\n}\n\n/** A repository contains the content for a project. */\nexport type Repository = Node & PackageOwner & ProjectOwner & ProjectV2Recent & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable & {\n  /**\n   * Whether or not a pull request head branch that is behind its base branch can\n   * always be updated even if it is not required to be up to date before merging.\n   */\n  allowUpdateBranch: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the repository was archived. */\n  archivedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of users that can be assigned to issues in this repository. */\n  assignableUsers: UserConnection;\n  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */\n  autoMergeAllowed: Scalars['Boolean']['output'];\n  /** A list of branch protection rules for this repository. */\n  branchProtectionRules: BranchProtectionRuleConnection;\n  /** Returns the code of conduct for this repository */\n  codeOfConduct?: Maybe<CodeOfConduct>;\n  /** Information extracted from the repository's `CODEOWNERS` file. */\n  codeowners?: Maybe<RepositoryCodeowners>;\n  /** A list of collaborators associated with the repository. */\n  collaborators?: Maybe<RepositoryCollaboratorConnection>;\n  /** A list of commit comments associated with the repository. */\n  commitComments: CommitCommentConnection;\n  /** Returns a list of contact links associated to the repository */\n  contactLinks?: Maybe<Array<RepositoryContactLink>>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The Ref associated with the repository's default branch. */\n  defaultBranchRef?: Maybe<Ref>;\n  /** Whether or not branches are automatically deleted when merged in this repository. */\n  deleteBranchOnMerge: Scalars['Boolean']['output'];\n  /** A list of deploy keys that are on this repository. */\n  deployKeys: DeployKeyConnection;\n  /** Deployments associated with the repository */\n  deployments: DeploymentConnection;\n  /** The description of the repository. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The description of the repository rendered to HTML. */\n  descriptionHTML: Scalars['HTML']['output'];\n  /** Returns a single discussion from the current repository by number. */\n  discussion?: Maybe<Discussion>;\n  /** A list of discussion categories that are available in the repository. */\n  discussionCategories: DiscussionCategoryConnection;\n  /** A discussion category by slug. */\n  discussionCategory?: Maybe<DiscussionCategory>;\n  /** A list of discussions that have been opened in the repository. */\n  discussions: DiscussionConnection;\n  /** The number of kilobytes this repository occupies on disk. */\n  diskUsage?: Maybe<Scalars['Int']['output']>;\n  /** Returns a single active environment from the current repository by name. */\n  environment?: Maybe<Environment>;\n  /** A list of environments that are in this repository. */\n  environments: EnvironmentConnection;\n  /** Returns how many forks there are of this repository in the whole network. */\n  forkCount: Scalars['Int']['output'];\n  /** Whether this repository allows forks. */\n  forkingAllowed: Scalars['Boolean']['output'];\n  /** A list of direct forked repositories. */\n  forks: RepositoryConnection;\n  /** The funding links for this repository */\n  fundingLinks: Array<FundingLink>;\n  /** Indicates if the repository has the Discussions feature enabled. */\n  hasDiscussionsEnabled: Scalars['Boolean']['output'];\n  /** Indicates if the repository has issues feature enabled. */\n  hasIssuesEnabled: Scalars['Boolean']['output'];\n  /** Indicates if the repository has the Projects feature enabled. */\n  hasProjectsEnabled: Scalars['Boolean']['output'];\n  /** Whether vulnerability alerts are enabled for the repository. */\n  hasVulnerabilityAlertsEnabled: Scalars['Boolean']['output'];\n  /** Indicates if the repository has wiki feature enabled. */\n  hasWikiEnabled: Scalars['Boolean']['output'];\n  /** The repository's URL. */\n  homepageUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The interaction ability settings for this repository. */\n  interactionAbility?: Maybe<RepositoryInteractionAbility>;\n  /** Indicates if the repository is unmaintained. */\n  isArchived: Scalars['Boolean']['output'];\n  /** Returns true if blank issue creation is allowed */\n  isBlankIssuesEnabled: Scalars['Boolean']['output'];\n  /** Returns whether or not this repository disabled. */\n  isDisabled: Scalars['Boolean']['output'];\n  /** Returns whether or not this repository is empty. */\n  isEmpty: Scalars['Boolean']['output'];\n  /** Identifies if the repository is a fork. */\n  isFork: Scalars['Boolean']['output'];\n  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n  isInOrganization: Scalars['Boolean']['output'];\n  /** Indicates if the repository has been locked or not. */\n  isLocked: Scalars['Boolean']['output'];\n  /** Identifies if the repository is a mirror. */\n  isMirror: Scalars['Boolean']['output'];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean']['output'];\n  /** Returns true if this repository has a security policy */\n  isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']['output']>;\n  /** Identifies if the repository is a template that can be used to generate new repositories. */\n  isTemplate: Scalars['Boolean']['output'];\n  /** Is this repository a user configuration repository? */\n  isUserConfigurationRepository: Scalars['Boolean']['output'];\n  /** Returns a single issue from the current repository by number. */\n  issue?: Maybe<Issue>;\n  /** Returns a single issue-like object from the current repository by number. */\n  issueOrPullRequest?: Maybe<IssueOrPullRequest>;\n  /** Returns a list of issue templates associated to the repository */\n  issueTemplates?: Maybe<Array<IssueTemplate>>;\n  /** A list of issues that have been opened in the repository. */\n  issues: IssueConnection;\n  /** Returns a single label by name */\n  label?: Maybe<Label>;\n  /** A list of labels associated with the repository. */\n  labels?: Maybe<LabelConnection>;\n  /** A list containing a breakdown of the language composition of the repository. */\n  languages?: Maybe<LanguageConnection>;\n  /** Get the latest release for the repository if one exists. */\n  latestRelease?: Maybe<Release>;\n  /** The license associated with the repository */\n  licenseInfo?: Maybe<License>;\n  /** The reason the repository has been locked. */\n  lockReason?: Maybe<RepositoryLockReason>;\n  /** A list of Users that can be mentioned in the context of the repository. */\n  mentionableUsers: UserConnection;\n  /** Whether or not PRs are merged with a merge commit on this repository. */\n  mergeCommitAllowed: Scalars['Boolean']['output'];\n  /** How the default commit message will be generated when merging a pull request. */\n  mergeCommitMessage: MergeCommitMessage;\n  /** How the default commit title will be generated when merging a pull request. */\n  mergeCommitTitle: MergeCommitTitle;\n  /** The merge queue for a specified branch, otherwise the default branch if not provided. */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** Returns a single milestone from the current repository by number. */\n  milestone?: Maybe<Milestone>;\n  /** A list of milestones associated with the repository. */\n  milestones?: Maybe<MilestoneConnection>;\n  /** The repository's original mirror URL. */\n  mirrorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The name of the repository. */\n  name: Scalars['String']['output'];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String']['output'];\n  /** A Git object in the repository */\n  object?: Maybe<GitObject>;\n  /** The image used to represent this repository in Open Graph data. */\n  openGraphImageUrl: Scalars['URI']['output'];\n  /** The User owner of the repository. */\n  owner: RepositoryOwner;\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n  /** The repository parent, if this is a fork. */\n  parent?: Maybe<Repository>;\n  /** A list of discussions that have been pinned in this repository. */\n  pinnedDiscussions: PinnedDiscussionConnection;\n  /** A list of pinned issues for this repository. */\n  pinnedIssues?: Maybe<PinnedIssueConnection>;\n  /** The primary language of the repository's code. */\n  primaryLanguage?: Maybe<Language>;\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** Finds and returns the Project according to the provided Project number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing the repository's projects */\n  projectsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL listing the repository's projects */\n  projectsUrl: Scalars['URI']['output'];\n  /** List of projects linked to this repository. */\n  projectsV2: ProjectV2Connection;\n  /** Returns a single pull request from the current repository by number. */\n  pullRequest?: Maybe<PullRequest>;\n  /** Returns a list of pull request templates associated to the repository */\n  pullRequestTemplates?: Maybe<Array<PullRequestTemplate>>;\n  /** A list of pull requests that have been opened in the repository. */\n  pullRequests: PullRequestConnection;\n  /** Identifies the date and time when the repository was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Whether or not rebase-merging is enabled on this repository. */\n  rebaseMergeAllowed: Scalars['Boolean']['output'];\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n  /** Fetch a given ref from the repository */\n  ref?: Maybe<Ref>;\n  /** Fetch a list of refs from the repository */\n  refs?: Maybe<RefConnection>;\n  /** Lookup a single release given various criteria. */\n  release?: Maybe<Release>;\n  /** List of releases which are dependent on this repository. */\n  releases: ReleaseConnection;\n  /** A list of applied repository-topic associations for this repository. */\n  repositoryTopics: RepositoryTopicConnection;\n  /** The HTTP path for this repository */\n  resourcePath: Scalars['URI']['output'];\n  /** Returns a single ruleset from the current repository by ID. */\n  ruleset?: Maybe<RepositoryRuleset>;\n  /** A list of rulesets for this repository. */\n  rulesets?: Maybe<RepositoryRulesetConnection>;\n  /** The security policy URL. */\n  securityPolicyUrl?: Maybe<Scalars['URI']['output']>;\n  /** A description of the repository, rendered to HTML without any links in it. */\n  shortDescriptionHTML: Scalars['HTML']['output'];\n  /** Whether or not squash-merging is enabled on this repository. */\n  squashMergeAllowed: Scalars['Boolean']['output'];\n  /** How the default commit message will be generated when squash merging a pull request. */\n  squashMergeCommitMessage: SquashMergeCommitMessage;\n  /** How the default commit title will be generated when squash merging a pull request. */\n  squashMergeCommitTitle: SquashMergeCommitTitle;\n  /**\n   * Whether a squash merge commit can use the pull request title as default.\n   * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.\n   */\n  squashPrTitleUsedAsDefault: Scalars['Boolean']['output'];\n  /** The SSH URL to clone this repository */\n  sshUrl: Scalars['GitSSHRemote']['output'];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int']['output'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /**\n   * Returns a list of all submodules in this repository parsed from the\n   * .gitmodules file as of the default branch's HEAD commit.\n   */\n  submodules: SubmoduleConnection;\n  /** Temporary authentication token for cloning this repository. */\n  tempCloneToken?: Maybe<Scalars['String']['output']>;\n  /** The repository from which this repository was generated, if any. */\n  templateRepository?: Maybe<Repository>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this repository */\n  url: Scalars['URI']['output'];\n  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n  usesCustomOpenGraphImage: Scalars['Boolean']['output'];\n  /** Indicates whether the viewer has admin permissions on this repository. */\n  viewerCanAdminister: Scalars['Boolean']['output'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Indicates whether the viewer can update the topics of this repository. */\n  viewerCanUpdateTopics: Scalars['Boolean']['output'];\n  /** The last commit email for the viewer. */\n  viewerDefaultCommitEmail?: Maybe<Scalars['String']['output']>;\n  /** The last used merge method by the viewer or the default for the repository. */\n  viewerDefaultMergeMethod: PullRequestMergeMethod;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean']['output'];\n  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */\n  viewerPermission?: Maybe<RepositoryPermission>;\n  /** A list of emails this viewer can commit with. */\n  viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']['output']>>;\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n  /** Returns a single vulnerability alert from the current repository by number. */\n  vulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;\n  /** A list of vulnerability alerts that are on this repository. */\n  vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>;\n  /** A list of users watching the repository. */\n  watchers: UserConnection;\n  /** Whether contributors are required to sign off on web-based commits in this repository. */\n  webCommitSignoffRequired: Scalars['Boolean']['output'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryAssignableUsersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryBranchProtectionRulesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryCodeownersArgs = {\n  refName?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryCollaboratorsArgs = {\n  affiliation?: InputMaybe<CollaboratorAffiliation>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  login?: InputMaybe<Scalars['String']['input']>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryCommitCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeployKeysArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeploymentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  environments?: InputMaybe<Array<Scalars['String']['input']>>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionCategoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterByAssignable?: InputMaybe<Scalars['Boolean']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionCategoryArgs = {\n  slug: Scalars['String']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  categoryId?: InputMaybe<Scalars['ID']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryForksArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueOrPullRequestArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LabelOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryLanguagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<LanguageOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMentionableUsersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMergeQueueArgs = {\n  branch?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestoneArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestonesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<MilestoneOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  states?: InputMaybe<Array<MilestoneState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryObjectArgs = {\n  expression?: InputMaybe<Scalars['String']['input']>;\n  oid?: InputMaybe<Scalars['GitObjectID']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPackagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']['input']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  headRefName?: InputMaybe<Scalars['String']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefArgs = {\n  qualifiedName: Scalars['String']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  direction?: InputMaybe<OrderDirection>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RefOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  refPrefix: Scalars['String']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleaseArgs = {\n  tagName: Scalars['String']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleasesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReleaseOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRepositoryTopicsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRulesetArgs = {\n  databaseId: Scalars['Int']['input'];\n  includeParents?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRulesetsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeParents?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryStargazersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositorySubmodulesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryVulnerabilityAlertArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryVulnerabilityAlertsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  dependencyScopes?: InputMaybe<Array<RepositoryVulnerabilityAlertDependencyScope>>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  states?: InputMaybe<Array<RepositoryVulnerabilityAlertState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryWatchersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The affiliation of a user to a repository */\nexport enum RepositoryAffiliation {\n  /** Repositories that the user has been added to as a collaborator. */\n  Collaborator = 'COLLABORATOR',\n  /**\n   * Repositories that the user has access to through being a member of an\n   * organization. This includes every repository on every team that the user is on.\n   */\n  OrganizationMember = 'ORGANIZATION_MEMBER',\n  /** Repositories that are owned by the authenticated user. */\n  Owner = 'OWNER'\n}\n\n/** Metadata for an audit entry with action repo.* */\nexport type RepositoryAuditEntryData = {\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Information extracted from a repository's `CODEOWNERS` file. */\nexport type RepositoryCodeowners = {\n  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */\n  errors: Array<RepositoryCodeownersError>;\n};\n\n/** An error in a `CODEOWNERS` file. */\nexport type RepositoryCodeownersError = {\n  /** The column number where the error occurs. */\n  column: Scalars['Int']['output'];\n  /** A short string describing the type of error. */\n  kind: Scalars['String']['output'];\n  /** The line number where the error occurs. */\n  line: Scalars['Int']['output'];\n  /** A complete description of the error, combining information from other fields. */\n  message: Scalars['String']['output'];\n  /** The path to the file when the error occurs. */\n  path: Scalars['String']['output'];\n  /** The content of the line where the error occurs. */\n  source: Scalars['String']['output'];\n  /** A suggestion of how to fix the error. */\n  suggestion?: Maybe<Scalars['String']['output']>;\n};\n\n/** The connection type for User. */\nexport type RepositoryCollaboratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryCollaboratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a user who is a collaborator of a repository. */\nexport type RepositoryCollaboratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  node: User;\n  /** The permission the user has on the repository. */\n  permission: RepositoryPermission;\n  /** A list of sources for the user's access to the repository. */\n  permissionSources?: Maybe<Array<PermissionSource>>;\n};\n\n/** A list of repositories owned by the subject. */\nexport type RepositoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /** The total size in kilobytes of all repositories in the connection. */\n  totalDiskUsage: Scalars['Int']['output'];\n};\n\n/** A repository contact link. */\nexport type RepositoryContactLink = {\n  /** The contact link purpose. */\n  about: Scalars['String']['output'];\n  /** The contact link name. */\n  name: Scalars['String']['output'];\n  /** The contact link URL. */\n  url: Scalars['URI']['output'];\n};\n\n/** The reason a repository is listed as 'contributed'. */\nexport enum RepositoryContributionType {\n  /** Created a commit */\n  Commit = 'COMMIT',\n  /** Created an issue */\n  Issue = 'ISSUE',\n  /** Created a pull request */\n  PullRequest = 'PULL_REQUEST',\n  /** Reviewed a pull request */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** Created the repository */\n  Repository = 'REPOSITORY'\n}\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthor = {\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n};\n\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  answered?: InputMaybe<Scalars['Boolean']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthor = {\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n};\n\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** An edge in a connection. */\nexport type RepositoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Repository>;\n};\n\n/** Parameters to be used for the repository_id condition */\nexport type RepositoryIdConditionTarget = {\n  /** One of these repo IDs must match the repo. */\n  repositoryIds: Array<Scalars['ID']['output']>;\n};\n\n/** Parameters to be used for the repository_id condition */\nexport type RepositoryIdConditionTargetInput = {\n  /** One of these repo IDs must match the repo. */\n  repositoryIds: Array<Scalars['ID']['input']>;\n};\n\n/** A subset of repository info. */\nexport type RepositoryInfo = {\n  /** Identifies the date and time when the repository was archived. */\n  archivedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The description of the repository. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The description of the repository rendered to HTML. */\n  descriptionHTML: Scalars['HTML']['output'];\n  /** Returns how many forks there are of this repository in the whole network. */\n  forkCount: Scalars['Int']['output'];\n  /** Indicates if the repository has the Discussions feature enabled. */\n  hasDiscussionsEnabled: Scalars['Boolean']['output'];\n  /** Indicates if the repository has issues feature enabled. */\n  hasIssuesEnabled: Scalars['Boolean']['output'];\n  /** Indicates if the repository has the Projects feature enabled. */\n  hasProjectsEnabled: Scalars['Boolean']['output'];\n  /** Indicates if the repository has wiki feature enabled. */\n  hasWikiEnabled: Scalars['Boolean']['output'];\n  /** The repository's URL. */\n  homepageUrl?: Maybe<Scalars['URI']['output']>;\n  /** Indicates if the repository is unmaintained. */\n  isArchived: Scalars['Boolean']['output'];\n  /** Identifies if the repository is a fork. */\n  isFork: Scalars['Boolean']['output'];\n  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n  isInOrganization: Scalars['Boolean']['output'];\n  /** Indicates if the repository has been locked or not. */\n  isLocked: Scalars['Boolean']['output'];\n  /** Identifies if the repository is a mirror. */\n  isMirror: Scalars['Boolean']['output'];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean']['output'];\n  /** Identifies if the repository is a template that can be used to generate new repositories. */\n  isTemplate: Scalars['Boolean']['output'];\n  /** The license associated with the repository */\n  licenseInfo?: Maybe<License>;\n  /** The reason the repository has been locked. */\n  lockReason?: Maybe<RepositoryLockReason>;\n  /** The repository's original mirror URL. */\n  mirrorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The name of the repository. */\n  name: Scalars['String']['output'];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String']['output'];\n  /** The image used to represent this repository in Open Graph data. */\n  openGraphImageUrl: Scalars['URI']['output'];\n  /** The User owner of the repository. */\n  owner: RepositoryOwner;\n  /** Identifies the date and time when the repository was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The HTTP path for this repository */\n  resourcePath: Scalars['URI']['output'];\n  /** A description of the repository, rendered to HTML without any links in it. */\n  shortDescriptionHTML: Scalars['HTML']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this repository */\n  url: Scalars['URI']['output'];\n  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n  usesCustomOpenGraphImage: Scalars['Boolean']['output'];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n\n/** A subset of repository info. */\nexport type RepositoryInfoShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Repository interaction limit that applies to this object. */\nexport type RepositoryInteractionAbility = {\n  /** The time the currently active limit expires. */\n  expiresAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The current limit that is enabled on this object. */\n  limit: RepositoryInteractionLimit;\n  /** The origin of the currently active interaction limit. */\n  origin: RepositoryInteractionLimitOrigin;\n};\n\n/** A repository interaction limit. */\nexport enum RepositoryInteractionLimit {\n  /** Users that are not collaborators will not be able to interact with the repository. */\n  CollaboratorsOnly = 'COLLABORATORS_ONLY',\n  /** Users that have not previously committed to a repository\u2019s default branch will be unable to interact with the repository. */\n  ContributorsOnly = 'CONTRIBUTORS_ONLY',\n  /** Users that have recently created their account will be unable to interact with the repository. */\n  ExistingUsers = 'EXISTING_USERS',\n  /** No interaction limits are enabled. */\n  NoLimit = 'NO_LIMIT'\n}\n\n/** The length for a repository interaction limit to be enabled for. */\nexport enum RepositoryInteractionLimitExpiry {\n  /** The interaction limit will expire after 1 day. */\n  OneDay = 'ONE_DAY',\n  /** The interaction limit will expire after 1 month. */\n  OneMonth = 'ONE_MONTH',\n  /** The interaction limit will expire after 1 week. */\n  OneWeek = 'ONE_WEEK',\n  /** The interaction limit will expire after 6 months. */\n  SixMonths = 'SIX_MONTHS',\n  /** The interaction limit will expire after 3 days. */\n  ThreeDays = 'THREE_DAYS'\n}\n\n/** Indicates where an interaction limit is configured. */\nexport enum RepositoryInteractionLimitOrigin {\n  /** A limit that is configured at the organization level. */\n  Organization = 'ORGANIZATION',\n  /** A limit that is configured at the repository level. */\n  Repository = 'REPOSITORY',\n  /** A limit that is configured at the user-wide level. */\n  User = 'USER'\n}\n\n/** An invitation for a user to be added to a repository. */\nexport type RepositoryInvitation = Node & {\n  /** The email address that received the invitation. */\n  email?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The user who received the invitation. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter: User;\n  /** The permalink for this repository invitation. */\n  permalink: Scalars['URI']['output'];\n  /** The permission granted on this repository by this invitation. */\n  permission: RepositoryPermission;\n  /** The Repository the user is invited to. */\n  repository?: Maybe<RepositoryInfo>;\n};\n\n/** A list of repository invitations. */\nexport type RepositoryInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryInvitation>;\n};\n\n/** Ordering options for repository invitation connections. */\nexport type RepositoryInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repository invitations by. */\n  field: RepositoryInvitationOrderField;\n};\n\n/** Properties by which repository invitation connections can be ordered. */\nexport enum RepositoryInvitationOrderField {\n  /** Order repository invitations by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible reasons a given repository could be in a locked state. */\nexport enum RepositoryLockReason {\n  /** The repository is locked due to a billing related reason. */\n  Billing = 'BILLING',\n  /** The repository is locked due to a migration. */\n  Migrating = 'MIGRATING',\n  /** The repository is locked due to a move. */\n  Moving = 'MOVING',\n  /** The repository is locked due to a rename. */\n  Rename = 'RENAME',\n  /** The repository is locked due to a trade controls related reason. */\n  TradeRestriction = 'TRADE_RESTRICTION'\n}\n\n/** A GitHub Enterprise Importer (GEI) repository migration. */\nexport type RepositoryMigration = Migration & Node & {\n  /** The migration flag to continue on error. */\n  continueOnError: Scalars['Boolean']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['String']['output']>;\n  /** The reason the migration failed. */\n  failureReason?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** The URL for the migration log (expires 1 day after migration completes). */\n  migrationLogUrl?: Maybe<Scalars['URI']['output']>;\n  /** The migration source. */\n  migrationSource: MigrationSource;\n  /** The target repository name. */\n  repositoryName: Scalars['String']['output'];\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  sourceUrl: Scalars['URI']['output'];\n  /** The migration state. */\n  state: MigrationState;\n  /**\n   * The number of warnings encountered for this migration. To review the warnings,\n   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).\n   */\n  warningsCount: Scalars['Int']['output'];\n};\n\n/** The connection type for RepositoryMigration. */\nexport type RepositoryMigrationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryMigrationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryMigration>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a repository migration. */\nexport type RepositoryMigrationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryMigration>;\n};\n\n/** Ordering options for repository migrations. */\nexport type RepositoryMigrationOrder = {\n  /** The ordering direction. */\n  direction: RepositoryMigrationOrderDirection;\n  /** The field to order repository migrations by. */\n  field: RepositoryMigrationOrderField;\n};\n\n/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */\nexport enum RepositoryMigrationOrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC'\n}\n\n/** Properties by which repository migrations can be ordered. */\nexport enum RepositoryMigrationOrderField {\n  /** Order mannequins why when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Parameters to be used for the repository_name condition */\nexport type RepositoryNameConditionTarget = {\n  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']['output']>;\n  /**\n   * Array of repository names or patterns to include. One of these patterns must\n   * match for the condition to pass. Also accepts `~ALL` to include all repositories.\n   */\n  include: Array<Scalars['String']['output']>;\n  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */\n  protected: Scalars['Boolean']['output'];\n};\n\n/** Parameters to be used for the repository_name condition */\nexport type RepositoryNameConditionTargetInput = {\n  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']['input']>;\n  /**\n   * Array of repository names or patterns to include. One of these patterns must\n   * match for the condition to pass. Also accepts `~ALL` to include all repositories.\n   */\n  include: Array<Scalars['String']['input']>;\n  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */\n  protected?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Represents a object that belongs to a repository. */\nexport type RepositoryNode = {\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n/** Ordering options for repository connections */\nexport type RepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: RepositoryOrderField;\n};\n\n/** Properties by which repository connections can be ordered. */\nexport enum RepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwner = {\n  /** A URL pointing to the owner's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  id: Scalars['ID']['output'];\n  /** The username used to login. */\n  login: Scalars['String']['output'];\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** The HTTP URL for the owner. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for the owner. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isArchived?: InputMaybe<Scalars['Boolean']['input']>;\n  isFork?: InputMaybe<Scalars['Boolean']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']['input']>;\n  name: Scalars['String']['input'];\n};\n\n/** The access level to a repository */\nexport enum RepositoryPermission {\n  /**\n   * Can read, clone, and push to this repository. Can also manage issues, pull\n   * requests, and repository settings, including adding collaborators\n   */\n  Admin = 'ADMIN',\n  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */\n  Maintain = 'MAINTAIN',\n  /** Can read and clone this repository. Can also open and comment on issues and pull requests */\n  Read = 'READ',\n  /** Can read and clone this repository. Can also manage issues and pull requests */\n  Triage = 'TRIAGE',\n  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */\n  Write = 'WRITE'\n}\n\n/** The privacy of a repository */\nexport enum RepositoryPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC'\n}\n\n/** A repository rule. */\nexport type RepositoryRule = Node & {\n  id: Scalars['ID']['output'];\n  /** The parameters for this rule. */\n  parameters?: Maybe<RuleParameters>;\n  /** The type of rule. */\n  type: RepositoryRuleType;\n};\n\n/** Set of conditions that determine if a ruleset will evaluate */\nexport type RepositoryRuleConditions = {\n  /** Configuration for the ref_name condition */\n  refName?: Maybe<RefNameConditionTarget>;\n  /** Configuration for the repository_id condition */\n  repositoryId?: Maybe<RepositoryIdConditionTarget>;\n  /** Configuration for the repository_name condition */\n  repositoryName?: Maybe<RepositoryNameConditionTarget>;\n};\n\n/** Specifies the conditions required for a ruleset to evaluate */\nexport type RepositoryRuleConditionsInput = {\n  /** Configuration for the ref_name condition */\n  refName?: InputMaybe<RefNameConditionTargetInput>;\n  /** Configuration for the repository_id condition */\n  repositoryId?: InputMaybe<RepositoryIdConditionTargetInput>;\n  /** Configuration for the repository_name condition */\n  repositoryName?: InputMaybe<RepositoryNameConditionTargetInput>;\n};\n\n/** The connection type for RepositoryRule. */\nexport type RepositoryRuleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryRuleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryRule>;\n};\n\n/** Specifies the attributes for a new or updated rule. */\nexport type RepositoryRuleInput = {\n  /** Optional ID of this rule when updating */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The parameters for the rule. */\n  parameters?: InputMaybe<RuleParametersInput>;\n  /** The type of rule to create. */\n  type: RepositoryRuleType;\n};\n\n/** The rule types supported in rulesets */\nexport enum RepositoryRuleType {\n  /** Branch name pattern */\n  BranchNamePattern = 'BRANCH_NAME_PATTERN',\n  /** Committer email pattern */\n  CommitterEmailPattern = 'COMMITTER_EMAIL_PATTERN',\n  /** Commit author email pattern */\n  CommitAuthorEmailPattern = 'COMMIT_AUTHOR_EMAIL_PATTERN',\n  /** Commit message pattern */\n  CommitMessagePattern = 'COMMIT_MESSAGE_PATTERN',\n  /** Only allow users with bypass permission to create matching refs. */\n  Creation = 'CREATION',\n  /** Only allow users with bypass permissions to delete matching refs. */\n  Deletion = 'DELETION',\n  /** Prevent users with push access from force pushing to branches. */\n  NonFastForward = 'NON_FAST_FORWARD',\n  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */\n  PullRequest = 'PULL_REQUEST',\n  /**\n   * Choose which environments must be successfully deployed to before branches can\n   * be merged into a branch that matches this rule.\n   */\n  RequiredDeployments = 'REQUIRED_DEPLOYMENTS',\n  /** Prevent merge commits from being pushed to matching branches. */\n  RequiredLinearHistory = 'REQUIRED_LINEAR_HISTORY',\n  /** Commits pushed to matching branches must have verified signatures. */\n  RequiredSignatures = 'REQUIRED_SIGNATURES',\n  /**\n   * Choose which status checks must pass before branches can be merged into a\n   * branch that matches this rule. When enabled, commits must first be pushed to\n   * another branch, then merged or pushed directly to a branch that matches this\n   * rule after status checks have passed.\n   */\n  RequiredStatusChecks = 'REQUIRED_STATUS_CHECKS',\n  /** Tag name pattern */\n  TagNamePattern = 'TAG_NAME_PATTERN',\n  /** Only allow users with bypass permission to update matching refs. */\n  Update = 'UPDATE'\n}\n\n/** A repository ruleset. */\nexport type RepositoryRuleset = Node & {\n  /** The actors that can bypass this ruleset */\n  bypassActors?: Maybe<RepositoryRulesetBypassActorConnection>;\n  /** The set of conditions that must evaluate to true for this ruleset to apply */\n  conditions: RepositoryRuleConditions;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The enforcement level of this ruleset */\n  enforcement: RuleEnforcement;\n  id: Scalars['ID']['output'];\n  /** Name of the ruleset. */\n  name: Scalars['String']['output'];\n  /** List of rules. */\n  rules?: Maybe<RepositoryRuleConnection>;\n  /** Source of ruleset. */\n  source: RuleSource;\n  /** Target of the ruleset. */\n  target?: Maybe<RepositoryRulesetTarget>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n\n/** A repository ruleset. */\nexport type RepositoryRulesetBypassActorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A repository ruleset. */\nexport type RepositoryRulesetRulesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<RepositoryRuleType>;\n};\n\n/** A team or app that has the ability to bypass a rules defined on a ruleset */\nexport type RepositoryRulesetBypassActor = Node & {\n  /** The actor that can bypass rules. */\n  actor?: Maybe<BypassActor>;\n  /** The mode for the bypass actor */\n  bypassMode?: Maybe<RepositoryRulesetBypassActorBypassMode>;\n  id: Scalars['ID']['output'];\n  /** This actor represents the ability for an organization admin to bypass */\n  organizationAdmin: Scalars['Boolean']['output'];\n  /** If the actor is a repository role, the repository role's ID that can bypass */\n  repositoryRoleDatabaseId?: Maybe<Scalars['Int']['output']>;\n  /** If the actor is a repository role, the repository role's name that can bypass */\n  repositoryRoleName?: Maybe<Scalars['String']['output']>;\n  /** Identifies the ruleset associated with the allowed actor */\n  repositoryRuleset?: Maybe<RepositoryRuleset>;\n};\n\n/** The bypass mode for a specific actor on a ruleset. */\nexport enum RepositoryRulesetBypassActorBypassMode {\n  /** The actor can always bypass rules */\n  Always = 'ALWAYS',\n  /** The actor can only bypass rules via a pull request */\n  PullRequest = 'PULL_REQUEST'\n}\n\n/** The connection type for RepositoryRulesetBypassActor. */\nexport type RepositoryRulesetBypassActorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryRulesetBypassActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryRulesetBypassActor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryRulesetBypassActorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryRulesetBypassActor>;\n};\n\n/**\n * Specifies the attributes for a new or updated ruleset bypass actor. Only one of\n * `actor_id`, `repository_role_database_id`, or `organization_admin` should be specified.\n */\nexport type RepositoryRulesetBypassActorInput = {\n  /** For Team and Integration bypasses, the Team or Integration ID */\n  actorId?: InputMaybe<Scalars['ID']['input']>;\n  /** The bypass mode for this actor. */\n  bypassMode: RepositoryRulesetBypassActorBypassMode;\n  /** For org admin bupasses, true */\n  organizationAdmin?: InputMaybe<Scalars['Boolean']['input']>;\n  /** For role bypasses, the role database ID */\n  repositoryRoleDatabaseId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for RepositoryRuleset. */\nexport type RepositoryRulesetConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryRulesetEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryRuleset>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryRulesetEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryRuleset>;\n};\n\n/** The targets supported for rulesets */\nexport enum RepositoryRulesetTarget {\n  /** Branch */\n  Branch = 'BRANCH',\n  /** Tag */\n  Tag = 'TAG'\n}\n\n/** A repository-topic connects a repository to a topic. */\nexport type RepositoryTopic = Node & UniformResourceLocatable & {\n  id: Scalars['ID']['output'];\n  /** The HTTP path for this repository-topic. */\n  resourcePath: Scalars['URI']['output'];\n  /** The topic. */\n  topic: Topic;\n  /** The HTTP URL for this repository-topic. */\n  url: Scalars['URI']['output'];\n};\n\n/** The connection type for RepositoryTopic. */\nexport type RepositoryTopicConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryTopicEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryTopic>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryTopicEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryTopic>;\n};\n\n/** The repository's visibility level. */\nexport enum RepositoryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repository_visibility_change.disable event. */\nexport type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a repository_visibility_change.enable event. */\nexport type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']['output']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']['output']>;\n  id: Scalars['ID']['output'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */\nexport type RepositoryVulnerabilityAlert = Node & RepositoryNode & {\n  /** When was the alert auto-dismissed? */\n  autoDismissedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** When was the alert created? */\n  createdAt: Scalars['DateTime']['output'];\n  /** The associated Dependabot update */\n  dependabotUpdate?: Maybe<DependabotUpdate>;\n  /** The scope of an alert's dependency */\n  dependencyScope?: Maybe<RepositoryVulnerabilityAlertDependencyScope>;\n  /** Comment explaining the reason the alert was dismissed */\n  dismissComment?: Maybe<Scalars['String']['output']>;\n  /** The reason the alert was dismissed */\n  dismissReason?: Maybe<Scalars['String']['output']>;\n  /** When was the alert dismissed? */\n  dismissedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The user who dismissed the alert */\n  dismisser?: Maybe<User>;\n  /** When was the alert fixed? */\n  fixedAt?: Maybe<Scalars['DateTime']['output']>;\n  id: Scalars['ID']['output'];\n  /** Identifies the alert number. */\n  number: Scalars['Int']['output'];\n  /** The associated repository */\n  repository: Repository;\n  /** The associated security advisory */\n  securityAdvisory?: Maybe<SecurityAdvisory>;\n  /** The associated security vulnerability */\n  securityVulnerability?: Maybe<SecurityVulnerability>;\n  /** Identifies the state of the alert. */\n  state: RepositoryVulnerabilityAlertState;\n  /** The vulnerable manifest filename */\n  vulnerableManifestFilename: Scalars['String']['output'];\n  /** The vulnerable manifest path */\n  vulnerableManifestPath: Scalars['String']['output'];\n  /** The vulnerable requirements */\n  vulnerableRequirements?: Maybe<Scalars['String']['output']>;\n};\n\n/** The connection type for RepositoryVulnerabilityAlert. */\nexport type RepositoryVulnerabilityAlertConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryVulnerabilityAlertEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryVulnerabilityAlert>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** The possible scopes of an alert's dependency. */\nexport enum RepositoryVulnerabilityAlertDependencyScope {\n  /** A dependency that is only used in development */\n  Development = 'DEVELOPMENT',\n  /** A dependency that is leveraged during application runtime */\n  Runtime = 'RUNTIME'\n}\n\n/** An edge in a connection. */\nexport type RepositoryVulnerabilityAlertEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryVulnerabilityAlert>;\n};\n\n/** The possible states of an alert */\nexport enum RepositoryVulnerabilityAlertState {\n  /** An alert that has been automatically closed by Dependabot. */\n  AutoDismissed = 'AUTO_DISMISSED',\n  /** An alert that has been manually closed by a user. */\n  Dismissed = 'DISMISSED',\n  /** An alert that has been resolved by a code change. */\n  Fixed = 'FIXED',\n  /** An alert that is still open. */\n  Open = 'OPEN'\n}\n\n/** Autogenerated input type of RequestReviews */\nexport type RequestReviewsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID']['input'];\n  /** The Node IDs of the team to request. */\n  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** Add users to the set rather than replace. */\n  union?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The Node IDs of the user to request. */\n  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n};\n\n/** Autogenerated return type of RequestReviews */\nexport type RequestReviewsPayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that is getting requests. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The edge from the pull request to the requested reviewers. */\n  requestedReviewersEdge?: Maybe<UserEdge>;\n};\n\n/** The possible states that can be requested when creating a check run. */\nexport enum RequestableCheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n/** Types that can be requested reviewers. */\nexport type RequestedReviewer = Mannequin | Team | User;\n\n/** The connection type for RequestedReviewer. */\nexport type RequestedReviewerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RequestedReviewerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RequestedReviewer>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type RequestedReviewerEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RequestedReviewer>;\n};\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequest = {\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean']['output'];\n};\n\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequestIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars['ID']['input']>;\n  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/**\n * Choose which environments must be successfully deployed to before branches can\n * be merged into a branch that matches this rule.\n */\nexport type RequiredDeploymentsParameters = {\n  /** The environments that must be successfully deployed to before branches can be merged. */\n  requiredDeploymentEnvironments: Array<Scalars['String']['output']>;\n};\n\n/**\n * Choose which environments must be successfully deployed to before branches can\n * be merged into a branch that matches this rule.\n */\nexport type RequiredDeploymentsParametersInput = {\n  /** The environments that must be successfully deployed to before branches can be merged. */\n  requiredDeploymentEnvironments: Array<Scalars['String']['input']>;\n};\n\n/** Represents a required status check for a protected branch, but not any specific run of that check. */\nexport type RequiredStatusCheckDescription = {\n  /** The App that must provide this status in order for it to be accepted. */\n  app?: Maybe<App>;\n  /** The name of this status. */\n  context: Scalars['String']['output'];\n};\n\n/** Specifies the attributes for a new or updated required status check. */\nexport type RequiredStatusCheckInput = {\n  /**\n   * The ID of the App that must set the status in order for it to be accepted.\n   * Omit this value to use whichever app has recently been setting this status, or\n   * use \"any\" to allow any app to set the status.\n   */\n  appId?: InputMaybe<Scalars['ID']['input']>;\n  /** Status check context that must pass for commits to be accepted to the matching branch. */\n  context: Scalars['String']['input'];\n};\n\n/**\n * Choose which status checks must pass before branches can be merged into a branch\n * that matches this rule. When enabled, commits must first be pushed to another\n * branch, then merged or pushed directly to a branch that matches this rule after\n * status checks have passed.\n */\nexport type RequiredStatusChecksParameters = {\n  /** Status checks that are required. */\n  requiredStatusChecks: Array<StatusCheckConfiguration>;\n  /**\n   * Whether pull requests targeting a matching branch must be tested with the\n   * latest code. This setting will not take effect unless at least one status\n   * check is enabled.\n   */\n  strictRequiredStatusChecksPolicy: Scalars['Boolean']['output'];\n};\n\n/**\n * Choose which status checks must pass before branches can be merged into a branch\n * that matches this rule. When enabled, commits must first be pushed to another\n * branch, then merged or pushed directly to a branch that matches this rule after\n * status checks have passed.\n */\nexport type RequiredStatusChecksParametersInput = {\n  /** Status checks that are required. */\n  requiredStatusChecks: Array<StatusCheckConfigurationInput>;\n  /**\n   * Whether pull requests targeting a matching branch must be tested with the\n   * latest code. This setting will not take effect unless at least one status\n   * check is enabled.\n   */\n  strictRequiredStatusChecksPolicy: Scalars['Boolean']['input'];\n};\n\n/** Autogenerated input type of RerequestCheckSuite */\nexport type RerequestCheckSuiteInput = {\n  /** The Node ID of the check suite. */\n  checkSuiteId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RerequestCheckSuite */\nexport type RerequestCheckSuitePayload = {\n  /** The requested check suite. */\n  checkSuite?: Maybe<CheckSuite>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of ResolveReviewThread */\nexport type ResolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the thread to resolve */\n  threadId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of ResolveReviewThread */\nexport type ResolveReviewThreadPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents a private contribution a user made on GitHub. */\nexport type RestrictedContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']['output'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']['output'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']['output'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** Autogenerated input type of RetireSponsorsTier */\nexport type RetireSponsorsTierInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the published tier to retire. */\n  tierId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RetireSponsorsTier */\nexport type RetireSponsorsTierPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The tier that was retired. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of RevertPullRequest */\nexport type RevertPullRequestInput = {\n  /** The description of the revert pull request. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Indicates whether the revert pull request should be a draft. */\n  draft?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the pull request to revert. */\n  pullRequestId: Scalars['ID']['input'];\n  /** The title of the revert pull request. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of RevertPullRequest */\nexport type RevertPullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The pull request that was reverted. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The new pull request that reverts the input pull request. */\n  revertPullRequest?: Maybe<PullRequest>;\n};\n\n/** A user, team, or app who has the ability to dismiss a review on a protected branch. */\nexport type ReviewDismissalAllowance = Node & {\n  /** The actor that can dismiss. */\n  actor?: Maybe<ReviewDismissalAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID']['output'];\n};\n\n/** Types that can be an actor. */\nexport type ReviewDismissalAllowanceActor = App | Team | User;\n\n/** The connection type for ReviewDismissalAllowance. */\nexport type ReviewDismissalAllowanceConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewDismissalAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewDismissalAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ReviewDismissalAllowanceEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewDismissalAllowance>;\n};\n\n/** Represents a 'review_dismissed' event on a given issue or pull request. */\nexport type ReviewDismissedEvent = Node & UniformResourceLocatable & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** Identifies the optional message associated with the 'review_dismissed' event. */\n  dismissalMessage?: Maybe<Scalars['String']['output']>;\n  /** Identifies the optional message associated with the event, rendered to HTML. */\n  dismissalMessageHTML?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** Identifies the previous state of the review with the 'review_dismissed' event. */\n  previousReviewState: PullRequestReviewState;\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the commit which caused the review to become stale. */\n  pullRequestCommit?: Maybe<PullRequestCommit>;\n  /** The HTTP path for this review dismissed event. */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the review associated with the 'review_dismissed' event. */\n  review?: Maybe<PullRequestReview>;\n  /** The HTTP URL for this review dismissed event. */\n  url: Scalars['URI']['output'];\n};\n\n/** A request for a user to review a pull request. */\nexport type ReviewRequest = Node & {\n  /** Whether this request was created for a code owner */\n  asCodeOwner: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** Identifies the pull request associated with this review request. */\n  pullRequest: PullRequest;\n  /** The reviewer that is requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/** The connection type for ReviewRequest. */\nexport type ReviewRequestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type ReviewRequestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewRequest>;\n};\n\n/** Represents an 'review_request_removed' event on a given pull request. */\nexport type ReviewRequestRemovedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the reviewer whose review request was removed. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/** Represents an 'review_requested' event on a given pull request. */\nexport type ReviewRequestedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the reviewer whose review was requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/**\n * A hovercard context with a message describing the current code review state of the pull\n * request.\n */\nexport type ReviewStatusHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']['output'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']['output'];\n  /** The current status of the pull request with respect to code review. */\n  reviewDecision?: Maybe<PullRequestReviewDecision>;\n};\n\n/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of the user to revoke the migrator role */\n  login: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The organizations that had the migrator role revoked for the given user. */\n  organizations?: Maybe<OrganizationConnection>;\n};\n\n\n/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Autogenerated input type of RevokeMigratorRole */\nexport type RevokeMigratorRoleInput = {\n  /** The user login or Team slug to revoke the migrator role from. */\n  actor: Scalars['String']['input'];\n  /** Specifies the type of the actor, can be either USER or TEAM. */\n  actorType: ActorType;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the organization that the user/team belongs to. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of RevokeMigratorRole */\nexport type RevokeMigratorRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** Possible roles a user may have in relation to an organization. */\nexport enum RoleInOrganization {\n  /** A user who is a direct member of the organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /** A user with full administrative access to the organization. */\n  Owner = 'OWNER',\n  /** A user who is unaffiliated with the organization. */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The level of enforcement for a rule or ruleset. */\nexport enum RuleEnforcement {\n  /** Rules will be enforced */\n  Active = 'ACTIVE',\n  /** Do not evaluate or enforce rules */\n  Disabled = 'DISABLED',\n  /**\n   * Allow admins to test rules before enforcing them. Admins can view insights on\n   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).\n   */\n  Evaluate = 'EVALUATE'\n}\n\n/** Types which can be parameters for `RepositoryRule` objects. */\nexport type RuleParameters = BranchNamePatternParameters | CommitAuthorEmailPatternParameters | CommitMessagePatternParameters | CommitterEmailPatternParameters | PullRequestParameters | RequiredDeploymentsParameters | RequiredStatusChecksParameters | TagNamePatternParameters | UpdateParameters;\n\n/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */\nexport type RuleParametersInput = {\n  /** Parameters used for the `branch_name_pattern` rule type */\n  branchNamePattern?: InputMaybe<BranchNamePatternParametersInput>;\n  /** Parameters used for the `commit_author_email_pattern` rule type */\n  commitAuthorEmailPattern?: InputMaybe<CommitAuthorEmailPatternParametersInput>;\n  /** Parameters used for the `commit_message_pattern` rule type */\n  commitMessagePattern?: InputMaybe<CommitMessagePatternParametersInput>;\n  /** Parameters used for the `committer_email_pattern` rule type */\n  committerEmailPattern?: InputMaybe<CommitterEmailPatternParametersInput>;\n  /** Parameters used for the `pull_request` rule type */\n  pullRequest?: InputMaybe<PullRequestParametersInput>;\n  /** Parameters used for the `required_deployments` rule type */\n  requiredDeployments?: InputMaybe<RequiredDeploymentsParametersInput>;\n  /** Parameters used for the `required_status_checks` rule type */\n  requiredStatusChecks?: InputMaybe<RequiredStatusChecksParametersInput>;\n  /** Parameters used for the `tag_name_pattern` rule type */\n  tagNamePattern?: InputMaybe<TagNamePatternParametersInput>;\n  /** Parameters used for the `update` rule type */\n  update?: InputMaybe<UpdateParametersInput>;\n};\n\n/** Types which can have `RepositoryRule` objects. */\nexport type RuleSource = Organization | Repository;\n\n/** The possible digest algorithms used to sign SAML requests for an identity provider. */\nexport enum SamlDigestAlgorithm {\n  /** SHA1 */\n  Sha1 = 'SHA1',\n  /** SHA256 */\n  Sha256 = 'SHA256',\n  /** SHA384 */\n  Sha384 = 'SHA384',\n  /** SHA512 */\n  Sha512 = 'SHA512'\n}\n\n/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */\nexport enum SamlSignatureAlgorithm {\n  /** RSA-SHA1 */\n  RsaSha1 = 'RSA_SHA1',\n  /** RSA-SHA256 */\n  RsaSha256 = 'RSA_SHA256',\n  /** RSA-SHA384 */\n  RsaSha384 = 'RSA_SHA384',\n  /** RSA-SHA512 */\n  RsaSha512 = 'RSA_SHA512'\n}\n\n/** A Saved Reply is text a user can use to reply quickly. */\nexport type SavedReply = Node & {\n  /** The body of the saved reply. */\n  body: Scalars['String']['output'];\n  /** The saved reply body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The title of the saved reply. */\n  title: Scalars['String']['output'];\n  /** The user that saved this reply. */\n  user?: Maybe<Actor>;\n};\n\n/** The connection type for SavedReply. */\nexport type SavedReplyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SavedReply>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SavedReplyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SavedReply>;\n};\n\n/** Ordering options for saved reply connections. */\nexport type SavedReplyOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order saved replies by. */\n  field: SavedReplyOrderField;\n};\n\n/** Properties by which saved reply connections can be ordered. */\nexport enum SavedReplyOrderField {\n  /** Order saved reply by when they were updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The results of a search. */\nexport type SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User;\n\n/**\n * A list of results that matched against a search query. Regardless of the number\n * of matches, a maximum of 1,000 results will be available across all types,\n * potentially split across many pages.\n */\nexport type SearchResultItemConnection = {\n  /**\n   * The total number of pieces of code that matched the search query. Regardless\n   * of the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  codeCount: Scalars['Int']['output'];\n  /**\n   * The total number of discussions that matched the search query. Regardless of\n   * the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  discussionCount: Scalars['Int']['output'];\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SearchResultItemEdge>>>;\n  /**\n   * The total number of issues that matched the search query. Regardless of the\n   * total number of matches, a maximum of 1,000 results will be available across all types.\n   */\n  issueCount: Scalars['Int']['output'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SearchResultItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /**\n   * The total number of repositories that matched the search query. Regardless of\n   * the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  repositoryCount: Scalars['Int']['output'];\n  /**\n   * The total number of users that matched the search query. Regardless of the\n   * total number of matches, a maximum of 1,000 results will be available across all types.\n   */\n  userCount: Scalars['Int']['output'];\n  /**\n   * The total number of wiki pages that matched the search query. Regardless of\n   * the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  wikiCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SearchResultItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SearchResultItem>;\n  /** Text matches on the result found. */\n  textMatches?: Maybe<Array<Maybe<TextMatch>>>;\n};\n\n/** Represents the individual results of a search. */\nexport enum SearchType {\n  /** Returns matching discussions in repositories. */\n  Discussion = 'DISCUSSION',\n  /** Returns results matching issues in repositories. */\n  Issue = 'ISSUE',\n  /** Returns results matching repositories. */\n  Repository = 'REPOSITORY',\n  /** Returns results matching users and organizations on GitHub. */\n  User = 'USER'\n}\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisory = Node & {\n  /** The classification of the advisory */\n  classification: SecurityAdvisoryClassification;\n  /** The CVSS associated with this advisory */\n  cvss: Cvss;\n  /** CWEs associated with this Advisory */\n  cwes: CweConnection;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** This is a long plaintext description of the advisory */\n  description: Scalars['String']['output'];\n  /** The GitHub Security Advisory ID */\n  ghsaId: Scalars['String']['output'];\n  id: Scalars['ID']['output'];\n  /** A list of identifiers for this advisory */\n  identifiers: Array<SecurityAdvisoryIdentifier>;\n  /** The permalink for the advisory's dependabot alerts page */\n  notificationsPermalink?: Maybe<Scalars['URI']['output']>;\n  /** The organization that originated the advisory */\n  origin: Scalars['String']['output'];\n  /** The permalink for the advisory */\n  permalink?: Maybe<Scalars['URI']['output']>;\n  /** When the advisory was published */\n  publishedAt: Scalars['DateTime']['output'];\n  /** A list of references for this advisory */\n  references: Array<SecurityAdvisoryReference>;\n  /** The severity of the advisory */\n  severity: SecurityAdvisorySeverity;\n  /** A short plaintext summary of the advisory */\n  summary: Scalars['String']['output'];\n  /** When the advisory was last updated */\n  updatedAt: Scalars['DateTime']['output'];\n  /** Vulnerabilities associated with this Advisory */\n  vulnerabilities: SecurityVulnerabilityConnection;\n  /** When the advisory was withdrawn, if it has been withdrawn */\n  withdrawnAt?: Maybe<Scalars['DateTime']['output']>;\n};\n\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryCwesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryVulnerabilitiesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;\n  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;\n  package?: InputMaybe<Scalars['String']['input']>;\n  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;\n};\n\n/** Classification of the advisory. */\nexport enum SecurityAdvisoryClassification {\n  /** Classification of general advisories. */\n  General = 'GENERAL',\n  /** Classification of malware advisories. */\n  Malware = 'MALWARE'\n}\n\n/** The connection type for SecurityAdvisory. */\nexport type SecurityAdvisoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityAdvisoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityAdvisory>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** The possible ecosystems of a security vulnerability's package. */\nexport enum SecurityAdvisoryEcosystem {\n  /** GitHub Actions */\n  Actions = 'ACTIONS',\n  /** PHP packages hosted at packagist.org */\n  Composer = 'COMPOSER',\n  /** Erlang/Elixir packages hosted at hex.pm */\n  Erlang = 'ERLANG',\n  /** Go modules */\n  Go = 'GO',\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = 'MAVEN',\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = 'NPM',\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = 'NUGET',\n  /** Python packages hosted at PyPI.org */\n  Pip = 'PIP',\n  /** Dart packages hosted at pub.dev */\n  Pub = 'PUB',\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = 'RUBYGEMS',\n  /** Rust crates */\n  Rust = 'RUST',\n  /** Swift packages */\n  Swift = 'SWIFT'\n}\n\n/** An edge in a connection. */\nexport type SecurityAdvisoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityAdvisory>;\n};\n\n/** A GitHub Security Advisory Identifier */\nexport type SecurityAdvisoryIdentifier = {\n  /** The identifier type, e.g. GHSA, CVE */\n  type: Scalars['String']['output'];\n  /** The identifier */\n  value: Scalars['String']['output'];\n};\n\n/** An advisory identifier to filter results on. */\nexport type SecurityAdvisoryIdentifierFilter = {\n  /** The identifier type. */\n  type: SecurityAdvisoryIdentifierType;\n  /** The identifier string. Supports exact or partial matching. */\n  value: Scalars['String']['input'];\n};\n\n/** Identifier formats available for advisories. */\nexport enum SecurityAdvisoryIdentifierType {\n  /** Common Vulnerabilities and Exposures Identifier. */\n  Cve = 'CVE',\n  /** GitHub Security Advisory ID. */\n  Ghsa = 'GHSA'\n}\n\n/** Ordering options for security advisory connections */\nexport type SecurityAdvisoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security advisories by. */\n  field: SecurityAdvisoryOrderField;\n};\n\n/** Properties by which security advisory connections can be ordered. */\nexport enum SecurityAdvisoryOrderField {\n  /** Order advisories by publication time */\n  PublishedAt = 'PUBLISHED_AT',\n  /** Order advisories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** An individual package */\nexport type SecurityAdvisoryPackage = {\n  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */\n  ecosystem: SecurityAdvisoryEcosystem;\n  /** The package name */\n  name: Scalars['String']['output'];\n};\n\n/** An individual package version */\nexport type SecurityAdvisoryPackageVersion = {\n  /** The package name or version */\n  identifier: Scalars['String']['output'];\n};\n\n/** A GitHub Security Advisory Reference */\nexport type SecurityAdvisoryReference = {\n  /** A publicly accessible reference */\n  url: Scalars['URI']['output'];\n};\n\n/** Severity of the vulnerability. */\nexport enum SecurityAdvisorySeverity {\n  /** Critical. */\n  Critical = 'CRITICAL',\n  /** High. */\n  High = 'HIGH',\n  /** Low. */\n  Low = 'LOW',\n  /** Moderate. */\n  Moderate = 'MODERATE'\n}\n\n/** An individual vulnerability within an Advisory */\nexport type SecurityVulnerability = {\n  /** The Advisory associated with this Vulnerability */\n  advisory: SecurityAdvisory;\n  /** The first version containing a fix for the vulnerability */\n  firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>;\n  /** A description of the vulnerable package */\n  package: SecurityAdvisoryPackage;\n  /** The severity of the vulnerability within this package */\n  severity: SecurityAdvisorySeverity;\n  /** When the vulnerability was last updated */\n  updatedAt: Scalars['DateTime']['output'];\n  /**\n   * A string that describes the vulnerable package versions.\n   * This string follows a basic syntax with a few forms.\n   * + `= 0.2.0` denotes a single vulnerable version.\n   * + `<= 1.0.8` denotes a version range up to and including the specified version\n   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version\n   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.\n   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum\n   */\n  vulnerableVersionRange: Scalars['String']['output'];\n};\n\n/** The connection type for SecurityVulnerability. */\nexport type SecurityVulnerabilityConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityVulnerabilityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityVulnerability>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SecurityVulnerabilityEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityVulnerability>;\n};\n\n/** Ordering options for security vulnerability connections */\nexport type SecurityVulnerabilityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security vulnerabilities by. */\n  field: SecurityVulnerabilityOrderField;\n};\n\n/** Properties by which security vulnerability connections can be ordered. */\nexport enum SecurityVulnerabilityOrderField {\n  /** Order vulnerability by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Autogenerated input type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod: SamlDigestAlgorithm;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate: Scalars['String']['input'];\n  /** The Issuer Entity ID for the SAML identity provider */\n  issuer?: InputMaybe<Scalars['String']['input']>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod: SamlSignatureAlgorithm;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl: Scalars['URI']['input'];\n};\n\n/** Autogenerated return type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the organization to set a limit for. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The organization that the interaction limit was set for. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the repository to set a limit for. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository that the interaction limit was set for. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the user to set a limit for. */\n  userId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The user that the interaction limit was set for. */\n  user?: Maybe<User>;\n};\n\n/** Represents an S/MIME signature on a Commit or Tag. */\nexport type SmimeSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']['output'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']['output'];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']['output'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']['output'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']['output'];\n};\n\n/** Social media profile associated with a user. */\nexport type SocialAccount = {\n  /** Name of the social media account as it appears on the profile. */\n  displayName: Scalars['String']['output'];\n  /** Software or company that hosts the social media account. */\n  provider: SocialAccountProvider;\n  /** URL of the social media account. */\n  url: Scalars['URI']['output'];\n};\n\n/** The connection type for SocialAccount. */\nexport type SocialAccountConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SocialAccountEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SocialAccount>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SocialAccountEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SocialAccount>;\n};\n\n/** Software or company that hosts social media accounts. */\nexport enum SocialAccountProvider {\n  /** Social media and networking website. */\n  Facebook = 'FACEBOOK',\n  /** Catch-all for social media providers that do not yet have specific handling. */\n  Generic = 'GENERIC',\n  /** Fork of Mastodon with a greater focus on local posting. */\n  Hometown = 'HOMETOWN',\n  /** Social media website with a focus on photo and video sharing. */\n  Instagram = 'INSTAGRAM',\n  /** Professional networking website. */\n  Linkedin = 'LINKEDIN',\n  /** Open-source federated microblogging service. */\n  Mastodon = 'MASTODON',\n  /** Social news aggregation and discussion website. */\n  Reddit = 'REDDIT',\n  /** Live-streaming service. */\n  Twitch = 'TWITCH',\n  /** Microblogging website. */\n  Twitter = 'TWITTER',\n  /** Online video platform. */\n  Youtube = 'YOUTUBE'\n}\n\n/** Entities that can sponsor others via GitHub Sponsors */\nexport type Sponsor = Organization | User;\n\n/** The connection type for Sponsor. */\nexport type SponsorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */\nexport type SponsorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsor>;\n};\n\n/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */\nexport type SponsorOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsor entities by. */\n  field: SponsorOrderField;\n};\n\n/** Properties by which sponsor connections can be ordered. */\nexport enum SponsorOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN',\n  /** Order sponsors by their relevance to the viewer. */\n  Relevance = 'RELEVANCE'\n}\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type Sponsorable = {\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean']['output'];\n  /** Whether the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean']['output'];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean']['output'];\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** The sponsorships where this user or organization is the maintainer receiving the funds. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** The sponsorships where this user or organization is the funder. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /**\n   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has\n   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the\n   * user themselves or by a user who can manage sponsorships for the requested organization.\n   */\n  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean']['output'];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean']['output'];\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableIsSponsoredByArgs = {\n  accountLogin: Scalars['String']['input'];\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsoringArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorsActivitiesArgs = {\n  actions?: InputMaybe<Array<SponsorsActivityAction>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  until?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipForViewerAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipForViewerAsSponsorableArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipsAsMaintainerArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipsAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableTotalSponsorshipAmountAsSponsorInCentsArgs = {\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  until?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n/** Entities that can be sponsored via GitHub Sponsors */\nexport type SponsorableItem = Organization | User;\n\n/** The connection type for SponsorableItem. */\nexport type SponsorableItemConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorableItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorableItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SponsorableItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorableItem>;\n};\n\n/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */\nexport type SponsorableOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorable entities by. */\n  field: SponsorableOrderField;\n};\n\n/** Properties by which sponsorable connections can be ordered. */\nexport enum SponsorableOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN'\n}\n\n/** An event related to sponsorship activity. */\nexport type SponsorsActivity = Node & {\n  /** What action this activity indicates took place. */\n  action: SponsorsActivityAction;\n  /** The sponsor's current privacy level. */\n  currentPrivacyLevel?: Maybe<SponsorshipPrivacy>;\n  id: Scalars['ID']['output'];\n  /** The tier that the sponsorship used to use, for tier change events. */\n  previousSponsorsTier?: Maybe<SponsorsTier>;\n  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */\n  sponsor?: Maybe<Sponsor>;\n  /** The user or organization that is being sponsored, the maintainer. */\n  sponsorable: Sponsorable;\n  /** The associated sponsorship tier. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n  /** The timestamp of this event. */\n  timestamp?: Maybe<Scalars['DateTime']['output']>;\n  /** Was this sponsorship made alongside other sponsorships at the same time from the same sponsor? */\n  viaBulkSponsorship: Scalars['Boolean']['output'];\n};\n\n/** The possible actions that GitHub Sponsors activities can represent. */\nexport enum SponsorsActivityAction {\n  /** The activity was cancelling a sponsorship. */\n  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',\n  /** The activity was starting a sponsorship. */\n  NewSponsorship = 'NEW_SPONSORSHIP',\n  /** The activity was scheduling a downgrade or cancellation. */\n  PendingChange = 'PENDING_CHANGE',\n  /** The activity was funds being refunded to the sponsor or GitHub. */\n  Refund = 'REFUND',\n  /** The activity was disabling matching for a previously matched sponsorship. */\n  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',\n  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */\n  TierChange = 'TIER_CHANGE'\n}\n\n/** The connection type for SponsorsActivity. */\nexport type SponsorsActivityConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsActivityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsActivity>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SponsorsActivityEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsActivity>;\n};\n\n/** Ordering options for GitHub Sponsors activity connections. */\nexport type SponsorsActivityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order activity by. */\n  field: SponsorsActivityOrderField;\n};\n\n/** Properties by which GitHub Sponsors activity connections can be ordered. */\nexport enum SponsorsActivityOrderField {\n  /** Order activities by when they happened. */\n  Timestamp = 'TIMESTAMP'\n}\n\n/** The possible time periods for which Sponsors activities can be requested. */\nexport enum SponsorsActivityPeriod {\n  /** Don't restrict the activity to any date range, include all activity. */\n  All = 'ALL',\n  /** The previous calendar day. */\n  Day = 'DAY',\n  /** The previous thirty days. */\n  Month = 'MONTH',\n  /** The previous seven days. */\n  Week = 'WEEK'\n}\n\n/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */\nexport enum SponsorsCountryOrRegionCode {\n  /** Andorra */\n  Ad = 'AD',\n  /** United Arab Emirates */\n  Ae = 'AE',\n  /** Afghanistan */\n  Af = 'AF',\n  /** Antigua and Barbuda */\n  Ag = 'AG',\n  /** Anguilla */\n  Ai = 'AI',\n  /** Albania */\n  Al = 'AL',\n  /** Armenia */\n  Am = 'AM',\n  /** Angola */\n  Ao = 'AO',\n  /** Antarctica */\n  Aq = 'AQ',\n  /** Argentina */\n  Ar = 'AR',\n  /** American Samoa */\n  As = 'AS',\n  /** Austria */\n  At = 'AT',\n  /** Australia */\n  Au = 'AU',\n  /** Aruba */\n  Aw = 'AW',\n  /** \u00C5land */\n  Ax = 'AX',\n  /** Azerbaijan */\n  Az = 'AZ',\n  /** Bosnia and Herzegovina */\n  Ba = 'BA',\n  /** Barbados */\n  Bb = 'BB',\n  /** Bangladesh */\n  Bd = 'BD',\n  /** Belgium */\n  Be = 'BE',\n  /** Burkina Faso */\n  Bf = 'BF',\n  /** Bulgaria */\n  Bg = 'BG',\n  /** Bahrain */\n  Bh = 'BH',\n  /** Burundi */\n  Bi = 'BI',\n  /** Benin */\n  Bj = 'BJ',\n  /** Saint Barth\u00E9lemy */\n  Bl = 'BL',\n  /** Bermuda */\n  Bm = 'BM',\n  /** Brunei Darussalam */\n  Bn = 'BN',\n  /** Bolivia */\n  Bo = 'BO',\n  /** Bonaire, Sint Eustatius and Saba */\n  Bq = 'BQ',\n  /** Brazil */\n  Br = 'BR',\n  /** Bahamas */\n  Bs = 'BS',\n  /** Bhutan */\n  Bt = 'BT',\n  /** Bouvet Island */\n  Bv = 'BV',\n  /** Botswana */\n  Bw = 'BW',\n  /** Belarus */\n  By = 'BY',\n  /** Belize */\n  Bz = 'BZ',\n  /** Canada */\n  Ca = 'CA',\n  /** Cocos (Keeling) Islands */\n  Cc = 'CC',\n  /** Congo (Kinshasa) */\n  Cd = 'CD',\n  /** Central African Republic */\n  Cf = 'CF',\n  /** Congo (Brazzaville) */\n  Cg = 'CG',\n  /** Switzerland */\n  Ch = 'CH',\n  /** C\u00F4te d'Ivoire */\n  Ci = 'CI',\n  /** Cook Islands */\n  Ck = 'CK',\n  /** Chile */\n  Cl = 'CL',\n  /** Cameroon */\n  Cm = 'CM',\n  /** China */\n  Cn = 'CN',\n  /** Colombia */\n  Co = 'CO',\n  /** Costa Rica */\n  Cr = 'CR',\n  /** Cape Verde */\n  Cv = 'CV',\n  /** Cura\u00E7ao */\n  Cw = 'CW',\n  /** Christmas Island */\n  Cx = 'CX',\n  /** Cyprus */\n  Cy = 'CY',\n  /** Czech Republic */\n  Cz = 'CZ',\n  /** Germany */\n  De = 'DE',\n  /** Djibouti */\n  Dj = 'DJ',\n  /** Denmark */\n  Dk = 'DK',\n  /** Dominica */\n  Dm = 'DM',\n  /** Dominican Republic */\n  Do = 'DO',\n  /** Algeria */\n  Dz = 'DZ',\n  /** Ecuador */\n  Ec = 'EC',\n  /** Estonia */\n  Ee = 'EE',\n  /** Egypt */\n  Eg = 'EG',\n  /** Western Sahara */\n  Eh = 'EH',\n  /** Eritrea */\n  Er = 'ER',\n  /** Spain */\n  Es = 'ES',\n  /** Ethiopia */\n  Et = 'ET',\n  /** Finland */\n  Fi = 'FI',\n  /** Fiji */\n  Fj = 'FJ',\n  /** Falkland Islands */\n  Fk = 'FK',\n  /** Micronesia */\n  Fm = 'FM',\n  /** Faroe Islands */\n  Fo = 'FO',\n  /** France */\n  Fr = 'FR',\n  /** Gabon */\n  Ga = 'GA',\n  /** United Kingdom */\n  Gb = 'GB',\n  /** Grenada */\n  Gd = 'GD',\n  /** Georgia */\n  Ge = 'GE',\n  /** French Guiana */\n  Gf = 'GF',\n  /** Guernsey */\n  Gg = 'GG',\n  /** Ghana */\n  Gh = 'GH',\n  /** Gibraltar */\n  Gi = 'GI',\n  /** Greenland */\n  Gl = 'GL',\n  /** Gambia */\n  Gm = 'GM',\n  /** Guinea */\n  Gn = 'GN',\n  /** Guadeloupe */\n  Gp = 'GP',\n  /** Equatorial Guinea */\n  Gq = 'GQ',\n  /** Greece */\n  Gr = 'GR',\n  /** South Georgia and South Sandwich Islands */\n  Gs = 'GS',\n  /** Guatemala */\n  Gt = 'GT',\n  /** Guam */\n  Gu = 'GU',\n  /** Guinea-Bissau */\n  Gw = 'GW',\n  /** Guyana */\n  Gy = 'GY',\n  /** Hong Kong */\n  Hk = 'HK',\n  /** Heard and McDonald Islands */\n  Hm = 'HM',\n  /** Honduras */\n  Hn = 'HN',\n  /** Croatia */\n  Hr = 'HR',\n  /** Haiti */\n  Ht = 'HT',\n  /** Hungary */\n  Hu = 'HU',\n  /** Indonesia */\n  Id = 'ID',\n  /** Ireland */\n  Ie = 'IE',\n  /** Israel */\n  Il = 'IL',\n  /** Isle of Man */\n  Im = 'IM',\n  /** India */\n  In = 'IN',\n  /** British Indian Ocean Territory */\n  Io = 'IO',\n  /** Iraq */\n  Iq = 'IQ',\n  /** Iran */\n  Ir = 'IR',\n  /** Iceland */\n  Is = 'IS',\n  /** Italy */\n  It = 'IT',\n  /** Jersey */\n  Je = 'JE',\n  /** Jamaica */\n  Jm = 'JM',\n  /** Jordan */\n  Jo = 'JO',\n  /** Japan */\n  Jp = 'JP',\n  /** Kenya */\n  Ke = 'KE',\n  /** Kyrgyzstan */\n  Kg = 'KG',\n  /** Cambodia */\n  Kh = 'KH',\n  /** Kiribati */\n  Ki = 'KI',\n  /** Comoros */\n  Km = 'KM',\n  /** Saint Kitts and Nevis */\n  Kn = 'KN',\n  /** Korea, South */\n  Kr = 'KR',\n  /** Kuwait */\n  Kw = 'KW',\n  /** Cayman Islands */\n  Ky = 'KY',\n  /** Kazakhstan */\n  Kz = 'KZ',\n  /** Laos */\n  La = 'LA',\n  /** Lebanon */\n  Lb = 'LB',\n  /** Saint Lucia */\n  Lc = 'LC',\n  /** Liechtenstein */\n  Li = 'LI',\n  /** Sri Lanka */\n  Lk = 'LK',\n  /** Liberia */\n  Lr = 'LR',\n  /** Lesotho */\n  Ls = 'LS',\n  /** Lithuania */\n  Lt = 'LT',\n  /** Luxembourg */\n  Lu = 'LU',\n  /** Latvia */\n  Lv = 'LV',\n  /** Libya */\n  Ly = 'LY',\n  /** Morocco */\n  Ma = 'MA',\n  /** Monaco */\n  Mc = 'MC',\n  /** Moldova */\n  Md = 'MD',\n  /** Montenegro */\n  Me = 'ME',\n  /** Saint Martin (French part) */\n  Mf = 'MF',\n  /** Madagascar */\n  Mg = 'MG',\n  /** Marshall Islands */\n  Mh = 'MH',\n  /** Macedonia */\n  Mk = 'MK',\n  /** Mali */\n  Ml = 'ML',\n  /** Myanmar */\n  Mm = 'MM',\n  /** Mongolia */\n  Mn = 'MN',\n  /** Macau */\n  Mo = 'MO',\n  /** Northern Mariana Islands */\n  Mp = 'MP',\n  /** Martinique */\n  Mq = 'MQ',\n  /** Mauritania */\n  Mr = 'MR',\n  /** Montserrat */\n  Ms = 'MS',\n  /** Malta */\n  Mt = 'MT',\n  /** Mauritius */\n  Mu = 'MU',\n  /** Maldives */\n  Mv = 'MV',\n  /** Malawi */\n  Mw = 'MW',\n  /** Mexico */\n  Mx = 'MX',\n  /** Malaysia */\n  My = 'MY',\n  /** Mozambique */\n  Mz = 'MZ',\n  /** Namibia */\n  Na = 'NA',\n  /** New Caledonia */\n  Nc = 'NC',\n  /** Niger */\n  Ne = 'NE',\n  /** Norfolk Island */\n  Nf = 'NF',\n  /** Nigeria */\n  Ng = 'NG',\n  /** Nicaragua */\n  Ni = 'NI',\n  /** Netherlands */\n  Nl = 'NL',\n  /** Norway */\n  No = 'NO',\n  /** Nepal */\n  Np = 'NP',\n  /** Nauru */\n  Nr = 'NR',\n  /** Niue */\n  Nu = 'NU',\n  /** New Zealand */\n  Nz = 'NZ',\n  /** Oman */\n  Om = 'OM',\n  /** Panama */\n  Pa = 'PA',\n  /** Peru */\n  Pe = 'PE',\n  /** French Polynesia */\n  Pf = 'PF',\n  /** Papua New Guinea */\n  Pg = 'PG',\n  /** Philippines */\n  Ph = 'PH',\n  /** Pakistan */\n  Pk = 'PK',\n  /** Poland */\n  Pl = 'PL',\n  /** Saint Pierre and Miquelon */\n  Pm = 'PM',\n  /** Pitcairn */\n  Pn = 'PN',\n  /** Puerto Rico */\n  Pr = 'PR',\n  /** Palestine */\n  Ps = 'PS',\n  /** Portugal */\n  Pt = 'PT',\n  /** Palau */\n  Pw = 'PW',\n  /** Paraguay */\n  Py = 'PY',\n  /** Qatar */\n  Qa = 'QA',\n  /** Reunion */\n  Re = 'RE',\n  /** Romania */\n  Ro = 'RO',\n  /** Serbia */\n  Rs = 'RS',\n  /** Russian Federation */\n  Ru = 'RU',\n  /** Rwanda */\n  Rw = 'RW',\n  /** Saudi Arabia */\n  Sa = 'SA',\n  /** Solomon Islands */\n  Sb = 'SB',\n  /** Seychelles */\n  Sc = 'SC',\n  /** Sudan */\n  Sd = 'SD',\n  /** Sweden */\n  Se = 'SE',\n  /** Singapore */\n  Sg = 'SG',\n  /** Saint Helena */\n  Sh = 'SH',\n  /** Slovenia */\n  Si = 'SI',\n  /** Svalbard and Jan Mayen Islands */\n  Sj = 'SJ',\n  /** Slovakia */\n  Sk = 'SK',\n  /** Sierra Leone */\n  Sl = 'SL',\n  /** San Marino */\n  Sm = 'SM',\n  /** Senegal */\n  Sn = 'SN',\n  /** Somalia */\n  So = 'SO',\n  /** Suriname */\n  Sr = 'SR',\n  /** South Sudan */\n  Ss = 'SS',\n  /** Sao Tome and Principe */\n  St = 'ST',\n  /** El Salvador */\n  Sv = 'SV',\n  /** Sint Maarten (Dutch part) */\n  Sx = 'SX',\n  /** Swaziland */\n  Sz = 'SZ',\n  /** Turks and Caicos Islands */\n  Tc = 'TC',\n  /** Chad */\n  Td = 'TD',\n  /** French Southern Lands */\n  Tf = 'TF',\n  /** Togo */\n  Tg = 'TG',\n  /** Thailand */\n  Th = 'TH',\n  /** Tajikistan */\n  Tj = 'TJ',\n  /** Tokelau */\n  Tk = 'TK',\n  /** Timor-Leste */\n  Tl = 'TL',\n  /** Turkmenistan */\n  Tm = 'TM',\n  /** Tunisia */\n  Tn = 'TN',\n  /** Tonga */\n  To = 'TO',\n  /** Turkey */\n  Tr = 'TR',\n  /** Trinidad and Tobago */\n  Tt = 'TT',\n  /** Tuvalu */\n  Tv = 'TV',\n  /** Taiwan */\n  Tw = 'TW',\n  /** Tanzania */\n  Tz = 'TZ',\n  /** Ukraine */\n  Ua = 'UA',\n  /** Uganda */\n  Ug = 'UG',\n  /** United States Minor Outlying Islands */\n  Um = 'UM',\n  /** United States of America */\n  Us = 'US',\n  /** Uruguay */\n  Uy = 'UY',\n  /** Uzbekistan */\n  Uz = 'UZ',\n  /** Vatican City */\n  Va = 'VA',\n  /** Saint Vincent and the Grenadines */\n  Vc = 'VC',\n  /** Venezuela */\n  Ve = 'VE',\n  /** Virgin Islands, British */\n  Vg = 'VG',\n  /** Virgin Islands, U.S. */\n  Vi = 'VI',\n  /** Vietnam */\n  Vn = 'VN',\n  /** Vanuatu */\n  Vu = 'VU',\n  /** Wallis and Futuna Islands */\n  Wf = 'WF',\n  /** Samoa */\n  Ws = 'WS',\n  /** Yemen */\n  Ye = 'YE',\n  /** Mayotte */\n  Yt = 'YT',\n  /** South Africa */\n  Za = 'ZA',\n  /** Zambia */\n  Zm = 'ZM',\n  /** Zimbabwe */\n  Zw = 'ZW'\n}\n\n/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */\nexport type SponsorsGoal = {\n  /** A description of the goal from the maintainer. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** What the objective of this goal is. */\n  kind: SponsorsGoalKind;\n  /** The percentage representing how complete this goal is, between 0-100. */\n  percentComplete: Scalars['Int']['output'];\n  /**\n   * What the goal amount is. Represents an amount in USD for monthly sponsorship\n   * amount goals. Represents a count of unique sponsors for total sponsors count goals.\n   */\n  targetValue: Scalars['Int']['output'];\n  /** A brief summary of the kind and target value of this goal. */\n  title: Scalars['String']['output'];\n};\n\n/** The different kinds of goals a GitHub Sponsors member can have. */\nexport enum SponsorsGoalKind {\n  /** The goal is about getting a certain amount in USD from sponsorships each month. */\n  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',\n  /** The goal is about reaching a certain number of sponsors. */\n  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT'\n}\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListing = Node & {\n  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */\n  activeGoal?: Maybe<SponsorsGoal>;\n  /**\n   * The Stripe Connect account currently in use for payouts for this Sponsors\n   * listing, if any. Will only return a value when queried by the maintainer\n   * themselves, or by an admin of the sponsorable organization.\n   */\n  activeStripeConnectAccount?: Maybe<StripeConnectAccount>;\n  /**\n   * The name of the country or region with the maintainer's bank account or fiscal\n   * host. Will only return a value when queried by the maintainer themselves, or\n   * by an admin of the sponsorable organization.\n   */\n  billingCountryOrRegion?: Maybe<Scalars['String']['output']>;\n  /**\n   * The email address used by GitHub to contact the sponsorable about their GitHub\n   * Sponsors profile. Will only return a value when queried by the maintainer\n   * themselves, or by an admin of the sponsorable organization.\n   */\n  contactEmailAddress?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */\n  dashboardResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */\n  dashboardUrl: Scalars['URI']['output'];\n  /** The records featured on the GitHub Sponsors profile. */\n  featuredItems: Array<SponsorsListingFeaturedItem>;\n  /**\n   * The fiscal host used for payments, if any. Will only return a value when\n   * queried by the maintainer themselves, or by an admin of the sponsorable organization.\n   */\n  fiscalHost?: Maybe<Organization>;\n  /** The full description of the listing. */\n  fullDescription: Scalars['String']['output'];\n  /** The full description of the listing rendered to HTML. */\n  fullDescriptionHTML: Scalars['HTML']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether this listing is publicly visible. */\n  isPublic: Scalars['Boolean']['output'];\n  /** The listing's full name. */\n  name: Scalars['String']['output'];\n  /** A future date on which this listing is eligible to receive a payout. */\n  nextPayoutDate?: Maybe<Scalars['Date']['output']>;\n  /**\n   * The name of the country or region where the maintainer resides. Will only\n   * return a value when queried by the maintainer themselves, or by an admin of\n   * the sponsorable organization.\n   */\n  residenceCountryOrRegion?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this Sponsors listing. */\n  resourcePath: Scalars['URI']['output'];\n  /** The short description of the listing. */\n  shortDescription: Scalars['String']['output'];\n  /** The short name of the listing. */\n  slug: Scalars['String']['output'];\n  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */\n  sponsorable: Sponsorable;\n  /** The tiers for this GitHub Sponsors profile. */\n  tiers?: Maybe<SponsorsTierConnection>;\n  /** The HTTP URL for this Sponsors listing. */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListingFeaturedItemsArgs = {\n  featureableTypes?: InputMaybe<Array<SponsorsListingFeaturedItemFeatureableType>>;\n};\n\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListingTiersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeUnpublished?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorsTierOrder>;\n};\n\n/** A record that can be featured on a GitHub Sponsors profile. */\nexport type SponsorsListingFeatureableItem = Repository | User;\n\n/** A record that is promoted on a GitHub Sponsors profile. */\nexport type SponsorsListingFeaturedItem = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /**\n   * Will either be a description from the sponsorable maintainer about why they\n   * featured this item, or the item's description itself, such as a user's bio\n   * from their GitHub profile page.\n   */\n  description?: Maybe<Scalars['String']['output']>;\n  /** The record that is featured on the GitHub Sponsors profile. */\n  featureable: SponsorsListingFeatureableItem;\n  id: Scalars['ID']['output'];\n  /**\n   * The position of this featured item on the GitHub Sponsors profile with a lower\n   * position indicating higher precedence. Starts at 1.\n   */\n  position: Scalars['Int']['output'];\n  /** The GitHub Sponsors profile that features this record. */\n  sponsorsListing: SponsorsListing;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */\nexport enum SponsorsListingFeaturedItemFeatureableType {\n  /** A repository owned by the user or organization with the GitHub Sponsors profile. */\n  Repository = 'REPOSITORY',\n  /** A user who belongs to the organization with the GitHub Sponsors profile. */\n  User = 'USER'\n}\n\n/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */\nexport type SponsorsTier = Node & {\n  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\n  adminInfo?: Maybe<SponsorsTierAdminInfo>;\n  /**\n   * Get a different tier for this tier's maintainer that is at the same frequency\n   * as this tier but with an equal or lesser cost. Returns the published tier with\n   * the monthly price closest to this tier's without going over.\n   */\n  closestLesserValueTier?: Maybe<SponsorsTier>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The description of the tier. */\n  description: Scalars['String']['output'];\n  /** The tier description rendered to HTML */\n  descriptionHTML: Scalars['HTML']['output'];\n  id: Scalars['ID']['output'];\n  /**\n   * Whether this tier was chosen at checkout time by the sponsor rather than\n   * defined ahead of time by the maintainer who manages the Sponsors listing.\n   */\n  isCustomAmount: Scalars['Boolean']['output'];\n  /** Whether this tier is only for use with one-time sponsorships. */\n  isOneTime: Scalars['Boolean']['output'];\n  /** How much this tier costs per month in cents. */\n  monthlyPriceInCents: Scalars['Int']['output'];\n  /** How much this tier costs per month in USD. */\n  monthlyPriceInDollars: Scalars['Int']['output'];\n  /** The name of the tier. */\n  name: Scalars['String']['output'];\n  /** The sponsors listing that this tier belongs to. */\n  sponsorsListing: SponsorsListing;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfo = {\n  /**\n   * Indicates whether this tier is still a work in progress by the sponsorable and\n   * not yet published to the associated GitHub Sponsors profile. Draft tiers\n   * cannot be used for new sponsorships and will not be in use on existing\n   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the\n   * GitHub Sponsors profile.\n   */\n  isDraft: Scalars['Boolean']['output'];\n  /**\n   * Indicates whether this tier is published to the associated GitHub Sponsors\n   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors\n   * profile, and are available for use in sponsorships if the GitHub Sponsors\n   * profile is publicly visible.\n   */\n  isPublished: Scalars['Boolean']['output'];\n  /**\n   * Indicates whether this tier has been retired from the associated GitHub\n   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors\n   * profile and cannot be chosen for new sponsorships. Existing sponsorships may\n   * still use retired tiers if the sponsor selected the tier before it was retired.\n   */\n  isRetired: Scalars['Boolean']['output'];\n  /** The sponsorships using this tier. */\n  sponsorships: SponsorshipConnection;\n};\n\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfoSponsorshipsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** The connection type for SponsorsTier. */\nexport type SponsorsTierConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsTierEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsTier>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SponsorsTierEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsTier>;\n};\n\n/** Ordering options for Sponsors tiers connections. */\nexport type SponsorsTierOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order tiers by. */\n  field: SponsorsTierOrderField;\n};\n\n/** Properties by which Sponsors tiers connections can be ordered. */\nexport enum SponsorsTierOrderField {\n  /** Order tiers by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order tiers by their monthly price in cents */\n  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'\n}\n\n/** A sponsorship relationship between a sponsor and a maintainer */\nexport type Sponsorship = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /**\n   * Whether the sponsorship is active. False implies the sponsor is a past sponsor\n   * of the maintainer, while true implies they are a current sponsor.\n   */\n  isActive: Scalars['Boolean']['output'];\n  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */\n  isOneTimePayment: Scalars['Boolean']['output'];\n  /**\n   * Whether the sponsor has chosen to receive sponsorship update emails sent from\n   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.\n   */\n  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']['output']>;\n  /**\n   * The entity that is being sponsored\n   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.\n   */\n  maintainer: User;\n  /** The privacy level for this sponsorship. */\n  privacyLevel: SponsorshipPrivacy;\n  /**\n   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.\n   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.\n   */\n  sponsor?: Maybe<User>;\n  /** The user or organization that is sponsoring, if you have permission to view them. */\n  sponsorEntity?: Maybe<Sponsor>;\n  /** The entity that is being sponsored */\n  sponsorable: Sponsorable;\n  /** The associated sponsorship tier */\n  tier?: Maybe<SponsorsTier>;\n  /** Identifies the date and time when the current tier was chosen for this sponsorship. */\n  tierSelectedAt?: Maybe<Scalars['DateTime']['output']>;\n};\n\n/** The connection type for Sponsorship. */\nexport type SponsorshipConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsorship>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n  /**\n   * The total amount in cents of all recurring sponsorships in the connection\n   * whose amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInCents: Scalars['Int']['output'];\n  /**\n   * The total amount in USD of all recurring sponsorships in the connection whose\n   * amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInDollars: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SponsorshipEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsorship>;\n};\n\n/** An update sent to sponsors of a user or organization on GitHub Sponsors. */\nexport type SponsorshipNewsletter = Node & {\n  /** The author of the newsletter. */\n  author?: Maybe<User>;\n  /** The contents of the newsletter, the message the sponsorable wanted to give. */\n  body: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Indicates if the newsletter has been made available to sponsors. */\n  isPublished: Scalars['Boolean']['output'];\n  /** The user or organization this newsletter is from. */\n  sponsorable: Sponsorable;\n  /** The subject of the newsletter, what it's about. */\n  subject: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** The connection type for SponsorshipNewsletter. */\nexport type SponsorshipNewsletterConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipNewsletterEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorshipNewsletter>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SponsorshipNewsletterEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorshipNewsletter>;\n};\n\n/** Ordering options for sponsorship newsletter connections. */\nexport type SponsorshipNewsletterOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship newsletters by. */\n  field: SponsorshipNewsletterOrderField;\n};\n\n/** Properties by which sponsorship update connections can be ordered. */\nexport enum SponsorshipNewsletterOrderField {\n  /** Order sponsorship newsletters by when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Ordering options for sponsorship connections. */\nexport type SponsorshipOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship by. */\n  field: SponsorshipOrderField;\n};\n\n/** Properties by which sponsorship connections can be ordered. */\nexport enum SponsorshipOrderField {\n  /** Order sponsorship by creation time. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The privacy of a sponsorship */\nexport enum SponsorshipPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC'\n}\n\n/** The possible default commit messages for squash merges. */\nexport enum SquashMergeCommitMessage {\n  /** Default to a blank commit message. */\n  Blank = 'BLANK',\n  /** Default to the branch's commit messages. */\n  CommitMessages = 'COMMIT_MESSAGES',\n  /** Default to the pull request's body. */\n  PrBody = 'PR_BODY'\n}\n\n/** The possible default commit titles for squash merges. */\nexport enum SquashMergeCommitTitle {\n  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */\n  CommitOrPrTitle = 'COMMIT_OR_PR_TITLE',\n  /** Default to the pull request's title. */\n  PrTitle = 'PR_TITLE'\n}\n\n/** Represents an SSH signature on a Commit or Tag. */\nexport type SshSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']['output'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']['output'];\n  /** Hex-encoded fingerprint of the key that signed this object. */\n  keyFingerprint?: Maybe<Scalars['String']['output']>;\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']['output'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']['output'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']['output'];\n};\n\n/** Ways in which star connections can be ordered. */\nexport type StarOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: StarOrderField;\n};\n\n/** Properties by which star connections can be ordered. */\nexport enum StarOrderField {\n  /** Allows ordering a list of stars by when they were created. */\n  StarredAt = 'STARRED_AT'\n}\n\n/** The connection type for User. */\nexport type StargazerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StargazerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a user that's starred a repository. */\nexport type StargazerEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  node: User;\n  /** Identifies when the item was starred. */\n  starredAt: Scalars['DateTime']['output'];\n};\n\n/** Things that can be starred. */\nexport type Starrable = {\n  id: Scalars['ID']['output'];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int']['output'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean']['output'];\n};\n\n\n/** Things that can be starred. */\nexport type StarrableStargazersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** The connection type for Repository. */\nexport type StarredRepositoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarredRepositoryEdge>>>;\n  /** Is the list of stars for this user truncated? This is true for users that have many stars. */\n  isOverLimit: Scalars['Boolean']['output'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a starred repository. */\nexport type StarredRepositoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  node: Repository;\n  /** Identifies when the item was starred. */\n  starredAt: Scalars['DateTime']['output'];\n};\n\n/** Autogenerated input type of StartOrganizationMigration */\nexport type StartOrganizationMigrationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The migration source access token. */\n  sourceAccessToken: Scalars['String']['input'];\n  /** The URL of the organization to migrate. */\n  sourceOrgUrl: Scalars['URI']['input'];\n  /** The ID of the enterprise the target organization belongs to. */\n  targetEnterpriseId: Scalars['ID']['input'];\n  /** The name of the target organization. */\n  targetOrgName: Scalars['String']['input'];\n};\n\n/** Autogenerated return type of StartOrganizationMigration */\nexport type StartOrganizationMigrationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new organization migration. */\n  orgMigration?: Maybe<OrganizationMigration>;\n};\n\n/** Autogenerated input type of StartRepositoryMigration */\nexport type StartRepositoryMigrationInput = {\n  /** The migration source access token. */\n  accessToken?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether to continue the migration on error. Defaults to `false`. */\n  continueOnError?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The signed URL to access the user-uploaded git archive. */\n  gitArchiveUrl?: InputMaybe<Scalars['String']['input']>;\n  /** The GitHub personal access token of the user importing to the target repository. */\n  githubPat?: InputMaybe<Scalars['String']['input']>;\n  /** Whether to lock the source repository. */\n  lockSource?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The signed URL to access the user-uploaded metadata archive. */\n  metadataArchiveUrl?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the organization that will own the imported repository. */\n  ownerId: Scalars['ID']['input'];\n  /** The name of the imported repository. */\n  repositoryName: Scalars['String']['input'];\n  /** Whether to skip migrating releases for the repository. */\n  skipReleases?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the migration source. */\n  sourceId: Scalars['ID']['input'];\n  /** The URL of the source repository. */\n  sourceRepositoryUrl?: InputMaybe<Scalars['URI']['input']>;\n  /** The visibility of the imported repository. */\n  targetRepoVisibility?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of StartRepositoryMigration */\nexport type StartRepositoryMigrationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The new repository migration. */\n  repositoryMigration?: Maybe<RepositoryMigration>;\n};\n\n/** Represents a commit status. */\nexport type Status = Node & {\n  /** A list of status contexts and check runs for this commit. */\n  combinedContexts: StatusCheckRollupContextConnection;\n  /** The commit this status is attached to. */\n  commit?: Maybe<Commit>;\n  /** Looks up an individual status context by context name. */\n  context?: Maybe<StatusContext>;\n  /** The individual status contexts for this commit. */\n  contexts: Array<StatusContext>;\n  id: Scalars['ID']['output'];\n  /** The combined commit status. */\n  state: StatusState;\n};\n\n\n/** Represents a commit status. */\nexport type StatusCombinedContextsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a commit status. */\nexport type StatusContextArgs = {\n  name: Scalars['String']['input'];\n};\n\n/** Required status check */\nexport type StatusCheckConfiguration = {\n  /** The status check context name that must be present on the commit. */\n  context: Scalars['String']['output'];\n  /** The optional integration ID that this status check must originate from. */\n  integrationId?: Maybe<Scalars['Int']['output']>;\n};\n\n/** Required status check */\nexport type StatusCheckConfigurationInput = {\n  /** The status check context name that must be present on the commit. */\n  context: Scalars['String']['input'];\n  /** The optional integration ID that this status check must originate from. */\n  integrationId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollup = Node & {\n  /** The commit the status and check runs are attached to. */\n  commit?: Maybe<Commit>;\n  /** A list of status contexts and check runs for this commit. */\n  contexts: StatusCheckRollupContextConnection;\n  id: Scalars['ID']['output'];\n  /** The combined status for the commit. */\n  state: StatusState;\n};\n\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollupContextsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Types that can be inside a StatusCheckRollup context. */\nexport type StatusCheckRollupContext = CheckRun | StatusContext;\n\n/** The connection type for StatusCheckRollupContext. */\nexport type StatusCheckRollupContextConnection = {\n  /** The number of check runs in this rollup. */\n  checkRunCount: Scalars['Int']['output'];\n  /** Counts of check runs by state. */\n  checkRunCountsByState?: Maybe<Array<CheckRunStateCount>>;\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StatusCheckRollupContextEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<StatusCheckRollupContext>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** The number of status contexts in this rollup. */\n  statusContextCount: Scalars['Int']['output'];\n  /** Counts of status contexts by state. */\n  statusContextCountsByState?: Maybe<Array<StatusContextStateCount>>;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type StatusCheckRollupContextEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<StatusCheckRollupContext>;\n};\n\n/** Represents an individual commit status context */\nexport type StatusContext = Node & RequirableByPullRequest & {\n  /** The avatar of the OAuth application or the user that created the status */\n  avatarUrl?: Maybe<Scalars['URI']['output']>;\n  /** This commit this status context is attached to. */\n  commit?: Maybe<Commit>;\n  /** The name of this status context. */\n  context: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The actor who created this status context. */\n  creator?: Maybe<Actor>;\n  /** The description for this status context. */\n  description?: Maybe<Scalars['String']['output']>;\n  id: Scalars['ID']['output'];\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean']['output'];\n  /** The state of this status context. */\n  state: StatusState;\n  /** The URL for this status context. */\n  targetUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/** Represents an individual commit status context */\nexport type StatusContextAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents an individual commit status context */\nexport type StatusContextIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars['ID']['input']>;\n  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Represents a count of the state of a status context. */\nexport type StatusContextStateCount = {\n  /** The number of statuses with this state. */\n  count: Scalars['Int']['output'];\n  /** The state of a status context. */\n  state: StatusState;\n};\n\n/** The possible commit status states. */\nexport enum StatusState {\n  /** Status is errored. */\n  Error = 'ERROR',\n  /** Status is expected. */\n  Expected = 'EXPECTED',\n  /** Status is failing. */\n  Failure = 'FAILURE',\n  /** Status is pending. */\n  Pending = 'PENDING',\n  /** Status is successful. */\n  Success = 'SUCCESS'\n}\n\n/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */\nexport type StripeConnectAccount = {\n  /** The account number used to identify this Stripe Connect account. */\n  accountId: Scalars['String']['output'];\n  /**\n   * The name of the country or region of an external account, such as a bank\n   * account, tied to the Stripe Connect account. Will only return a value when\n   * queried by the maintainer of the associated GitHub Sponsors profile\n   * themselves, or by an admin of the sponsorable organization.\n   */\n  billingCountryOrRegion?: Maybe<Scalars['String']['output']>;\n  /**\n   * The name of the country or region of the Stripe Connect account. Will only\n   * return a value when queried by the maintainer of the associated GitHub\n   * Sponsors profile themselves, or by an admin of the sponsorable organization.\n   */\n  countryOrRegion?: Maybe<Scalars['String']['output']>;\n  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */\n  isActive: Scalars['Boolean']['output'];\n  /** The GitHub Sponsors profile associated with this Stripe Connect account. */\n  sponsorsListing: SponsorsListing;\n  /** The URL to access this Stripe Connect account on Stripe's website. */\n  stripeDashboardUrl: Scalars['URI']['output'];\n};\n\n/** Autogenerated input type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewInput = {\n  /** The text field to set on the Pull Request Review. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The event to send to the Pull Request Review. */\n  event: PullRequestReviewEvent;\n  /** The Pull Request ID to submit any pending reviews. */\n  pullRequestId?: InputMaybe<Scalars['ID']['input']>;\n  /** The Pull Request Review ID to submit. */\n  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The submitted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** A pointer to a repository at a specific revision embedded inside another repository. */\nexport type Submodule = {\n  /** The branch of the upstream submodule for tracking updates */\n  branch?: Maybe<Scalars['String']['output']>;\n  /** The git URL of the submodule repository */\n  gitUrl: Scalars['URI']['output'];\n  /** The name of the submodule in .gitmodules */\n  name: Scalars['String']['output'];\n  /** The name of the submodule in .gitmodules (Base64-encoded) */\n  nameRaw: Scalars['Base64String']['output'];\n  /** The path in the superproject that this submodule is located in */\n  path: Scalars['String']['output'];\n  /** The path in the superproject that this submodule is located in (Base64-encoded) */\n  pathRaw: Scalars['Base64String']['output'];\n  /** The commit revision of the subproject repository being tracked by the submodule */\n  subprojectCommitOid?: Maybe<Scalars['GitObjectID']['output']>;\n};\n\n/** The connection type for Submodule. */\nexport type SubmoduleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Submodule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type SubmoduleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Submodule>;\n};\n\n/** Entities that can be subscribed to for web and email notifications. */\nexport type Subscribable = {\n  id: Scalars['ID']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n/** Represents a 'subscribed' event on a given `Subscribable`. */\nexport type SubscribedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Object referenced by event. */\n  subscribable: Subscribable;\n};\n\n/** The possible states of a subscription. */\nexport enum SubscriptionState {\n  /** The User is never notified. */\n  Ignored = 'IGNORED',\n  /** The User is notified of all conversations. */\n  Subscribed = 'SUBSCRIBED',\n  /** The User is only notified when participating or @mentioned. */\n  Unsubscribed = 'UNSUBSCRIBED'\n}\n\n/** A suggestion to review a pull request based on a user's commit history and review comments. */\nexport type SuggestedReviewer = {\n  /** Is this suggestion based on past commits? */\n  isAuthor: Scalars['Boolean']['output'];\n  /** Is this suggestion based on past review comments? */\n  isCommenter: Scalars['Boolean']['output'];\n  /** Identifies the user suggested to review the pull request. */\n  reviewer: User;\n};\n\n/** Represents a Git tag. */\nexport type Tag = GitObject & Node & {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String']['output'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI']['output'];\n  id: Scalars['ID']['output'];\n  /** The Git tag message. */\n  message?: Maybe<Scalars['String']['output']>;\n  /** The Git tag name. */\n  name: Scalars['String']['output'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID']['output'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n  /** Details about the tag author. */\n  tagger?: Maybe<GitActor>;\n  /** The Git object the tag points to. */\n  target: GitObject;\n};\n\n/** Parameters to be used for the tag_name_pattern rule */\nexport type TagNamePatternParameters = {\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean']['output'];\n  /** The operator to use for matching. */\n  operator: Scalars['String']['output'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['output'];\n};\n\n/** Parameters to be used for the tag_name_pattern rule */\nexport type TagNamePatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String']['input'];\n  /** The pattern to match with. */\n  pattern: Scalars['String']['input'];\n};\n\n/** A team of users in an organization. */\nexport type Team = MemberStatusable & Node & Subscribable & {\n  /** A list of teams that are ancestors of this team. */\n  ancestors: TeamConnection;\n  /** A URL pointing to the team's avatar. */\n  avatarUrl?: Maybe<Scalars['URI']['output']>;\n  /** List of child teams belonging to this team */\n  childTeams: TeamConnection;\n  /** The slug corresponding to the organization and team. */\n  combinedSlug: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The description of the team. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** Find a team discussion by its number. */\n  discussion?: Maybe<TeamDiscussion>;\n  /** A list of team discussions. */\n  discussions: TeamDiscussionConnection;\n  /** The HTTP path for team discussions */\n  discussionsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for team discussions */\n  discussionsUrl: Scalars['URI']['output'];\n  /** The HTTP path for editing this team */\n  editTeamResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for editing this team */\n  editTeamUrl: Scalars['URI']['output'];\n  id: Scalars['ID']['output'];\n  /** A list of pending invitations for users to this team */\n  invitations?: Maybe<OrganizationInvitationConnection>;\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n  /** A list of users who are members of this team. */\n  members: TeamMemberConnection;\n  /** The HTTP path for the team' members */\n  membersResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for the team' members */\n  membersUrl: Scalars['URI']['output'];\n  /** The name of the team. */\n  name: Scalars['String']['output'];\n  /** The HTTP path creating a new team */\n  newTeamResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL creating a new team */\n  newTeamUrl: Scalars['URI']['output'];\n  /** The notification setting that the team has set. */\n  notificationSetting: TeamNotificationSetting;\n  /** The organization that owns this team. */\n  organization: Organization;\n  /** The parent team of the team. */\n  parentTeam?: Maybe<Team>;\n  /** The level of privacy the team has. */\n  privacy: TeamPrivacy;\n  /** Finds and returns the project according to the provided project number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** List of projects this team has collaborator access to. */\n  projectsV2: ProjectV2Connection;\n  /** A list of repositories this team has access to. */\n  repositories: TeamRepositoryConnection;\n  /** The HTTP path for this team's repositories */\n  repositoriesResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this team's repositories */\n  repositoriesUrl: Scalars['URI']['output'];\n  /** The HTTP path for this team */\n  resourcePath: Scalars['URI']['output'];\n  /** The slug corresponding to the team. */\n  slug: Scalars['String']['output'];\n  /** The HTTP path for this team's teams */\n  teamsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this team's teams */\n  teamsUrl: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this team */\n  url: Scalars['URI']['output'];\n  /** Team is adminable by the viewer. */\n  viewerCanAdminister: Scalars['Boolean']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamAncestorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamChildTeamsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  immediateOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<TeamOrder>;\n  userLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamDiscussionArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A team of users in an organization. */\nexport type TeamDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isPinned?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<TeamDiscussionOrder>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamMemberStatusesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamMembersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  membership?: InputMaybe<TeamMembershipType>;\n  orderBy?: InputMaybe<TeamMemberOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<TeamMemberRole>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A team of users in an organization. */\nexport type TeamProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<ProjectV2Filters>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<TeamRepositoryOrder>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Audit log entry for a team.add_member event. */\nexport type TeamAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a team.add_repository event. */\nexport type TeamAddRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Metadata for an audit entry with action team.* */\nexport type TeamAuditEntryData = {\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a team.change_parent_team event. */\nexport type TeamChangeParentTeamAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The new parent team. */\n  parentTeam?: Maybe<Team>;\n  /** The name of the new parent team */\n  parentTeamName?: Maybe<Scalars['String']['output']>;\n  /** The name of the former parent team */\n  parentTeamNameWas?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the parent team */\n  parentTeamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the parent team */\n  parentTeamUrl?: Maybe<Scalars['URI']['output']>;\n  /** The former parent team. */\n  parentTeamWas?: Maybe<Team>;\n  /** The HTTP path for the previous parent team */\n  parentTeamWasResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the previous parent team */\n  parentTeamWasUrl?: Maybe<Scalars['URI']['output']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The connection type for Team. */\nexport type TeamConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Team>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** A team discussion. */\nexport type TeamDiscussion = Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /**\n   * Author's association with the discussion's team.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /**\n   * Identifies the discussion body hash.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  bodyVersion: Scalars['String']['output'];\n  /**\n   * A list of comments on this discussion.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  comments: TeamDiscussionCommentConnection;\n  /**\n   * The HTTP path for discussion comments\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  commentsResourcePath: Scalars['URI']['output'];\n  /**\n   * The HTTP URL for discussion comments\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  commentsUrl: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /**\n   * Whether or not the discussion is pinned.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  isPinned: Scalars['Boolean']['output'];\n  /**\n   * Whether or not the discussion is only visible to team members and org admins.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  isPrivate: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Identifies the discussion within its team.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  number: Scalars['Int']['output'];\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /**\n   * The HTTP path for this discussion\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  resourcePath: Scalars['URI']['output'];\n  /**\n   * The team that defines the context of this discussion.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  team: Team;\n  /**\n   * The title of the discussion\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  title: Scalars['String']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /**\n   * The HTTP URL for this discussion\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /**\n   * Whether or not the current viewer can pin this discussion.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  viewerCanPin: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A team discussion. */\nexport type TeamDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  fromComment?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<TeamDiscussionCommentOrder>;\n};\n\n\n/** A team discussion. */\nexport type TeamDiscussionReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A team discussion. */\nexport type TeamDiscussionUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionComment = Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /**\n   * Author's association with the comment's team.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String']['output'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']['output'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String']['output'];\n  /**\n   * The current version of the body content.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  bodyVersion: Scalars['String']['output'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /**\n   * The discussion this comment is about.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  discussion: TeamDiscussion;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']['output'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * Identifies the comment number.\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  number: Scalars['Int']['output'];\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /**\n   * The HTTP path for this comment\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  resourcePath: Scalars['URI']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /**\n   * The HTTP URL for this comment\n   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.\n   */\n  url: Scalars['URI']['output'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']['output'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']['output'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']['output'];\n};\n\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for TeamDiscussionComment. */\nexport type TeamDiscussionCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussionComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type TeamDiscussionCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussionComment>;\n};\n\n/** Ways in which team discussion comment connections can be ordered. */\nexport type TeamDiscussionCommentOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionCommentOrderField;\n};\n\n/** Properties by which team discussion comment connections can be ordered. */\nexport enum TeamDiscussionCommentOrderField {\n  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */\n  Number = 'NUMBER'\n}\n\n/** The connection type for TeamDiscussion. */\nexport type TeamDiscussionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type TeamDiscussionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussion>;\n};\n\n/** Ways in which team discussion connections can be ordered. */\nexport type TeamDiscussionOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionOrderField;\n};\n\n/** Properties by which team discussion connections can be ordered. */\nexport enum TeamDiscussionOrderField {\n  /** Allows chronological ordering of team discussions. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** An edge in a connection. */\nexport type TeamEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Team>;\n};\n\n/** The connection type for User. */\nexport type TeamMemberConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a user who is a member of a team. */\nexport type TeamMemberEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The HTTP path to the organization's member access page. */\n  memberAccessResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL to the organization's member access page. */\n  memberAccessUrl: Scalars['URI']['output'];\n  node: User;\n  /** The role the member has on the team. */\n  role: TeamMemberRole;\n};\n\n/** Ordering options for team member connections */\nexport type TeamMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order team members by. */\n  field: TeamMemberOrderField;\n};\n\n/** Properties by which team member connections can be ordered. */\nexport enum TeamMemberOrderField {\n  /** Order team members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order team members by login */\n  Login = 'LOGIN'\n}\n\n/** The possible team member roles; either 'maintainer' or 'member'. */\nexport enum TeamMemberRole {\n  /** A team maintainer has permission to add and remove team members. */\n  Maintainer = 'MAINTAINER',\n  /** A team member has no administrative permissions on the team. */\n  Member = 'MEMBER'\n}\n\n/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */\nexport enum TeamMembershipType {\n  /** Includes immediate and child team members for the team. */\n  All = 'ALL',\n  /** Includes only child team members for the team. */\n  ChildTeam = 'CHILD_TEAM',\n  /** Includes only immediate members of the team. */\n  Immediate = 'IMMEDIATE'\n}\n\n/** The possible team notification values. */\nexport enum TeamNotificationSetting {\n  /** No one will receive notifications. */\n  NotificationsDisabled = 'NOTIFICATIONS_DISABLED',\n  /** Everyone will receive notifications when the team is @mentioned. */\n  NotificationsEnabled = 'NOTIFICATIONS_ENABLED'\n}\n\n/** Ways in which team connections can be ordered. */\nexport type TeamOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: TeamOrderField;\n};\n\n/** Properties by which team connections can be ordered. */\nexport enum TeamOrderField {\n  /** Allows ordering a list of teams by name. */\n  Name = 'NAME'\n}\n\n/** The possible team privacy values. */\nexport enum TeamPrivacy {\n  /** A secret team can only be seen by its members. */\n  Secret = 'SECRET',\n  /** A visible team can be seen and @mentioned by every member of the organization. */\n  Visible = 'VISIBLE'\n}\n\n/** Audit log entry for a team.remove_member event. */\nexport type TeamRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** Audit log entry for a team.remove_repository event. */\nexport type TeamRemoveRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {\n  /** The action name */\n  action: Scalars['String']['output'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']['output']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']['output']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']['output']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']['output']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']['output']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']['output']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']['output']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n/** The connection type for Repository. */\nexport type TeamRepositoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamRepositoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** Represents a team repository. */\nexport type TeamRepositoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  node: Repository;\n  /** The permission level the team has on the repository */\n  permission: RepositoryPermission;\n};\n\n/** Ordering options for team repository connections */\nexport type TeamRepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: TeamRepositoryOrderField;\n};\n\n/** Properties by which team repository connections can be ordered. */\nexport enum TeamRepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by permission */\n  Permission = 'PERMISSION',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The role of a user on a team. */\nexport enum TeamRole {\n  /** User has admin rights on the team. */\n  Admin = 'ADMIN',\n  /** User is a member of the team. */\n  Member = 'MEMBER'\n}\n\n/** A text match within a search result. */\nexport type TextMatch = {\n  /** The specific text fragment within the property matched on. */\n  fragment: Scalars['String']['output'];\n  /** Highlights within the matched fragment. */\n  highlights: Array<TextMatchHighlight>;\n  /** The property matched on. */\n  property: Scalars['String']['output'];\n};\n\n/** Represents a single highlight in a search result match. */\nexport type TextMatchHighlight = {\n  /** The indice in the fragment where the matched text begins. */\n  beginIndice: Scalars['Int']['output'];\n  /** The indice in the fragment where the matched text ends. */\n  endIndice: Scalars['Int']['output'];\n  /** The text matched. */\n  text: Scalars['String']['output'];\n};\n\n/** A topic aggregates entities that are related to a subject. */\nexport type Topic = Node & Starrable & {\n  id: Scalars['ID']['output'];\n  /** The topic's name. */\n  name: Scalars['String']['output'];\n  /**\n   * A list of related topics, including aliases of this topic, sorted with the most relevant\n   * first. Returns up to 10 Topics.\n   */\n  relatedTopics: Array<Topic>;\n  /** A list of repositories. */\n  repositories: RepositoryConnection;\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int']['output'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean']['output'];\n};\n\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRelatedTopicsArgs = {\n  first?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n  sponsorableOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicStargazersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** Metadata for an audit entry with a topic. */\nexport type TopicAuditEntryData = {\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']['output']>;\n};\n\n/** Reason that the suggested topic is declined. */\nexport enum TopicSuggestionDeclineReason {\n  /** The suggested topic is not relevant to the repository. */\n  NotRelevant = 'NOT_RELEVANT',\n  /** The viewer does not like the suggested topic. */\n  PersonalPreference = 'PERSONAL_PREFERENCE',\n  /** The suggested topic is too general for the repository. */\n  TooGeneral = 'TOO_GENERAL',\n  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */\n  TooSpecific = 'TOO_SPECIFIC'\n}\n\n/** The possible states of a tracked issue. */\nexport enum TrackedIssueStates {\n  /** The tracked issue is closed */\n  Closed = 'CLOSED',\n  /** The tracked issue is open */\n  Open = 'OPEN'\n}\n\n/** Autogenerated input type of TransferEnterpriseOrganization */\nexport type TransferEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise where the organization should be transferred. */\n  destinationEnterpriseId: Scalars['ID']['input'];\n  /** The ID of the organization to transfer. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of TransferEnterpriseOrganization */\nexport type TransferEnterpriseOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The organization for which a transfer was initiated. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of TransferIssue */\nexport type TransferIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether to create labels if they don't exist in the target repository (matched by name) */\n  createLabelsIfMissing?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The Node ID of the issue to be transferred */\n  issueId: Scalars['ID']['input'];\n  /** The Node ID of the repository the issue should be transferred to */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of TransferIssue */\nexport type TransferIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue that was transferred */\n  issue?: Maybe<Issue>;\n};\n\n/** Represents a 'transferred' event on a given issue or pull request. */\nexport type TransferredEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The repository this came from */\n  fromRepository?: Maybe<Repository>;\n  id: Scalars['ID']['output'];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** Represents a Git tree. */\nexport type Tree = GitObject & Node & {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String']['output'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI']['output'];\n  /** A list of tree entries. */\n  entries?: Maybe<Array<TreeEntry>>;\n  id: Scalars['ID']['output'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID']['output'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n};\n\n/** Represents a Git tree entry. */\nexport type TreeEntry = {\n  /** The extension of the file */\n  extension?: Maybe<Scalars['String']['output']>;\n  /** Whether or not this tree entry is generated */\n  isGenerated: Scalars['Boolean']['output'];\n  /** The programming language this file is written in. */\n  language?: Maybe<Language>;\n  /** Number of lines in the file. */\n  lineCount?: Maybe<Scalars['Int']['output']>;\n  /** Entry file mode. */\n  mode: Scalars['Int']['output'];\n  /** Entry file name. */\n  name: Scalars['String']['output'];\n  /** Entry file name. (Base64-encoded) */\n  nameRaw: Scalars['Base64String']['output'];\n  /** Entry file object. */\n  object?: Maybe<GitObject>;\n  /** Entry file Git object ID. */\n  oid: Scalars['GitObjectID']['output'];\n  /** The full path of the file. */\n  path?: Maybe<Scalars['String']['output']>;\n  /** The full path of the file. (Base64-encoded) */\n  pathRaw?: Maybe<Scalars['Base64String']['output']>;\n  /** The Repository the tree entry belongs to */\n  repository: Repository;\n  /** Entry byte size */\n  size: Scalars['Int']['output'];\n  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */\n  submodule?: Maybe<Submodule>;\n  /** Entry file type. */\n  type: Scalars['String']['output'];\n};\n\n/** Autogenerated input type of UnarchiveProjectV2Item */\nexport type UnarchiveProjectV2ItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the ProjectV2Item to unarchive. */\n  itemId: Scalars['ID']['input'];\n  /** The ID of the Project to archive the item from. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnarchiveProjectV2Item */\nexport type UnarchiveProjectV2ItemPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item unarchived from the project. */\n  item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of UnarchiveRepository */\nexport type UnarchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the repository to unarchive. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnarchiveRepository */\nexport type UnarchiveRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository that was unarchived. */\n  repository?: Maybe<Repository>;\n};\n\n/** Represents an 'unassigned' event on any assignable object. */\nexport type UnassignedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable;\n  /** Identifies the user or mannequin that was unassigned. */\n  assignee?: Maybe<Assignee>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /**\n   * Identifies the subject (user) who was unassigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>;\n};\n\n/** Autogenerated input type of UnfollowOrganization */\nexport type UnfollowOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the organization to unfollow. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnfollowOrganization */\nexport type UnfollowOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The organization that was unfollowed. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of UnfollowUser */\nexport type UnfollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the user to unfollow. */\n  userId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnfollowUser */\nexport type UnfollowUserPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The user that was unfollowed. */\n  user?: Maybe<User>;\n};\n\n/** Represents a type that can be retrieved by a URL. */\nexport type UniformResourceLocatable = {\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI']['output'];\n  /** The URL to this resource. */\n  url: Scalars['URI']['output'];\n};\n\n/** Represents an unknown signature on a Commit or Tag. */\nexport type UnknownSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']['output'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']['output'];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']['output'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']['output'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']['output'];\n};\n\n/** Represents an 'unlabeled' event on a given issue or pull request. */\nexport type UnlabeledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the label associated with the 'unlabeled' event. */\n  label: Label;\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable;\n};\n\n/** Autogenerated input type of UnlinkProjectV2FromRepository */\nexport type UnlinkProjectV2FromRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the project to unlink from the repository. */\n  projectId: Scalars['ID']['input'];\n  /** The ID of the repository to unlink from the project. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnlinkProjectV2FromRepository */\nexport type UnlinkProjectV2FromRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository the project is no longer linked to. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UnlinkProjectV2FromTeam */\nexport type UnlinkProjectV2FromTeamInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the project to unlink from the team. */\n  projectId: Scalars['ID']['input'];\n  /** The ID of the team to unlink from the project. */\n  teamId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnlinkProjectV2FromTeam */\nexport type UnlinkProjectV2FromTeamPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The team the project is unlinked from */\n  team?: Maybe<Team>;\n};\n\n/** Autogenerated input type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Project linked to the Repository. */\n  projectId: Scalars['ID']['input'];\n  /** The ID of the Repository linked to the Project. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The linked Project. */\n  project?: Maybe<Project>;\n  /** The linked Repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UnlockLockable */\nexport type UnlockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the item to be unlocked. */\n  lockableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnlockLockable */\nexport type UnlockLockablePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The item that was unlocked. */\n  unlockedRecord?: Maybe<Lockable>;\n};\n\n/** Represents an 'unlocked' event on a given issue or pull request. */\nexport type UnlockedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Object that was unlocked. */\n  lockable: Lockable;\n};\n\n/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion comment to unmark as an answer. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The discussion that includes the comment. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The path of the file to mark as unviewed */\n  path: Scalars['String']['input'];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicateInput = {\n  /** ID of the issue or pull request currently considered canonical/authoritative/original. */\n  canonicalId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** ID of the issue or pull request currently marked as a duplicate. */\n  duplicateId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicatePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue or pull request that was marked as a duplicate. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n};\n\n/** Autogenerated input type of UnmarkProjectV2AsTemplate */\nexport type UnmarkProjectV2AsTemplateInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Project to unmark as a template. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnmarkProjectV2AsTemplate */\nexport type UnmarkProjectV2AsTemplatePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\nexport type UnmarkedAsDuplicateEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n  id: Scalars['ID']['output'];\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars['Boolean']['output'];\n};\n\n/** Autogenerated input type of UnminimizeComment */\nexport type UnminimizeCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnminimizeComment */\nexport type UnminimizeCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The comment that was unminimized. */\n  unminimizedComment?: Maybe<Minimizable>;\n};\n\n/** Autogenerated input type of UnpinIssue */\nexport type UnpinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the issue to be unpinned */\n  issueId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnpinIssue */\nexport type UnpinIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue that was unpinned */\n  issue?: Maybe<Issue>;\n};\n\n/** Represents an 'unpinned' event on a given issue or pull request. */\nexport type UnpinnedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** Autogenerated input type of UnresolveReviewThread */\nexport type UnresolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the thread to unresolve */\n  threadId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UnresolveReviewThread */\nexport type UnresolveReviewThreadPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents an 'unsubscribed' event on a given `Subscribable`. */\nexport type UnsubscribedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** Object referenced by event. */\n  subscribable: Subscribable;\n};\n\n/** Entities that can be updated. */\nexport type Updatable = {\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']['output'];\n};\n\n/** Comments that can be updated. */\nexport type UpdatableComment = {\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n};\n\n/** Autogenerated input type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Is branch creation a protected operation. */\n  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The global relay id of the branch protection rule to be updated. */\n  branchProtectionRuleId: Scalars['ID']['input'];\n  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */\n  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */\n  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * Whether users can pull changes from upstream when the branch is locked. Set to\n   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.\n   */\n  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */\n  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern?: InputMaybe<Scalars['String']['input']>;\n  /** A list of User, Team, or App IDs allowed to push to matching branches. */\n  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** Whether the most recent push must be approved by someone other than the person who pushed it */\n  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;\n  /** The list of required deployment environments */\n  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** The list of required status checks */\n  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are successful deployments required before merging. */\n  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n};\n\n/** Autogenerated return type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRulePayload = {\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateCheckRun */\nexport type UpdateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: InputMaybe<Array<CheckRunAction>>;\n  /** The node of the check. */\n  checkRunId: Scalars['ID']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The time that the check run finished. */\n  completedAt?: InputMaybe<Scalars['DateTime']['input']>;\n  /** The final conclusion of the check. */\n  conclusion?: InputMaybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: InputMaybe<Scalars['URI']['input']>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the check. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Descriptive details about the run. */\n  output?: InputMaybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n  /** The time that the check run began. */\n  startedAt?: InputMaybe<Scalars['DateTime']['input']>;\n  /** The current status. */\n  status?: InputMaybe<RequestableCheckStatusState>;\n};\n\n/** Autogenerated return type of UpdateCheckRun */\nexport type UpdateCheckRunPayload = {\n  /** The updated check run. */\n  checkRun?: Maybe<CheckRun>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesInput = {\n  /** The check suite preferences to modify. */\n  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentInput = {\n  /** The new contents of the comment body. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion comment to update. */\n  commentId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The modified discussion comment. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of UpdateDiscussion */\nexport type UpdateDiscussionInput = {\n  /** The new contents of the discussion body. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of a discussion category within the same repository to change this discussion to. */\n  categoryId?: InputMaybe<Scalars['ID']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion to update. */\n  discussionId: Scalars['ID']['input'];\n  /** The new discussion title. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateDiscussion */\nexport type UpdateDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The modified discussion. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The login of a administrator whose role is being changed. */\n  login: Scalars['String']['input'];\n  /** The new role for the Enterprise administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n/** Autogenerated return type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of changing the administrator's role. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the allow private repository forking setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the allow private repository forking policy on the enterprise. */\n  policyValue?: InputMaybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;\n  /** The value for the allow private repository forking setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated allow private repository forking setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the base repository permission setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the base repository permission setting on the enterprise. */\n  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated base repository permission setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the base repository permission setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can change repository visibility setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can change repository visibility setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can change repository visibility setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can change repository visibility setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can create repositories setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** Allow members to create internal repositories. Defaults to current value. */\n  membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Allow members to create private repositories. Defaults to current value. */\n  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Allow members to create public repositories. Defaults to current value. */\n  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']['input']>;\n  /** When false, allow member organizations to set their own repository creation member privileges. */\n  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * Value for the members can create repositories setting on the enterprise. This\n   * or the granular public/private/internal allowed fields (but not both) must be provided.\n   */\n  settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can create repositories setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can create repositories setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can delete issues setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can delete issues setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can delete issues setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can delete issues setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can delete repositories setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can delete repositories setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can delete repositories setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can delete repositories setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can invite collaborators setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can invite collaborators setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can invite collaborators setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can invite collaborators setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can make purchases setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can make purchases setting on the enterprise. */\n  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can make purchases setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can make purchases setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can update protected branches setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can update protected branches setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can update protected branches setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can update protected branches setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the members can view dependency insights setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the members can view dependency insights setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated members can view dependency insights setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can view dependency insights setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the organization projects setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the organization projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated organization projects setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the organization projects setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */\nexport type UpdateEnterpriseOwnerOrganizationRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Enterprise which the owner belongs to. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The ID of the organization for membership change. */\n  organizationId: Scalars['ID']['input'];\n  /** The role to assume in the organization. */\n  organizationRole: RoleInOrganization;\n};\n\n/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */\nexport type UpdateEnterpriseOwnerOrganizationRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of changing the owner's organization role. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfileInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the enterprise. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The Enterprise ID to update. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The location of the enterprise. */\n  location?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the enterprise. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The URL of the enterprise's website. */\n  websiteUrl?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfilePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the repository projects setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the repository projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated repository projects setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the repository projects setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the team discussions setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the team discussions setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated team discussions setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the team discussions setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the enterprise on which to set the two factor authentication required setting. */\n  enterpriseId: Scalars['ID']['input'];\n  /** The value for the two factor authentication required setting on the enterprise. */\n  settingValue: EnterpriseEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The enterprise with the updated two factor authentication required setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the two factor authentication required setting. */\n  message?: Maybe<Scalars['String']['output']>;\n};\n\n/** Autogenerated input type of UpdateEnvironment */\nexport type UpdateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The node ID of the environment. */\n  environmentId: Scalars['ID']['input'];\n  /** The ids of users or teams that can approve deployments to this environment */\n  reviewers?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The wait timer in minutes. */\n  waitTimer?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Autogenerated return type of UpdateEnvironment */\nexport type UpdateEnvironmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated environment. */\n  environment?: Maybe<Environment>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the owner on which to set the IP allow list enabled setting. */\n  ownerId: Scalars['ID']['input'];\n  /** The value for the IP allow list enabled setting. */\n  settingValue: IpAllowListEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the IP allow list entry to update. */\n  ipAllowListEntryId: Scalars['ID']['input'];\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean']['input'];\n  /** An optional name for the IP allow list entry. */\n  name?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The IP allow list entry that was updated. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the owner. */\n  ownerId: Scalars['ID']['input'];\n  /** The value for the IP allow list configuration for installed GitHub Apps setting. */\n  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>;\n};\n\n/** Autogenerated input type of UpdateIssueComment */\nexport type UpdateIssueCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the IssueComment to modify. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateIssueComment */\nexport type UpdateIssueCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated comment. */\n  issueComment?: Maybe<IssueComment>;\n};\n\n/** Autogenerated input type of UpdateIssue */\nexport type UpdateIssueInput = {\n  /** An array of Node IDs of users for this issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The body for the issue description. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Issue to modify. */\n  id: Scalars['ID']['input'];\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: InputMaybe<Scalars['ID']['input']>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The desired issue state. */\n  state?: InputMaybe<IssueState>;\n  /** The title for the issue. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateIssue */\nexport type UpdateIssuePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The issue. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the owner on which to set the restrict notifications setting. */\n  ownerId: Scalars['ID']['input'];\n  /** The value for the restrict notifications setting. */\n  settingValue: NotificationRestrictionSettingValue;\n};\n\n/** Autogenerated return type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The owner on which the setting was updated. */\n  owner?: Maybe<VerifiableDomainOwner>;\n};\n\n/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */\nexport type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Enable forking of private repositories in the organization? */\n  forkingEnabled: Scalars['Boolean']['input'];\n  /** The ID of the organization on which to set the allow private repository forking setting. */\n  organizationId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */\nexport type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars['String']['output']>;\n  /** The organization with the updated allow private repository forking setting. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */\nexport type UpdateOrganizationWebCommitSignoffSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the organization on which to set the web commit signoff setting. */\n  organizationId: Scalars['ID']['input'];\n  /** Enable signoff on web-based commits for repositories in the organization? */\n  webCommitSignoffRequired: Scalars['Boolean']['input'];\n};\n\n/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting */\nexport type UpdateOrganizationWebCommitSignoffSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of updating the web commit signoff setting. */\n  message?: Maybe<Scalars['String']['output']>;\n  /** The organization with the updated web commit signoff setting. */\n  organization?: Maybe<Organization>;\n};\n\n/** Only allow users with bypass permission to update matching refs. */\nexport type UpdateParameters = {\n  /** Branch can pull changes from its upstream repository */\n  updateAllowsFetchAndMerge: Scalars['Boolean']['output'];\n};\n\n/** Only allow users with bypass permission to update matching refs. */\nexport type UpdateParametersInput = {\n  /** Branch can pull changes from its upstream repository */\n  updateAllowsFetchAndMerge: Scalars['Boolean']['input'];\n};\n\n/** Autogenerated input type of UpdateProjectCard */\nexport type UpdateProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether or not the ProjectCard should be archived */\n  isArchived?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The note of ProjectCard. */\n  note?: InputMaybe<Scalars['String']['input']>;\n  /** The ProjectCard ID to update. */\n  projectCardId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateProjectCard */\nexport type UpdateProjectCardPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>;\n};\n\n/** Autogenerated input type of UpdateProjectColumn */\nexport type UpdateProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of project column. */\n  name: Scalars['String']['input'];\n  /** The ProjectColumn ID to update. */\n  projectColumnId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateProjectColumn */\nexport type UpdateProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated project column. */\n  projectColumn?: Maybe<ProjectColumn>;\n};\n\n/** Autogenerated input type of UpdateProject */\nexport type UpdateProjectInput = {\n  /** The description of project. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The name of project. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The Project ID to update. */\n  projectId: Scalars['ID']['input'];\n  /** Whether the project is public or not. */\n  public?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether the project is open or closed. */\n  state?: InputMaybe<ProjectState>;\n};\n\n/** Autogenerated return type of UpdateProject */\nexport type UpdateProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of UpdateProjectV2Collaborators */\nexport type UpdateProjectV2CollaboratorsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The collaborators to update. */\n  collaborators: Array<ProjectV2Collaborator>;\n  /** The ID of the project to update the collaborators for. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateProjectV2Collaborators */\nexport type UpdateProjectV2CollaboratorsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The collaborators granted a role */\n  collaborators?: Maybe<ProjectV2ActorConnection>;\n};\n\n\n/** Autogenerated return type of UpdateProjectV2Collaborators */\nexport type UpdateProjectV2CollaboratorsPayloadCollaboratorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Autogenerated input type of UpdateProjectV2DraftIssue */\nexport type UpdateProjectV2DraftIssueInput = {\n  /** The IDs of the assignees of the draft issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The body of the draft issue. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the draft issue to update. */\n  draftIssueId: Scalars['ID']['input'];\n  /** The title of the draft issue. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateProjectV2DraftIssue */\nexport type UpdateProjectV2DraftIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The draft issue updated in the project. */\n  draftIssue?: Maybe<DraftIssue>;\n};\n\n/** Autogenerated input type of UpdateProjectV2 */\nexport type UpdateProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Set the project to closed or open. */\n  closed?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the Project to update. */\n  projectId: Scalars['ID']['input'];\n  /** Set the project to public or private. */\n  public?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Set the readme description of the project. */\n  readme?: InputMaybe<Scalars['String']['input']>;\n  /** Set the short description of the project. */\n  shortDescription?: InputMaybe<Scalars['String']['input']>;\n  /** Set the title of the project. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated input type of UpdateProjectV2ItemFieldValue */\nexport type UpdateProjectV2ItemFieldValueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the field to be updated. */\n  fieldId: Scalars['ID']['input'];\n  /** The ID of the item to be updated. */\n  itemId: Scalars['ID']['input'];\n  /** The ID of the Project. */\n  projectId: Scalars['ID']['input'];\n  /** The value which will be set on the field. */\n  value: ProjectV2FieldValue;\n};\n\n/** Autogenerated return type of UpdateProjectV2ItemFieldValue */\nexport type UpdateProjectV2ItemFieldValuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated item. */\n  projectV2Item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of UpdateProjectV2ItemPosition */\nexport type UpdateProjectV2ItemPositionInput = {\n  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */\n  afterId?: InputMaybe<Scalars['ID']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the item to be moved. */\n  itemId: Scalars['ID']['input'];\n  /** The ID of the Project. */\n  projectId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateProjectV2ItemPosition */\nexport type UpdateProjectV2ItemPositionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The items in the new order */\n  items?: Maybe<ProjectV2ItemConnection>;\n};\n\n\n/** Autogenerated return type of UpdateProjectV2ItemPosition */\nexport type UpdateProjectV2ItemPositionPayloadItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Autogenerated return type of UpdateProjectV2 */\nexport type UpdateProjectV2Payload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated Project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of UpdatePullRequestBranch */\nexport type UpdatePullRequestBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The head ref oid for the upstream branch. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdatePullRequestBranch */\nexport type UpdatePullRequestBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UpdatePullRequest */\nexport type UpdatePullRequestInput = {\n  /** An array of Node IDs of users for this pull request. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository.\n   */\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  /** The contents of the pull request. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** An array of Node IDs of labels for this pull request. */\n  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The Node ID of the milestone for this pull request. */\n  milestoneId?: InputMaybe<Scalars['ID']['input']>;\n  /** An array of Node IDs for projects associated with this pull request. */\n  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']['input'];\n  /** The target state of the pull request. */\n  state?: InputMaybe<PullRequestUpdateState>;\n  /** The title of the pull request. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdatePullRequest */\nexport type UpdatePullRequestPayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the comment to modify. */\n  pullRequestReviewCommentId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated comment. */\n  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;\n};\n\n/** Autogenerated input type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewInput = {\n  /** The contents of the pull request review body. */\n  body: Scalars['String']['input'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of UpdateRef */\nexport type UpdateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Permit updates of branch Refs that are not fast-forwards? */\n  force?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The GitObjectID that the Ref shall be updated to target. */\n  oid: Scalars['GitObjectID']['input'];\n  /** The Node ID of the Ref to be updated. */\n  refId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateRef */\nexport type UpdateRefPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated Ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of UpdateRepository */\nexport type UpdateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A new description for the repository. Pass an empty string to erase the existing description. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** Indicates if the repository should have the discussions feature enabled. */\n  hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Indicates if the repository should have the project boards feature enabled. */\n  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */\n  homepageUrl?: InputMaybe<Scalars['URI']['input']>;\n  /** The new name of the repository. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the repository to update. */\n  repositoryId: Scalars['ID']['input'];\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Autogenerated return type of UpdateRepository */\nexport type UpdateRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateRepositoryRuleset */\nexport type UpdateRepositoryRulesetInput = {\n  /** A list of actors that are allowed to bypass rules in this ruleset. */\n  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The list of conditions for this ruleset */\n  conditions?: InputMaybe<RepositoryRuleConditionsInput>;\n  /** The enforcement level for this ruleset */\n  enforcement?: InputMaybe<RuleEnforcement>;\n  /** The name of the ruleset. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The global relay id of the repository ruleset to be updated. */\n  repositoryRulesetId: Scalars['ID']['input'];\n  /** The list of rules for this ruleset */\n  rules?: InputMaybe<Array<RepositoryRuleInput>>;\n  /** The target of the ruleset. */\n  target?: InputMaybe<RepositoryRulesetTarget>;\n};\n\n/** Autogenerated return type of UpdateRepositoryRuleset */\nexport type UpdateRepositoryRulesetPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The newly created Ruleset. */\n  ruleset?: Maybe<RepositoryRuleset>;\n};\n\n/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */\nexport type UpdateRepositoryWebCommitSignoffSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the repository to update. */\n  repositoryId: Scalars['ID']['input'];\n  /** Indicates if the repository should require signoff on web-based commits. */\n  webCommitSignoffRequired: Scalars['Boolean']['input'];\n};\n\n/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting */\nexport type UpdateRepositoryWebCommitSignoffSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** A message confirming the result of updating the web commit signoff setting. */\n  message?: Maybe<Scalars['String']['output']>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars['ID']['input']>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']['input']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The sponsorship that was updated. */\n  sponsorship?: Maybe<Sponsorship>;\n};\n\n/** Autogenerated input type of UpdateSubscription */\nexport type UpdateSubscriptionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The new state of the subscription. */\n  state: SubscriptionState;\n  /** The Node ID of the subscribable object to modify. */\n  subscribableId: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateSubscription */\nexport type UpdateSubscriptionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The input subscribable entity. */\n  subscribable?: Maybe<Subscribable>;\n};\n\n/** Autogenerated input type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String']['input'];\n  /** The current version of the body content. */\n  bodyVersion?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the comment to modify. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>;\n};\n\n/** Autogenerated input type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionInput = {\n  /** The updated text of the discussion. */\n  body?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * The current version of the body content. If provided, this update operation\n   * will be rejected if the given version does not match the latest version on the server.\n   */\n  bodyVersion?: InputMaybe<Scalars['String']['input']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the discussion to modify. */\n  id: Scalars['ID']['input'];\n  /** If provided, sets the pinned state of the updated discussion. */\n  pinned?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The updated title of the discussion. */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The updated discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>;\n};\n\n/** Autogenerated input type of UpdateTeamsRepository */\nexport type UpdateTeamsRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Permission that should be granted to the teams. */\n  permission: RepositoryPermission;\n  /** Repository ID being granted access to. */\n  repositoryId: Scalars['ID']['input'];\n  /** A list of teams being granted access. Limit: 10 */\n  teamIds: Array<Scalars['ID']['input']>;\n};\n\n/** Autogenerated return type of UpdateTeamsRepository */\nexport type UpdateTeamsRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The repository that was updated. */\n  repository?: Maybe<Repository>;\n  /** The teams granted permission on the repository. */\n  teams?: Maybe<Array<Team>>;\n};\n\n/** Autogenerated input type of UpdateTopics */\nexport type UpdateTopicsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']['input'];\n  /** An array of topic names. */\n  topicNames: Array<Scalars['String']['input']>;\n};\n\n/** Autogenerated return type of UpdateTopics */\nexport type UpdateTopicsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** Names of the provided topics that are not valid. */\n  invalidTopicNames?: Maybe<Array<Scalars['String']['output']>>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type User = Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean']['output'];\n  /** A URL pointing to the user's public avatar. */\n  avatarUrl: Scalars['URI']['output'];\n  /** The user's public profile bio. */\n  bio?: Maybe<Scalars['String']['output']>;\n  /** The user's public profile bio as HTML. */\n  bioHTML: Scalars['HTML']['output'];\n  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */\n  canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean']['output'];\n  /** A list of commit comments made by this user. */\n  commitComments: CommitCommentConnection;\n  /** The user's public profile company. */\n  company?: Maybe<Scalars['String']['output']>;\n  /** The user's public profile company as HTML. */\n  companyHTML: Scalars['HTML']['output'];\n  /** The collection of contributions this user has made to different repositories. */\n  contributionsCollection: ContributionsCollection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The user's publicly visible profile email. */\n  email: Scalars['String']['output'];\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];\n  /** A list of users the given user is followed by. */\n  followers: FollowerConnection;\n  /** A list of users the given user is following. */\n  following: FollowingConnection;\n  /** Find gist by repo name. */\n  gist?: Maybe<Gist>;\n  /** A list of gist comments made by this user. */\n  gistComments: GistCommentConnection;\n  /** A list of the Gists the user has created. */\n  gists: GistConnection;\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean']['output'];\n  /** The hovercard information for this user in a given context */\n  hovercard: Hovercard;\n  id: Scalars['ID']['output'];\n  /** The interaction ability settings for this user. */\n  interactionAbility?: Maybe<RepositoryInteractionAbility>;\n  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */\n  isBountyHunter: Scalars['Boolean']['output'];\n  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */\n  isCampusExpert: Scalars['Boolean']['output'];\n  /** Whether or not this user is a GitHub Developer Program member. */\n  isDeveloperProgramMember: Scalars['Boolean']['output'];\n  /** Whether or not this user is a GitHub employee. */\n  isEmployee: Scalars['Boolean']['output'];\n  /** Whether or not this user is following the viewer. Inverse of viewerIsFollowing */\n  isFollowingViewer: Scalars['Boolean']['output'];\n  /** Whether or not this user is a member of the GitHub Stars Program. */\n  isGitHubStar: Scalars['Boolean']['output'];\n  /** Whether or not the user has marked themselves as for hire. */\n  isHireable: Scalars['Boolean']['output'];\n  /** Whether or not this user is a site administrator. */\n  isSiteAdmin: Scalars['Boolean']['output'];\n  /** Whether the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean']['output'];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean']['output'];\n  /** Whether or not this user is the viewing user. */\n  isViewer: Scalars['Boolean']['output'];\n  /** A list of issue comments made by this user. */\n  issueComments: IssueCommentConnection;\n  /** A list of issues associated with this user. */\n  issues: IssueConnection;\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The user's public profile location. */\n  location?: Maybe<Scalars['String']['output']>;\n  /** The username used to login. */\n  login: Scalars['String']['output'];\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];\n  /** The user's public profile name. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** Find an organization by its login that the user belongs to. */\n  organization?: Maybe<Organization>;\n  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */\n  organizationVerifiedDomainEmails: Array<Scalars['String']['output']>;\n  /** A list of organizations the user belongs to. */\n  organizations: OrganizationConnection;\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int']['output'];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing user's projects */\n  projectsResourcePath: Scalars['URI']['output'];\n  /** The HTTP URL listing user's projects */\n  projectsUrl: Scalars['URI']['output'];\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** The user's profile pronouns */\n  pronouns?: Maybe<Scalars['String']['output']>;\n  /** A list of public keys associated with this user. */\n  publicKeys: PublicKeyConnection;\n  /** A list of pull requests associated with this user. */\n  pullRequests: PullRequestConnection;\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** A list of repositories that the user recently contributed to. */\n  repositoriesContributedTo: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n  /** The HTTP path for this user */\n  resourcePath: Scalars['URI']['output'];\n  /** Replies this user has saved */\n  savedReplies?: Maybe<SavedReplyConnection>;\n  /** The user's social media accounts, ordered as they appear on the user's profile. */\n  socialAccounts: SocialAccountConnection;\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** The sponsorships where this user or organization is the maintainer receiving the funds. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** The sponsorships where this user or organization is the funder. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /** Repositories the user has starred. */\n  starredRepositories: StarredRepositoryConnection;\n  /** The user's description of what they're currently doing. */\n  status?: Maybe<UserStatus>;\n  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */\n  topRepositories: RepositoryConnection;\n  /**\n   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has\n   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the\n   * user themselves or by a user who can manage sponsorships for the requested organization.\n   */\n  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;\n  /** The user's Twitter username. */\n  twitterUsername?: Maybe<Scalars['String']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this user */\n  url: Scalars['URI']['output'];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean']['output'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean']['output'];\n  /** Whether or not the viewer is able to follow the user. */\n  viewerCanFollow: Scalars['Boolean']['output'];\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean']['output'];\n  /** Whether or not this user is followed by the viewer. Inverse of isFollowingViewer. */\n  viewerIsFollowing: Scalars['Boolean']['output'];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean']['output'];\n  /** A list of repositories the given user is watching. */\n  watching: RepositoryConnection;\n  /** A URL pointing to the user's public website/blog. */\n  websiteUrl?: Maybe<Scalars['URI']['output']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {\n  login: Scalars['String']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCommitCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserContributionsCollectionArgs = {\n  from?: InputMaybe<Scalars['DateTime']['input']>;\n  organizationID?: InputMaybe<Scalars['ID']['input']>;\n  to?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowingArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<GistOrder>;\n  privacy?: InputMaybe<GistPrivacy>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserHovercardArgs = {\n  primarySubjectId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIsSponsoredByArgs = {\n  accountLogin: Scalars['String']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssueCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssuesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationArgs = {\n  login: Scalars['String']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationVerifiedDomainEmailsArgs = {\n  login: Scalars['String']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPackagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnableItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnedItemsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectArgs = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectV2Args = {\n  number: Scalars['Int']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']['input']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPublicKeysArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  baseRefName?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  headRefName?: InputMaybe<Scalars['String']['input']>;\n  labels?: InputMaybe<Array<Scalars['String']['input']>>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isArchived?: InputMaybe<Scalars['Boolean']['input']>;\n  isFork?: InputMaybe<Scalars['Boolean']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesContributedToArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  contributionTypes?: InputMaybe<Array<InputMaybe<RepositoryContributionType>>>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeUserRepositories?: InputMaybe<Scalars['Boolean']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']['input']>;\n  name: Scalars['String']['input'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  answered?: InputMaybe<Scalars['Boolean']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars['ID']['input']>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSavedRepliesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SavedReplyOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSocialAccountsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsoringArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsActivitiesArgs = {\n  actions?: InputMaybe<Array<SponsorsActivityAction>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  until?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipForViewerAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipForViewerAsSponsorableArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsMaintainerArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserStarredRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<StarOrder>;\n  ownedByViewer?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserTopRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: RepositoryOrder;\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserTotalSponsorshipAmountAsSponsorInCentsArgs = {\n  since?: InputMaybe<Scalars['DateTime']['input']>;\n  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;\n  until?: InputMaybe<Scalars['DateTime']['input']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserWatchingArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  isLocked?: InputMaybe<Scalars['Boolean']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** The possible durations that a user can be blocked for. */\nexport enum UserBlockDuration {\n  /** The user was blocked for 1 day */\n  OneDay = 'ONE_DAY',\n  /** The user was blocked for 30 days */\n  OneMonth = 'ONE_MONTH',\n  /** The user was blocked for 7 days */\n  OneWeek = 'ONE_WEEK',\n  /** The user was blocked permanently */\n  Permanent = 'PERMANENT',\n  /** The user was blocked for 3 days */\n  ThreeDays = 'THREE_DAYS'\n}\n\n/** Represents a 'user_blocked' event on a given user. */\nexport type UserBlockedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Number of days that the user was blocked for. */\n  blockDuration: UserBlockDuration;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  id: Scalars['ID']['output'];\n  /** The user who was blocked. */\n  subject?: Maybe<User>;\n};\n\n/** The connection type for User. */\nexport type UserConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edit on user content */\nexport type UserContentEdit = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the date and time when the object was deleted. */\n  deletedAt?: Maybe<Scalars['DateTime']['output']>;\n  /** The actor who deleted this content */\n  deletedBy?: Maybe<Actor>;\n  /** A summary of the changes for this edit */\n  diff?: Maybe<Scalars['String']['output']>;\n  /** When this content was edited */\n  editedAt: Scalars['DateTime']['output'];\n  /** The actor who edited this content */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n};\n\n/** A list of edits to content. */\nexport type UserContentEditConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserContentEditEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserContentEdit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type UserContentEditEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<UserContentEdit>;\n};\n\n/** Represents a user. */\nexport type UserEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n};\n\n/** Email attributes from External Identity */\nexport type UserEmailMetadata = {\n  /** Boolean to identify primary emails */\n  primary?: Maybe<Scalars['Boolean']['output']>;\n  /** Type of email */\n  type?: Maybe<Scalars['String']['output']>;\n  /** Email id */\n  value: Scalars['String']['output'];\n};\n\n/** The user's description of what they're currently doing. */\nexport type UserStatus = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** An emoji summarizing the user's status. */\n  emoji?: Maybe<Scalars['String']['output']>;\n  /** The status emoji as HTML. */\n  emojiHTML?: Maybe<Scalars['HTML']['output']>;\n  /** If set, the status will not be shown after this date. */\n  expiresAt?: Maybe<Scalars['DateTime']['output']>;\n  id: Scalars['ID']['output'];\n  /** Whether this status indicates the user is not fully available on GitHub. */\n  indicatesLimitedAvailability: Scalars['Boolean']['output'];\n  /** A brief message describing what the user is doing. */\n  message?: Maybe<Scalars['String']['output']>;\n  /** The organization whose members can see this status. If null, this status is publicly visible. */\n  organization?: Maybe<Organization>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The user who has this status. */\n  user: User;\n};\n\n/** The connection type for UserStatus. */\nexport type UserStatusConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserStatusEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserStatus>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type UserStatusEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<UserStatus>;\n};\n\n/** Ordering options for user status connections. */\nexport type UserStatusOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user statuses by. */\n  field: UserStatusOrderField;\n};\n\n/** Properties by which user status connections can be ordered. */\nexport enum UserStatusOrderField {\n  /** Order user statuses by when they were updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** A domain that can be verified or approved for an organization or an enterprise. */\nexport type VerifiableDomain = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The DNS host name that should be used for verification. */\n  dnsHostName?: Maybe<Scalars['URI']['output']>;\n  /** The unicode encoded domain. */\n  domain: Scalars['URI']['output'];\n  /** Whether a TXT record for verification with the expected host name was found. */\n  hasFoundHostName: Scalars['Boolean']['output'];\n  /** Whether a TXT record for verification with the expected verification token was found. */\n  hasFoundVerificationToken: Scalars['Boolean']['output'];\n  id: Scalars['ID']['output'];\n  /** Whether or not the domain is approved. */\n  isApproved: Scalars['Boolean']['output'];\n  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */\n  isRequiredForPolicyEnforcement: Scalars['Boolean']['output'];\n  /** Whether or not the domain is verified. */\n  isVerified: Scalars['Boolean']['output'];\n  /** The owner of the domain. */\n  owner: VerifiableDomainOwner;\n  /** The punycode encoded domain. */\n  punycodeEncodedDomain: Scalars['URI']['output'];\n  /** The time that the current verification token will expire. */\n  tokenExpirationTime?: Maybe<Scalars['DateTime']['output']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The current verification token for the domain. */\n  verificationToken?: Maybe<Scalars['String']['output']>;\n};\n\n/** The connection type for VerifiableDomain. */\nexport type VerifiableDomainConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<VerifiableDomainEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<VerifiableDomain>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type VerifiableDomainEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<VerifiableDomain>;\n};\n\n/** Ordering options for verifiable domain connections. */\nexport type VerifiableDomainOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order verifiable domains by. */\n  field: VerifiableDomainOrderField;\n};\n\n/** Properties by which verifiable domain connections can be ordered. */\nexport enum VerifiableDomainOrderField {\n  /** Order verifiable domains by their creation date. */\n  CreatedAt = 'CREATED_AT',\n  /** Order verifiable domains by the domain name. */\n  Domain = 'DOMAIN'\n}\n\n/** Types that can own a verifiable domain. */\nexport type VerifiableDomainOwner = Enterprise | Organization;\n\n/** Autogenerated input type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the verifiable domain to verify. */\n  id: Scalars['ID']['input'];\n};\n\n/** Autogenerated return type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']['output']>;\n  /** The verifiable domain that was verified. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** A hovercard context with a message describing how the viewer is related. */\nexport type ViewerHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']['output'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']['output'];\n  /** Identifies the user who is related to this context. */\n  viewer: User;\n};\n\n/** A subject that may be upvoted. */\nexport type Votable = {\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int']['output'];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean']['output'];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean']['output'];\n};\n\n/** A workflow contains meta information about an Actions workflow file. */\nexport type Workflow = Node & UniformResourceLocatable & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['ID']['output'];\n  /** The name of the workflow. */\n  name: Scalars['String']['output'];\n  /** The HTTP path for this workflow */\n  resourcePath: Scalars['URI']['output'];\n  /** The runs of the workflow. */\n  runs: WorkflowRunConnection;\n  /** The state of the workflow. */\n  state: WorkflowState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this workflow */\n  url: Scalars['URI']['output'];\n};\n\n\n/** A workflow contains meta information about an Actions workflow file. */\nexport type WorkflowRunsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<WorkflowRunOrder>;\n};\n\n/** A workflow run. */\nexport type WorkflowRun = Node & UniformResourceLocatable & {\n  /** The check suite this workflow run belongs to. */\n  checkSuite: CheckSuite;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']['output'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']['output']>;\n  /** The log of deployment reviews */\n  deploymentReviews: DeploymentReviewConnection;\n  /** The event that triggered the workflow run */\n  event: Scalars['String']['output'];\n  /** The workflow file */\n  file?: Maybe<WorkflowRunFile>;\n  id: Scalars['ID']['output'];\n  /** The pending deployment requests of all check runs in this workflow run */\n  pendingDeploymentRequests: DeploymentRequestConnection;\n  /** The HTTP path for this workflow run */\n  resourcePath: Scalars['URI']['output'];\n  /** A number that uniquely identifies this workflow run in its parent workflow. */\n  runNumber: Scalars['Int']['output'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']['output'];\n  /** The HTTP URL for this workflow run */\n  url: Scalars['URI']['output'];\n  /** The workflow executed in this workflow run. */\n  workflow: Workflow;\n};\n\n\n/** A workflow run. */\nexport type WorkflowRunDeploymentReviewsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** A workflow run. */\nexport type WorkflowRunPendingDeploymentRequestsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** The connection type for WorkflowRun. */\nexport type WorkflowRunConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<WorkflowRunEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<WorkflowRun>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']['output'];\n};\n\n/** An edge in a connection. */\nexport type WorkflowRunEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge. */\n  node?: Maybe<WorkflowRun>;\n};\n\n/** An executed workflow file for a workflow run. */\nexport type WorkflowRunFile = Node & UniformResourceLocatable & {\n  id: Scalars['ID']['output'];\n  /** The path of the workflow file relative to its repository. */\n  path: Scalars['String']['output'];\n  /** The direct link to the file in the repository which stores the workflow file. */\n  repositoryFileUrl: Scalars['URI']['output'];\n  /** The repository name and owner which stores the workflow file. */\n  repositoryName: Scalars['URI']['output'];\n  /** The HTTP path for this workflow run file */\n  resourcePath: Scalars['URI']['output'];\n  /** The parent workflow run execution for this file. */\n  run: WorkflowRun;\n  /** The HTTP URL for this workflow run file */\n  url: Scalars['URI']['output'];\n  /** If the viewer has permissions to push to the repository which stores the workflow. */\n  viewerCanPushRepository: Scalars['Boolean']['output'];\n  /** If the viewer has permissions to read the repository which stores the workflow. */\n  viewerCanReadRepository: Scalars['Boolean']['output'];\n};\n\n/** Ways in which lists of workflow runs can be ordered upon return. */\nexport type WorkflowRunOrder = {\n  /** The direction in which to order workflow runs by the specified field. */\n  direction: OrderDirection;\n  /** The field by which to order workflows. */\n  field: WorkflowRunOrderField;\n};\n\n/** Properties by which workflow run connections can be ordered. */\nexport enum WorkflowRunOrderField {\n  /** Order workflow runs by most recently created */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible states for a workflow. */\nexport enum WorkflowState {\n  /** The workflow is active. */\n  Active = 'ACTIVE',\n  /** The workflow was deleted from the git repository. */\n  Deleted = 'DELETED',\n  /** The workflow was disabled by default on a fork. */\n  DisabledFork = 'DISABLED_FORK',\n  /** The workflow was disabled for inactivity in the repository. */\n  DisabledInactivity = 'DISABLED_INACTIVITY',\n  /** The workflow was disabled manually. */\n  DisabledManually = 'DISABLED_MANUALLY'\n}\n\nexport type FilesQueryVariables = Exact<{\n  owner: Scalars['String']['input'];\n  repo: Scalars['String']['input'];\n  path: Scalars['String']['input'];\n}>;\n\n\nexport type FilesQuery = { repository?: { object?: { __typename: 'Blob' } | { __typename: 'Commit' } | { __typename: 'Tag' } | { __typename: 'Tree', entries?: Array<{ name: string, type: string, language?: { name: string } | null, object?: { __typename: 'Blob', text?: string | null } | { __typename: 'Commit' } | { __typename: 'Tag' } | { __typename: 'Tree' } | null }> | null } | null } | null };\n\nexport type DeleteDeploymentMutationVariables = Exact<{\n  deploymentId: Scalars['ID']['input'];\n}>;\n\n\nexport type DeleteDeploymentMutation = { deleteDeployment?: { clientMutationId?: string | null } | null };\n\nexport type DeleteDeploymentAndCommentMutationVariables = Exact<{\n  deploymentId: Scalars['ID']['input'];\n  commentId: Scalars['ID']['input'];\n}>;\n\n\nexport type DeleteDeploymentAndCommentMutation = { deleteDeployment?: { clientMutationId?: string | null } | null, deleteIssueComment?: { clientMutationId?: string | null } | null };\n\nexport type AddCommentMutationVariables = Exact<{\n  subjectId: Scalars['ID']['input'];\n  body: Scalars['String']['input'];\n}>;\n\n\nexport type AddCommentMutation = { addComment?: { commentEdge?: { node?: { id: string } | null } | null } | null };\n\nexport type EnvironmentFragmentFragment = { name: string, id: string };\n\nexport type CreateEnvironmentMutationVariables = Exact<{\n  repositoryId: Scalars['ID']['input'];\n  name: Scalars['String']['input'];\n}>;\n\n\nexport type CreateEnvironmentMutation = { createEnvironment?: { environment?: { name: string, id: string } | null } | null };\n\nexport type GetEnvironmentQueryVariables = Exact<{\n  owner: Scalars['String']['input'];\n  repo: Scalars['String']['input'];\n  environment_name: Scalars['String']['input'];\n  qualifiedName: Scalars['String']['input'];\n}>;\n\n\nexport type GetEnvironmentQuery = { repository?: { environment?: { name: string, id: string } | null, ref?: { id: string, name: string, prefix: string } | null } | null };\n\nexport class TypedDocumentString<TResult, TVariables>\n  extends String\n  implements DocumentTypeDecoration<TResult, TVariables>\n{\n  __apiType?: DocumentTypeDecoration<TResult, TVariables>['__apiType'];\n\n  constructor(private value: string, public __meta__?: Record<string, any>) {\n    super(value);\n  }\n\n  toString(): string & DocumentTypeDecoration<TResult, TVariables> {\n    return this.value;\n  }\n}\nexport const EnvironmentFragmentFragmentDoc = new TypedDocumentString(`\n    fragment EnvironmentFragment on Environment {\n  name\n  id\n}\n    `, {\"fragmentName\":\"EnvironmentFragment\"}) as unknown as TypedDocumentString<EnvironmentFragmentFragment, unknown>;\nexport const FilesDocument = new TypedDocumentString(`\n    query Files($owner: String!, $repo: String!, $path: String!) {\n  repository(owner: $owner, name: $repo) {\n    object(expression: $path) {\n      __typename\n      ... on Tree {\n        entries {\n          name\n          type\n          language {\n            name\n          }\n          object {\n            __typename\n            ... on Blob {\n              text\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `) as unknown as TypedDocumentString<FilesQuery, FilesQueryVariables>;\nexport const DeleteDeploymentDocument = new TypedDocumentString(`\n    mutation DeleteDeployment($deploymentId: ID!) {\n  deleteDeployment(input: {id: $deploymentId}) {\n    clientMutationId\n  }\n}\n    `) as unknown as TypedDocumentString<DeleteDeploymentMutation, DeleteDeploymentMutationVariables>;\nexport const DeleteDeploymentAndCommentDocument = new TypedDocumentString(`\n    mutation DeleteDeploymentAndComment($deploymentId: ID!, $commentId: ID!) {\n  deleteDeployment(input: {id: $deploymentId}) {\n    clientMutationId\n  }\n  deleteIssueComment(input: {id: $commentId}) {\n    clientMutationId\n  }\n}\n    `) as unknown as TypedDocumentString<DeleteDeploymentAndCommentMutation, DeleteDeploymentAndCommentMutationVariables>;\nexport const AddCommentDocument = new TypedDocumentString(`\n    mutation AddComment($subjectId: ID!, $body: String!) {\n  addComment(input: {subjectId: $subjectId, body: $body}) {\n    commentEdge {\n      node {\n        id\n      }\n    }\n  }\n}\n    `) as unknown as TypedDocumentString<AddCommentMutation, AddCommentMutationVariables>;\nexport const CreateEnvironmentDocument = new TypedDocumentString(`\n    mutation CreateEnvironment($repositoryId: ID!, $name: String!) {\n  createEnvironment(input: {repositoryId: $repositoryId, name: $name}) {\n    environment {\n      ...EnvironmentFragment\n    }\n  }\n}\n    fragment EnvironmentFragment on Environment {\n  name\n  id\n}`) as unknown as TypedDocumentString<CreateEnvironmentMutation, CreateEnvironmentMutationVariables>;\nexport const GetEnvironmentDocument = new TypedDocumentString(`\n    query GetEnvironment($owner: String!, $repo: String!, $environment_name: String!, $qualifiedName: String!) {\n  repository(owner: $owner, name: $repo) {\n    environment(name: $environment_name) {\n      ...EnvironmentFragment\n    }\n    ref(qualifiedName: $qualifiedName) {\n      id\n      name\n      prefix\n    }\n  }\n}\n    fragment EnvironmentFragment on Environment {\n  name\n  id\n}`) as unknown as TypedDocumentString<GetEnvironmentQuery, GetEnvironmentQueryVariables>;", "/* eslint-disable */\nimport * as types from './graphql.js';\n\n\n\n/**\n * Map of all GraphQL operations in the project.\n *\n * This map has several performance disadvantages:\n * 1. It is not tree-shakeable, so it will include all operations in the project.\n * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n * 3. It does not support dead code elimination, so it will add unused operations.\n *\n * Therefore it is highly recommended to use the babel or swc plugin for production.\n */\nconst documents = {\n    \"\\n      query Files($owner: String!, $repo: String!, $path: String!) {\\n        repository(owner: $owner, name: $repo) {\\n          object(expression: $path) {\\n            __typename\\n            ... on Tree {\\n              entries {\\n                name\\n                type\\n                language {\\n                  name\\n                }\\n                object {\\n                  __typename\\n                  ... on Blob {\\n                    text\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    \": types.FilesDocument,\n    \"\\n  mutation DeleteDeployment($deploymentId: ID!) {\\n    deleteDeployment(input: {id: $deploymentId}) {\\n      clientMutationId\\n    }\\n  }\\n\": types.DeleteDeploymentDocument,\n    \"\\n  mutation DeleteDeploymentAndComment($deploymentId: ID!, $commentId: ID!) {\\n    deleteDeployment(input: {id: $deploymentId}) {\\n      clientMutationId\\n    }\\n    deleteIssueComment(input: {id: $commentId}) {\\n      clientMutationId\\n    }\\n  }\\n\": types.DeleteDeploymentAndCommentDocument,\n    \"\\n  mutation AddComment($subjectId: ID!, $body: String!) {\\n    addComment(input: {subjectId: $subjectId, body: $body}) {\\n      commentEdge {\\n        node {\\n          id\\n        }\\n      }\\n    }\\n  }\\n\": types.AddCommentDocument,\n    \"\\n  fragment EnvironmentFragment on Environment {\\n    name\\n    id\\n  }\\n\": types.EnvironmentFragmentFragmentDoc,\n    \"\\n  mutation CreateEnvironment($repositoryId: ID!, $name: String!) {\\n    createEnvironment(input: {repositoryId: $repositoryId, name: $name}) {\\n      environment {\\n        ...EnvironmentFragment\\n      }\\n    }\\n  }\\n\": types.CreateEnvironmentDocument,\n    \"\\n  query GetEnvironment(\\n    $owner: String!\\n    $repo: String!\\n    $environment_name: String!\\n    $qualifiedName: String!\\n  ) {\\n    repository(owner: $owner, name: $repo) {\\n      environment(name: $environment_name) {\\n        ...EnvironmentFragment\\n      }\\n      ref(qualifiedName: $qualifiedName) {\\n        id\\n        name\\n        prefix\\n      }\\n    }\\n  }\\n\": types.GetEnvironmentDocument,\n};\n\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n      query Files($owner: String!, $repo: String!, $path: String!) {\\n        repository(owner: $owner, name: $repo) {\\n          object(expression: $path) {\\n            __typename\\n            ... on Tree {\\n              entries {\\n                name\\n                type\\n                language {\\n                  name\\n                }\\n                object {\\n                  __typename\\n                  ... on Blob {\\n                    text\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    \"): typeof import('./graphql.js').FilesDocument;\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  mutation DeleteDeployment($deploymentId: ID!) {\\n    deleteDeployment(input: {id: $deploymentId}) {\\n      clientMutationId\\n    }\\n  }\\n\"): typeof import('./graphql.js').DeleteDeploymentDocument;\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  mutation DeleteDeploymentAndComment($deploymentId: ID!, $commentId: ID!) {\\n    deleteDeployment(input: {id: $deploymentId}) {\\n      clientMutationId\\n    }\\n    deleteIssueComment(input: {id: $commentId}) {\\n      clientMutationId\\n    }\\n  }\\n\"): typeof import('./graphql.js').DeleteDeploymentAndCommentDocument;\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  mutation AddComment($subjectId: ID!, $body: String!) {\\n    addComment(input: {subjectId: $subjectId, body: $body}) {\\n      commentEdge {\\n        node {\\n          id\\n        }\\n      }\\n    }\\n  }\\n\"): typeof import('./graphql.js').AddCommentDocument;\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  fragment EnvironmentFragment on Environment {\\n    name\\n    id\\n  }\\n\"): typeof import('./graphql.js').EnvironmentFragmentFragmentDoc;\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  mutation CreateEnvironment($repositoryId: ID!, $name: String!) {\\n    createEnvironment(input: {repositoryId: $repositoryId, name: $name}) {\\n      environment {\\n        ...EnvironmentFragment\\n      }\\n    }\\n  }\\n\"): typeof import('./graphql.js').CreateEnvironmentDocument;\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query GetEnvironment(\\n    $owner: String!\\n    $repo: String!\\n    $environment_name: String!\\n    $qualifiedName: String!\\n  ) {\\n    repository(owner: $owner, name: $repo) {\\n      environment(name: $environment_name) {\\n        ...EnvironmentFragment\\n      }\\n      ref(qualifiedName: $qualifiedName) {\\n        id\\n        name\\n        prefix\\n      }\\n    }\\n  }\\n\"): typeof import('./graphql.js').GetEnvironmentDocument;\n\n\nexport function graphql(source: string) {\n  return (documents as any)[source] ?? {};\n}\n", "import type {GraphQLError} from 'graphql'\n\nimport {getInput} from '@unlike/github-actions-core'\n\nimport type {TypedDocumentString} from '@/gql/graphql.js'\nimport {ACTION_INPUT_GITHUB_TOKEN} from '@/src/constants.js'\n\nimport {useContext} from '../context.js'\n\n/**\n * https://github.com/octokit/graphql.js/blob/c067d9c5da27e0147d25fa215192f1d8be7e1b72/src/types.ts#L55C1-L72C3\n */\nexport type GitHubGraphQLError = Partial<GraphQLError> & {\n  /**\n   * NOT_FOUND\n   */\n  type: string\n}\n\nexport type GraphqlResponse<T = unknown> = {\n  data: T\n  errors?: GitHubGraphQLError[]\n}\nexport type Variables = Record<string, unknown>\n\ntype Options = {\n  /**\n   * Should request throw error when graphql returns errors\n   * Default is true\n   */\n  errorThrows?: boolean\n}\n\n// | string\n// | DocumentNode\n// | TypedDocumentNode<TData, TVariables>\n\nexport type RequestParams<TData, TVariables> = {\n  query: string | TypedDocumentString<TData, TVariables>\n  variables?: TVariables\n  options?: Options\n}\n\nexport const request = async <\n  TData = unknown,\n  TVariables extends Variables = Variables\n>(\n  params: RequestParams<TData, TVariables>\n): Promise<GraphqlResponse<TData>> => {\n  const {query, variables, options} = params\n  const {errorThrows} = options || {errorThrows: true}\n  const token = getInput(ACTION_INPUT_GITHUB_TOKEN, {required: true})\n\n  const {graphqlEndpoint} = useContext()\n\n  return fetch(graphqlEndpoint, {\n    method: 'POST',\n    headers: {\n      authorization: `bearer ${token}`,\n      'Content-Type': 'application/json',\n      Accept: 'application/vnd.github.flash-preview+json'\n    },\n    body: JSON.stringify({query: query.toString(), variables})\n  })\n    .then(res => res.json() as Promise<GraphqlResponse<TData>>)\n    .then(res => {\n      if (res.errors && errorThrows) {\n        throw new Error(JSON.stringify(res.errors))\n      }\n      return res\n    })\n}\n", "import {graphql} from '@/gql/gql.js'\n\nimport type {PagesDeployment} from '../cloudflare/types.js'\nimport {getDeploymentAlias} from '../cloudflare/deployments.js'\nimport {raise} from '../utils.js'\nimport {request} from './api/client.js'\nimport {useContext, useContextEvent} from './context.js'\n\nexport const MutationAddComment = graphql(/* GraphQL */ `\n  mutation AddComment($subjectId: ID!, $body: String!) {\n    addComment(input: {subjectId: $subjectId, body: $body}) {\n      commentEdge {\n        node {\n          id\n        }\n      }\n    }\n  }\n`)\n\nexport const addComment = async (\n  deployment: PagesDeployment\n): Promise<string | undefined> => {\n  const {eventName, payload} = useContextEvent()\n\n  if (eventName === 'pull_request' && payload.action !== 'closed') {\n    const prNodeId =\n      payload.pull_request.node_id ?? raise('No pull request node id')\n\n    const {sha} = useContext()\n\n    const rawBody = `## Cloudflare Pages Deployment\\n **Environment:** ${\n      deployment.environment\n    } \\n **Project:** ${\n      deployment.project_name\n    } \\n **Built with commit:** ${sha}\\n **Preview URL:** ${\n      deployment.url\n    } \\n **Branch Preview URL:** ${getDeploymentAlias(deployment)}`\n\n    const comment = await request({\n      query: MutationAddComment,\n      variables: {\n        subjectId: prNodeId,\n        body: rawBody\n      }\n    })\n    return comment.data.addComment?.commentEdge?.node?.id\n  }\n}\n", "import {error, getInput, notice} from '@unlike/github-actions-core'\n\nimport {graphql} from '@/gql/gql.js'\n\nimport {ACTION_INPUT_GITHUB_ENVIRONMENT} from '../constants.js'\nimport {request} from './api/client.js'\nimport {useContext} from './context.js'\n\nexport const EnvironmentFragment = graphql(/* GraphQL */ `\n  fragment EnvironmentFragment on Environment {\n    name\n    id\n  }\n`)\n\n/**\n * MutationCreateEnvironment will either return the environment if it exists or create it.\n * GITHUB_TOKEN Action permissions don't allow for creating environments.\n * @see {@link https://docs.github.com/en/actions/security-guides/automatic-token-authentication#granting-additional-permissions | Granting additional permissions}\n * @see {@link https://docs.github.com/en/graphql/reference/mutations#createenvironment | `createEnvironment`}\n */\nexport const MutationCreateEnvironment = graphql(/* GraphQL */ `\n  mutation CreateEnvironment($repositoryId: ID!, $name: String!) {\n    createEnvironment(input: {repositoryId: $repositoryId, name: $name}) {\n      environment {\n        ...EnvironmentFragment\n      }\n    }\n  }\n`)\n\nexport const createEnvironment = async () => {\n  const {branch, repo} = useContext()\n\n  if (!branch) throw new Error('branch is required')\n\n  const environment = await request({\n    query: MutationCreateEnvironment,\n    variables: {\n      repositoryId: repo.node_id,\n      name: branch\n    },\n    options: {\n      errorThrows: false\n    }\n  })\n\n  if (environment.errors) {\n    error(`GitHub Environment: Errors - ${JSON.stringify(environment.errors)}`)\n  }\n\n  if (!environment.data.createEnvironment?.environment) {\n    notice('GitHub Environment: Not created')\n  }\n\n  return environment.data.createEnvironment?.environment\n}\n\nexport const QueryGetEnvironment = graphql(/* GraphQL */ `\n  query GetEnvironment(\n    $owner: String!\n    $repo: String!\n    $environment_name: String!\n    $qualifiedName: String!\n  ) {\n    repository(owner: $owner, name: $repo) {\n      environment(name: $environment_name) {\n        ...EnvironmentFragment\n      }\n      ref(qualifiedName: $qualifiedName) {\n        id\n        name\n        prefix\n      }\n    }\n  }\n`)\n\n/**\n * CheckEnvironment will check if the environment exists and if it does not it\n * will error to the users to create the environment themselves.\n */\nexport const checkEnvironment = async () => {\n  const environmentName = getInput(ACTION_INPUT_GITHUB_ENVIRONMENT, {\n    required: true\n  })\n  const {repo, ref} = useContext()\n\n  const environment = await request({\n    query: QueryGetEnvironment,\n    variables: {\n      owner: repo.owner,\n      repo: repo.repo,\n      environment_name: environmentName,\n      qualifiedName: ref\n    },\n    options: {\n      errorThrows: false\n    }\n  })\n\n  if (environment.errors) {\n    error(`GitHub Environment: Errors - ${JSON.stringify(environment.errors)}`)\n  }\n\n  if (!environment.data.repository?.environment) {\n    throw new Error(`GitHub Environment: Not created for ${environmentName}`)\n  }\n\n  if (!environment.data.repository?.ref?.id) {\n    throw new Error(`GitHub Environment: No ref id ${environmentName}`)\n  }\n\n  return {\n    ...environment.data.repository.environment,\n    refId: environment.data.repository?.ref?.id\n  }\n}\n\nexport type Environment = Awaited<ReturnType<typeof checkEnvironment>>\n", "import type {\n  Deployment,\n  DeploymentStatus,\n  Exact,\n  Maybe,\n  Scalars\n} from '@/gql/graphql.js'\nimport {DeploymentStatusState} from '@/gql/graphql.js'\n\nimport type {PagesDeployment} from '../cloudflare/types.js'\nimport {getCloudflareLogEndpoint} from '../cloudflare/api/endpoints.js'\nimport {raise} from '../utils.js'\nimport {request} from './api/client.js'\nimport {useContext} from './context.js'\nimport {checkEnvironment} from './environment.js'\n\n/**\n * GitHub GraphQL Schema doesn't have Deployment Preview yet.\n * So can't use codgen for type information.\n * @see {@link https://docs.github.com/en/graphql/overview/schema-previews#deployments-preview | Deployments Preview}\n * @see {@link https://docs.github.com/en/graphql/reference/mutations#createdeployment | createDeployment}\n */\nexport const MutationCreateDeployment = `\n  mutation CreateDeployment(\n    $repositoryId: ID!\n    $environmentName: String!\n    $refId: ID!\n    $payload: String!\n    $description: String\n  ) {\n    createDeployment(\n      input: {\n        autoMerge: false\n        description: $description\n        environment: $environmentName\n        refId: $refId\n        repositoryId: $repositoryId\n        requiredContexts: []\n        payload: $payload\n      }\n    ) {\n      deployment {\n        id\n        environment\n        state\n      }\n    }\n  }\n`\n/**\n * Have to manually create type information. See above GraphQL query.\n */\ntype CreateDeploymentMutation = Partial<{\n  createDeployment: Maybe<{\n    deployment?: Maybe<Pick<Deployment, 'environment' | 'state' | 'id'>>\n  }>\n}>\ntype CreateDeploymentMutationVariables = Exact<{\n  repositoryId: Scalars['ID']['input']\n  environmentName: Scalars['String']['input']\n  refId: Scalars['ID']['input']\n  payload: Scalars['String']['input']\n  description: Scalars['String']['input']\n}>\n\n/**\n * GitHub GraphQL Schema doesn't have Deployment Preview yet.\n * So can't use codgen for type information.\n * @see {@link https://docs.github.com/en/graphql/overview/schema-previews#deployments-preview | Deployments Preview}\n * @see {@link https://docs.github.com/en/graphql/reference/mutations#createdeploymentstatus | createdeploymentstatus}\n */\nexport const MutationCreateDeploymentStatus = `\n  mutation CreateDeploymentStatus(\n    $deploymentId: ID!\n    $environment: String\n    $environmentUrl: String!\n    $logUrl: String!\n    $state: DeploymentStatusState!\n  ) {\n    createDeploymentStatus(\n      input: {\n        autoInactive: false\n        deploymentId: $deploymentId\n        environment: $environment\n        environmentUrl: $environmentUrl\n        logUrl: $logUrl\n        state: $state\n      }\n    ) {\n      deploymentStatus {\n        createdAt\n        deployment {\n          id\n          environment\n          state\n        }\n        state\n        environmentUrl\n      }\n    }\n  }\n`\n/**\n * Have to manually create type information. See above GraphQL query.\n */\nexport type CreateDeploymentStatusMutation = Partial<{\n  createDeploymentStatus: Maybe<{\n    deploymentStatus: Maybe<\n      Pick<DeploymentStatus, 'environmentUrl' | 'createdAt' | 'state'> & {\n        deployment: Maybe<Pick<Deployment, 'id' | 'environment' | 'state'>>\n      }\n    >\n  }>\n}>\nexport type CreateDeploymentStatusMutationVariables = Exact<{\n  deploymentId: Scalars['ID']['input']\n  environment: Scalars['String']['input']\n  environmentUrl: Scalars['String']['input']\n  logUrl: Scalars['String']['input']\n  state: DeploymentStatusState\n}>\n\nexport type DeploymentPayload = {\n  cloudflareId: string\n  url: string\n  commentId: Scalars['ID']['input'] | undefined\n}\n\nexport const createGitHubDeployment = async (\n  {id, url}: PagesDeployment,\n  commentId: string | undefined\n) => {\n  /**\n   * Check GitHub Environment exists to link GitHub Deployment too.\n   */\n  const {name, refId} =\n    (await checkEnvironment()) ??\n    raise('GitHub Deployment: GitHub Environment is required')\n\n  const {repo} = useContext()\n\n  const payload: DeploymentPayload = {cloudflareId: id, url, commentId}\n\n  /**\n   * Create GitHub Deployment\n   */\n  const deployment = await request<\n    CreateDeploymentMutation,\n    CreateDeploymentMutationVariables\n  >({\n    query: MutationCreateDeployment,\n    variables: {\n      repositoryId: repo.node_id,\n      environmentName: name,\n      refId: refId,\n      payload: JSON.stringify(payload),\n      description: `Cloudflare Pages Deployment: ${id}`\n    }\n  })\n  const gitHubDeploymentId =\n    deployment.data.createDeployment?.deployment?.id ??\n    raise('GitHub Deployment: GitHub deployment id is required')\n\n  /**\n   * Update GitHub Deployment Status\n   */\n  await request<\n    CreateDeploymentStatusMutation,\n    CreateDeploymentStatusMutationVariables\n  >({\n    query: MutationCreateDeploymentStatus,\n    variables: {\n      environment: name,\n      deploymentId: gitHubDeploymentId,\n      environmentUrl: url,\n      logUrl: getCloudflareLogEndpoint(id),\n      state: DeploymentStatusState.Success\n    }\n  })\n}\n", "export function lowercaseKeys(object) {\n  if (!object) {\n    return {};\n  }\n\n  return Object.keys(object).reduce((newObj, key) => {\n    newObj[key.toLowerCase()] = object[key];\n    return newObj;\n  }, {});\n}\n", "export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "import isPlainObject from \"is-plain-obj\";\n\nexport function mergeDeep(defaults, options) {\n  const result = Object.assign({}, defaults);\n\n  Object.keys(options).forEach((key) => {\n    if (isPlainObject(options[key])) {\n      if (!(key in defaults)) Object.assign(result, { [key]: options[key] });\n      else result[key] = mergeDeep(defaults[key], options[key]);\n    } else {\n      Object.assign(result, { [key]: options[key] });\n    }\n  });\n\n  return result;\n}\n", "export function removeUndefinedProperties(obj) {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      delete obj[key];\n    }\n  }\n  return obj;\n}\n", "import { lowercaseKeys } from \"./util/lowercase-keys.js\";\nimport { mergeDeep } from \"./util/merge-deep.js\";\nimport { removeUndefinedProperties } from \"./util/remove-undefined-properties.js\";\n\nexport function merge(defaults, route, options) {\n  if (typeof route === \"string\") {\n    let [method, url] = route.split(\" \");\n    options = Object.assign(url ? { method, url } : { url: method }, options);\n  } else {\n    options = Object.assign({}, route);\n  }\n\n  // lowercase header names before merging with defaults to avoid duplicates\n  options.headers = lowercaseKeys(options.headers);\n\n  // remove properties with undefined values before merging\n  removeUndefinedProperties(options);\n  removeUndefinedProperties(options.headers);\n\n  const mergedOptions = mergeDeep(defaults || {}, options);\n\n  // mediaType.previews arrays are merged, instead of overwritten\n  if (defaults && defaults.mediaType.previews.length) {\n    mergedOptions.mediaType.previews = defaults.mediaType.previews\n      .filter((preview) => !mergedOptions.mediaType.previews.includes(preview))\n      .concat(mergedOptions.mediaType.previews);\n  }\n\n  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(\n    (preview) => preview.replace(/-preview/, \"\")\n  );\n\n  return mergedOptions;\n}\n", "export function addQueryParameters(url, parameters) {\n  const separator = /\\?/.test(url) ? \"&\" : \"?\";\n  const names = Object.keys(parameters);\n\n  if (names.length === 0) {\n    return url;\n  }\n\n  const query = names\n    .map((name) => {\n      if (name === \"q\") {\n        return \"q=\" + parameters.q.split(\"+\").map(encodeURIComponent).join(\"+\");\n      }\n\n      return `${name}=${encodeURIComponent(parameters[name])}`;\n    })\n    .join(\"&\");\n\n  return url + separator + query;\n}\n", "const urlVariableRegex = /\\{[^}]+\\}/g;\n\nfunction removeNonChars(variableName) {\n  return variableName.replace(/^\\W+|\\W+$/g, \"\").split(/,/);\n}\n\nexport function extractUrlVariableNames(url) {\n  const matches = url.match(urlVariableRegex);\n\n  if (!matches) {\n    return [];\n  }\n\n  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);\n}\n", "export function omit(object, keysToOmit) {\n  return Object.keys(object)\n    .filter((option) => !keysToOmit.includes(option))\n    .reduce((obj, key) => {\n      obj[key] = object[key];\n      return obj;\n    }, {});\n}\n", "// Based on https://github.com/bramstein/url-template, licensed under BSD\n// TODO: create separate package.\n//\n// Copyright (c) 2012-2014, Bram Stein\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n\n//  1. Redistributions of source code must retain the above copyright\n//     notice, this list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright\n//     notice, this list of conditions and the following disclaimer in the\n//     documentation and/or other materials provided with the distribution.\n//  3. The name of the author may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR \"AS IS\" AND ANY EXPRESS OR IMPLIED\n// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/* c8 ignore start */\n\nfunction encodeReserved(str) {\n  return str\n    .split(/(%[0-9A-Fa-f]{2})/g)\n    .map(function (part) {\n      if (!/%[0-9A-Fa-f]/.test(part)) {\n        part = encodeURI(part).replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n      }\n      return part;\n    })\n    .join(\"\");\n}\n\nfunction encodeUnreserved(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n    return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\nfunction encodeValue(operator, value, key) {\n  value =\n    operator === \"+\" || operator === \"#\"\n      ? encodeReserved(value)\n      : encodeUnreserved(value);\n\n  if (key) {\n    return encodeUnreserved(key) + \"=\" + value;\n  } else {\n    return value;\n  }\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n  return operator === \";\" || operator === \"&\" || operator === \"?\";\n}\n\nfunction getValues(context, operator, key, modifier) {\n  var value = context[key],\n    result = [];\n\n  if (isDefined(value) && value !== \"\") {\n    if (\n      typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\"\n    ) {\n      value = value.toString();\n\n      if (modifier && modifier !== \"*\") {\n        value = value.substring(0, parseInt(modifier, 10));\n      }\n\n      result.push(\n        encodeValue(operator, value, isKeyOperator(operator) ? key : \"\")\n      );\n    } else {\n      if (modifier === \"*\") {\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function (value) {\n            result.push(\n              encodeValue(operator, value, isKeyOperator(operator) ? key : \"\")\n            );\n          });\n        } else {\n          Object.keys(value).forEach(function (k) {\n            if (isDefined(value[k])) {\n              result.push(encodeValue(operator, value[k], k));\n            }\n          });\n        }\n      } else {\n        const tmp = [];\n\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function (value) {\n            tmp.push(encodeValue(operator, value));\n          });\n        } else {\n          Object.keys(value).forEach(function (k) {\n            if (isDefined(value[k])) {\n              tmp.push(encodeUnreserved(k));\n              tmp.push(encodeValue(operator, value[k].toString()));\n            }\n          });\n        }\n\n        if (isKeyOperator(operator)) {\n          result.push(encodeUnreserved(key) + \"=\" + tmp.join(\",\"));\n        } else if (tmp.length !== 0) {\n          result.push(tmp.join(\",\"));\n        }\n      }\n    }\n  } else {\n    if (operator === \";\") {\n      if (isDefined(value)) {\n        result.push(encodeUnreserved(key));\n      }\n    } else if (value === \"\" && (operator === \"&\" || operator === \"?\")) {\n      result.push(encodeUnreserved(key) + \"=\");\n    } else if (value === \"\") {\n      result.push(\"\");\n    }\n  }\n  return result;\n}\n\nexport function parseUrl(template) {\n  return {\n    expand: expand.bind(null, template),\n  };\n}\n\nfunction expand(template, context) {\n  var operators = [\"+\", \"#\", \".\", \"/\", \";\", \"?\", \"&\"];\n\n  return template.replace(\n    /\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g,\n    function (_, expression, literal) {\n      if (expression) {\n        let operator = \"\";\n        const values = [];\n\n        if (operators.indexOf(expression.charAt(0)) !== -1) {\n          operator = expression.charAt(0);\n          expression = expression.substr(1);\n        }\n\n        expression.split(/,/g).forEach(function (variable) {\n          var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n        });\n\n        if (operator && operator !== \"+\") {\n          var separator = \",\";\n\n          if (operator === \"?\") {\n            separator = \"&\";\n          } else if (operator !== \"#\") {\n            separator = operator;\n          }\n          return (values.length !== 0 ? operator : \"\") + values.join(separator);\n        } else {\n          return values.join(\",\");\n        }\n      } else {\n        return encodeReserved(literal);\n      }\n    }\n  );\n}\n", "import { addQueryParameters } from \"./util/add-query-parameters.js\";\nimport { extractUrlVariableNames } from \"./util/extract-url-variable-names.js\";\nimport { omit } from \"./util/omit.js\";\nimport { parseUrl } from \"./util/url-template.js\";\n\nexport function parse(options) {\n  // https://fetch.spec.whatwg.org/#methods\n  let method = options.method.toUpperCase();\n\n  // replace :varname with {varname} to make it RFC 6570 compatible\n  let url = (options.url || \"/\").replace(/:([a-z]\\w+)/g, \"{$1}\");\n  let headers = Object.assign({}, options.headers);\n  let body;\n  let parameters = omit(options, [\n    \"method\",\n    \"baseUrl\",\n    \"url\",\n    \"headers\",\n    \"request\",\n    \"mediaType\",\n  ]);\n\n  // extract variable names from URL to calculate remaining variables later\n  const urlVariableNames = extractUrlVariableNames(url);\n\n  url = parseUrl(url).expand(parameters);\n\n  if (!/^http/.test(url)) {\n    url = options.baseUrl + url;\n  }\n\n  const omittedParameters = Object.keys(options)\n    .filter((option) => urlVariableNames.includes(option))\n    .concat(\"baseUrl\");\n  const remainingParameters = omit(parameters, omittedParameters);\n\n  const isBinaryRequest = /application\\/octet-stream/i.test(headers.accept);\n\n  if (!isBinaryRequest) {\n    if (options.mediaType.format) {\n      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw\n      headers.accept = headers.accept\n        .split(/,/)\n        .map((preview) =>\n          preview.replace(\n            /application\\/vnd(\\.\\w+)(\\.v3)?(\\.\\w+)?(\\+json)?$/,\n            `application/vnd$1$2.${options.mediaType.format}`\n          )\n        )\n        .join(\",\");\n    }\n\n    if (options.mediaType.previews.length) {\n      const previewsFromAcceptHeader =\n        headers.accept.match(/[\\w-]+(?=-preview)/g) || [];\n      headers.accept = previewsFromAcceptHeader\n        .concat(options.mediaType.previews)\n        .map((preview) => {\n          const format = options.mediaType.format\n            ? `.${options.mediaType.format}`\n            : \"+json\";\n          return `application/vnd.github.${preview}-preview${format}`;\n        })\n        .join(\",\");\n    }\n  }\n\n  // for GET/HEAD requests, set URL query parameters from remaining parameters\n  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    url = addQueryParameters(url, remainingParameters);\n  } else {\n    if (\"data\" in remainingParameters) {\n      body = remainingParameters.data;\n    } else {\n      if (Object.keys(remainingParameters).length) {\n        body = remainingParameters;\n      }\n    }\n  }\n\n  // default content-type for JSON if body is set\n  if (!headers[\"content-type\"] && typeof body !== \"undefined\") {\n    headers[\"content-type\"] = \"application/json; charset=utf-8\";\n  }\n\n  // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.\n  // fetch does not allow to set `content-length` header, but we can set body to an empty string\n  if ([\"PATCH\", \"PUT\"].includes(method) && typeof body === \"undefined\") {\n    body = \"\";\n  }\n\n  // Only return body/request keys if present\n  return Object.assign(\n    { method, url, headers },\n    typeof body !== \"undefined\" ? { body } : null,\n    options.request ? { request: options.request } : null\n  );\n}\n", "import { merge } from \"./merge.js\";\nimport { parse } from \"./parse.js\";\n\nexport function endpointWithDefaults(defaults, route, options) {\n  return parse(merge(defaults, route, options));\n}\n", "import { endpointWithDefaults } from \"./endpoint-with-defaults.js\";\nimport { merge } from \"./merge.js\";\nimport { parse } from \"./parse.js\";\n\nexport function withDefaults(oldDefaults, newDefaults) {\n  const DEFAULTS = merge(oldDefaults, newDefaults);\n  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);\n\n  return Object.assign(endpoint, {\n    DEFAULTS,\n    defaults: withDefaults.bind(null, DEFAULTS),\n    merge: merge.bind(null, DEFAULTS),\n    parse,\n  });\n}\n", "export function getUserAgent() {\n  if (typeof navigator === \"object\" && \"userAgent\" in navigator) {\n    return navigator.userAgent;\n  }\n\n  if (typeof process === \"object\" && \"version\" in process) {\n    return `Node.js/${process.version.substr(1)} (${process.platform}; ${\n      process.arch\n    })`;\n  }\n\n  return \"<environment undetectable>\";\n}\n", "export const VERSION = \"2.7.0\";\n", "import { getUserAgent } from \"universal-user-agent\";\n\nimport { VERSION } from \"./version.js\";\n\nconst userAgent = `octokit-next-endpoint.js/${VERSION} ${getUserAgent()}`;\n\n// DEFAULTS has all properties set that EndpointOptions has, except url.\n// So we use RequestParameters and add method as additional required property.\nexport const DEFAULTS = {\n  method: \"GET\",\n  baseUrl: \"https://api.github.com\",\n  headers: {\n    accept: \"application/vnd.github.v3+json\",\n    \"user-agent\": userAgent,\n  },\n  mediaType: {\n    format: \"\",\n    previews: [],\n  },\n};\n", "import { withDefaults } from \"./lib/with-defaults.js\";\nimport { DEFAULTS } from \"./lib/defaults.js\";\nexport { VERSION } from \"./lib/version.js\";\n\nexport const endpoint = withDefaults(null, DEFAULTS);\n", "export const VERSION = \"2.7.0\";\n", "/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport { isPlainObject };\n", "/**\n * Error with extra properties to help with debugging\n */\nexport class RequestError extends Error {\n  name;\n\n  /**\n   * http status code\n   */\n  status;\n\n  /**\n   * Request options that lead to the error.\n   */\n  request;\n\n  /**\n   * Response object if a response was received\n   */\n  response;\n\n  constructor(message, statusCode, options) {\n    super(message);\n\n    // Maintains proper stack trace (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.name = \"HttpError\";\n    this.status = statusCode;\n\n    if (\"response\" in options) {\n      this.response = options.response;\n    }\n\n    // redact request credentials without mutating original request options\n    const requestCopy = { ...options.request };\n    if (options.request.headers.authorization) {\n      requestCopy.headers = {\n        ...options.request.headers,\n        authorization: options.request.headers.authorization.replace(\n          / .*$/,\n          \" [REDACTED]\"\n        ),\n      };\n    }\n\n    requestCopy.url = requestCopy.url\n      // client_id & client_secret can be passed as URL query parameters to increase rate limit\n      // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications\n      .replace(/\\bclient_secret=\\w+/g, \"client_secret=[REDACTED]\")\n      // OAuth tokens can be passed as URL query parameters, although it is not recommended\n      // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header\n      .replace(/\\baccess_token=\\w+/g, \"access_token=[REDACTED]\");\n\n    this.request = requestCopy;\n  }\n}\n", "/* c8 ignore next 4 */\n// TODO: figure out how to test buffers\nexport default function getBufferResponse(response) {\n  return response.arrayBuffer();\n}\n", "import { isPlainObject } from \"is-plain-object\";\nimport { RequestError } from \"@octokit-next/request-error\";\n\nimport getBuffer from \"./get-buffer-response.js\";\n\nexport default function fetchWrapper(requestOptions) {\n  const log = requestOptions.request?.log || console;\n\n  if (\n    isPlainObject(requestOptions.body) ||\n    Array.isArray(requestOptions.body)\n  ) {\n    requestOptions.body = JSON.stringify(requestOptions.body);\n  }\n\n  let responseHeaders = {};\n  let status;\n  let url;\n\n  const { redirect, fetch, ...remainingRequestOptions } =\n    requestOptions.request || {};\n\n  const fetchOptions = {\n    method: requestOptions.method,\n    body: requestOptions.body,\n    headers: requestOptions.headers,\n    redirect,\n    ...remainingRequestOptions,\n  };\n\n  const requestOrGlobalFetch = fetch || globalThis.fetch;\n\n  return requestOrGlobalFetch(requestOptions.url, fetchOptions)\n    .then(async (response) => {\n      url = response.url;\n      status = response.status;\n\n      for (const keyAndValue of response.headers) {\n        responseHeaders[keyAndValue[0]] = keyAndValue[1];\n      }\n\n      if (\"deprecation\" in responseHeaders) {\n        const matches =\n          responseHeaders.link &&\n          responseHeaders.link.match(/<([^>]+)>; rel=\"deprecation\"/);\n        const deprecationLink = matches && matches.pop();\n        log.warn(\n          `[@octokit/request] \"${requestOptions.method} ${\n            requestOptions.url\n          }\" is deprecated. It is scheduled to be removed on ${\n            responseHeaders.sunset\n          }${deprecationLink ? `. See ${deprecationLink}` : \"\"}`\n        );\n      }\n\n      if (status === 204 || status === 205) {\n        return;\n      }\n\n      // GitHub API returns 200 for HEAD requests\n      if (requestOptions.method === \"HEAD\") {\n        if (status < 400) {\n          return;\n        }\n        throw new RequestError(response.statusText, status, {\n          response: {\n            url,\n            status,\n            headers: responseHeaders,\n            data: undefined,\n          },\n          request: requestOptions,\n        });\n      }\n\n      if (status === 304) {\n        throw new RequestError(\"Not modified\", status, {\n          response: {\n            url,\n            status,\n            headers: responseHeaders,\n            data: await getResponseData(response),\n          },\n          request: requestOptions,\n        });\n      }\n\n      if (status >= 400) {\n        const data = await getResponseData(response);\n        const error = new RequestError(toErrorMessage(data), status, {\n          response: {\n            url,\n            status,\n            headers: responseHeaders,\n            data,\n          },\n          request: requestOptions,\n        });\n        throw error;\n      }\n\n      return getResponseData(response);\n    })\n\n    .then((data) => {\n      return {\n        status,\n        url,\n        headers: responseHeaders,\n        data,\n      };\n    })\n\n    .catch((error) => {\n      if (error instanceof RequestError) throw error;\n\n      if (error.name === \"AbortError\") throw error;\n\n      throw new RequestError(error.message, 500, {\n        request: requestOptions,\n      });\n    });\n}\n\nasync function getResponseData(response) {\n  const contentType = response.headers.get(\"content-type\");\n\n  if (/application\\/json/.test(contentType)) {\n    return response.json();\n  }\n\n  if (!contentType || /^text\\/|charset=utf-8$/.test(contentType)) {\n    return response.text();\n  }\n  /* c8 ignore next 2 */\n  // TODO: figure out how to test buffers\n  return getBuffer(response);\n}\n\nfunction toErrorMessage(data) {\n  if (typeof data === \"string\") return data;\n\n  if (\"message\" in data) {\n    if (Array.isArray(data.errors)) {\n      return `${data.message}: ${data.errors.map(JSON.stringify).join(\", \")}`;\n    }\n    return data.message;\n  }\n  /* c8 ignore next 2 */\n  // shouldn't happen, but just in case\n  return `Unknown error: ${JSON.stringify(data)}`;\n}\n", "import fetchWrapper from \"./fetch-wrapper.js\";\n\nexport default function withDefaults(oldEndpoint, newDefaults) {\n  const endpoint = oldEndpoint.defaults(newDefaults);\n  const newApi = function (route, parameters) {\n    const endpointOptions = endpoint.merge(route, parameters);\n\n    if (!endpointOptions.request || !endpointOptions.request.hook) {\n      return fetchWrapper(endpoint.parse(endpointOptions));\n    }\n\n    const request = (route, parameters) => {\n      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));\n    };\n\n    Object.assign(request, {\n      endpoint,\n      defaults: withDefaults.bind(null, endpoint),\n    });\n\n    return endpointOptions.request.hook(request, endpointOptions);\n  };\n\n  return Object.assign(newApi, {\n    endpoint,\n    defaults: withDefaults.bind(null, endpoint),\n  });\n}\n", "import { endpoint } from \"@octokit-next/endpoint\";\nimport { getUserAgent } from \"universal-user-agent\";\n\nimport { VERSION } from \"./lib/version.js\";\nexport { VERSION } from \"./lib/version.js\";\n\nimport withDefaults from \"./lib/with-defaults.js\";\n\nexport const request = withDefaults(endpoint, {\n  headers: {\n    \"user-agent\": `octokit-next-request.js/${VERSION} ${getUserAgent()}`,\n  },\n});\n", "// @ts-check\n\nconst REGEX_IS_INSTALLATION_LEGACY = /^v1\\./;\nconst REGEX_IS_INSTALLATION = /^ghs_/;\nconst REGEX_IS_USER_TO_SERVER = /^ghu_/;\n\nexport async function auth(token) {\n  const isApp = token.split(/\\./).length === 3;\n  const isInstallation =\n    REGEX_IS_INSTALLATION_LEGACY.test(token) ||\n    REGEX_IS_INSTALLATION.test(token);\n  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);\n\n  const tokenType = isApp\n    ? \"app\"\n    : isInstallation\n    ? \"installation\"\n    : isUserToServer\n    ? \"user-to-server\"\n    : \"oauth\";\n\n  return {\n    type: \"token\",\n    token: token,\n    tokenType,\n  };\n}\n", "// @ts-check\n\n/**\n * Prefix token for usage in the Authorization header\n *\n * @param {string} token OAuth token or JSON Web Token\n */\nexport function withAuthorizationPrefix(token) {\n  if (token.split(/\\./).length === 3) {\n    return `bearer ${token}`;\n  }\n\n  return `token ${token}`;\n}\n", "// @ts-check\n\nimport { withAuthorizationPrefix } from \"./with-authorization-prefix.js\";\n\nexport async function hook(token, request, route, parameters) {\n  const endpoint = request.endpoint.merge(route, parameters);\n\n  endpoint.headers.authorization = withAuthorizationPrefix(token);\n\n  return request(endpoint);\n}\n", "// @ts-check\n\nimport { auth } from \"./lib/auth.js\";\nimport { hook } from \"./lib/hook.js\";\n\nexport function createTokenAuth(options) {\n  if (!options?.token) {\n    throw new Error(\n      \"[@octokit/auth-token] options.token not set for createTokenAuth(options)\"\n    );\n  }\n\n  if (typeof options?.token !== \"string\") {\n    throw new Error(\n      \"[@octokit/auth-token] options.token is not a string for createTokenAuth(options)\"\n    );\n  }\n\n  const token = options.token.replace(/^(token|bearer) +/i, \"\");\n\n  return Object.assign(auth.bind(null, token), {\n    hook: hook.bind(null, token),\n  });\n}\n", "export const VERSION = \"2.7.0\";\n", "function _buildMessageForResponseErrors(data) {\n  return (\n    `Request failed due to following response errors:\\n` +\n    data.errors.map((e) => ` - ${e.message}`).join(\"\\n\")\n  );\n}\n\nexport class GraphqlResponseError extends Error {\n  constructor(request, headers, response) {\n    super(_buildMessageForResponseErrors(response));\n\n    this.request = request;\n    this.headers = headers;\n    this.response = response;\n    this.name = \"GraphqlResponseError\";\n    // Expose the errors and response data in their shorthand properties.\n    this.errors = response.errors;\n    this.data = response.data;\n\n    // Maintains proper stack trace (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n", "import { GraphqlResponseError } from \"./error.js\";\n\nconst NON_VARIABLE_OPTIONS = [\n  \"method\",\n  \"baseUrl\",\n  \"url\",\n  \"headers\",\n  \"request\",\n  \"query\",\n  \"mediaType\",\n];\n\nconst FORBIDDEN_VARIABLE_OPTIONS = [\"query\", \"method\", \"url\"];\n\nconst GHES_V3_SUFFIX_REGEX = /\\/api\\/v3\\/?$/;\n\nexport function graphql(request, query, options) {\n  if (options) {\n    if (typeof query === \"string\" && \"query\" in options) {\n      return Promise.reject(\n        new Error(`[@octokit/graphql] \"query\" cannot be used as variable name`)\n      );\n    }\n\n    for (const key in options) {\n      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;\n\n      return Promise.reject(\n        new Error(`[@octokit/graphql] \"${key}\" cannot be used as variable name`)\n      );\n    }\n  }\n\n  const parsedOptions =\n    typeof query === \"string\" ? Object.assign({ query }, options) : query;\n\n  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {\n    if (NON_VARIABLE_OPTIONS.includes(key)) {\n      result[key] = parsedOptions[key];\n      return result;\n    }\n\n    if (!result.variables) {\n      result.variables = {};\n    }\n\n    result.variables[key] = parsedOptions[key];\n    return result;\n  }, {});\n\n  // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix\n  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451\n  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;\n  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {\n    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, \"/api/graphql\");\n  }\n\n  return request(requestOptions).then((response) => {\n    if (response.data.errors) {\n      const headers = {};\n      for (const key of Object.keys(response.headers)) {\n        headers[key] = response.headers[key];\n      }\n\n      throw new GraphqlResponseError(requestOptions, headers, response.data);\n    }\n\n    return response.data.data;\n  });\n}\n", "import { graphql } from \"./graphql.js\";\n\nexport function withDefaults(oldRequest, newDefaults) {\n  const newRequest = oldRequest.defaults(newDefaults);\n  const newApi = (query, options) => {\n    return graphql(newRequest, query, options);\n  };\n\n  return Object.assign(newApi, {\n    defaults: withDefaults.bind(null, newRequest),\n    endpoint: newRequest.endpoint,\n  });\n}\n", "import { request } from \"@octokit-next/request\";\nimport { getUserAgent } from \"universal-user-agent\";\n\nimport { VERSION } from \"./lib/version.js\";\nexport { VERSION } from \"./lib/version.js\";\n\nimport { withDefaults } from \"./lib/with-defaults.js\";\n\nexport const graphql = withDefaults(request, {\n  headers: {\n    \"user-agent\": `octokit-next-graphql.js/${VERSION} ${getUserAgent()}`,\n  },\n  method: \"POST\",\n  url: \"/graphql\",\n});\n\nexport { GraphqlResponseError } from \"./lib/error.js\";\n\nexport function withCustomRequest(customRequest) {\n  return withDefaults(customRequest, {\n    method: \"POST\",\n    url: \"/graphql\",\n  });\n}\n", "// @ts-check\n\nexport function register(state, name, method, options) {\n  if (typeof method !== \"function\") {\n    throw new Error(\"method for before hook must be a function\");\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (Array.isArray(name)) {\n    return name.reverse().reduce((callback, name) => {\n      return register.bind(null, state, name, callback, options);\n    }, method)();\n  }\n\n  return Promise.resolve().then(() => {\n    if (!state.registry[name]) {\n      return method(options);\n    }\n\n    return state.registry[name].reduce((method, registered) => {\n      return registered.hook.bind(null, method, options);\n    }, method)();\n  });\n}\n", "// @ts-check\n\nexport function addHook(state, kind, name, hook) {\n  const orig = hook;\n  if (!state.registry[name]) {\n    state.registry[name] = [];\n  }\n\n  if (kind === \"before\") {\n    hook = (method, options) => {\n      return Promise.resolve()\n        .then(orig.bind(null, options))\n        .then(method.bind(null, options));\n    };\n  }\n\n  if (kind === \"after\") {\n    hook = (method, options) => {\n      let result;\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .then((result_) => {\n          result = result_;\n          return orig(result, options);\n        })\n        .then(() => {\n          return result;\n        });\n    };\n  }\n\n  if (kind === \"error\") {\n    hook = (method, options) => {\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .catch((error) => {\n          return orig(error, options);\n        });\n    };\n  }\n\n  state.registry[name].push({\n    hook: hook,\n    orig: orig,\n  });\n}\n", "// @ts-check\n\nexport function removeHook(state, name, method) {\n  if (!state.registry[name]) {\n    return;\n  }\n\n  const index = state.registry[name]\n    .map((registered) => {\n      return registered.orig;\n    })\n    .indexOf(method);\n\n  if (index === -1) {\n    return;\n  }\n\n  state.registry[name].splice(index, 1);\n}\n", "// @ts-check\n\nimport { register } from \"./lib/register.js\";\nimport { addHook } from \"./lib/add.js\";\nimport { removeHook } from \"./lib/remove.js\";\n\n// bind with array of arguments: https://stackoverflow.com/a/21792913\nconst bind = Function.bind;\nconst bindable = bind.bind(bind);\n\nfunction bindApi(hook, state, name) {\n  const removeHookRef = bindable(removeHook, null).apply(\n    null,\n    name ? [state, name] : [state]\n  );\n  hook.api = { remove: removeHookRef };\n  hook.remove = removeHookRef;\n  [\"before\", \"error\", \"after\", \"wrap\"].forEach((kind) => {\n    const args = name ? [state, kind, name] : [state, kind];\n    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);\n  });\n}\n\nfunction Singular() {\n  const singularHookName = Symbol(\"Singular\");\n  const singularHookState = {\n    registry: {},\n  };\n  const singularHook = register.bind(null, singularHookState, singularHookName);\n  bindApi(singularHook, singularHookState, singularHookName);\n  return singularHook;\n}\n\nfunction Collection() {\n  const state = {\n    registry: {},\n  };\n\n  const hook = register.bind(null, state);\n  bindApi(hook, state);\n\n  return hook;\n}\n\nexport default { Singular, Collection };\n", "export const VERSION = \"2.7.0\";\n", "import { endpoint } from \"@octokit-next/endpoint\";\nimport { request } from \"@octokit-next/request\";\nimport { createTokenAuth } from \"@octokit-next/auth-token\";\nimport { withCustomRequest } from \"@octokit-next/graphql\";\nimport { getUserAgent } from \"universal-user-agent\";\nimport Hook from \"before-after-hook\";\n\nimport { VERSION } from \"./lib/version.js\";\n\nexport class Octokit {\n  static VERSION = VERSION;\n  static DEFAULTS = {\n    baseUrl: endpoint.DEFAULTS.baseUrl,\n    userAgent: `octokit-next-core.js/${VERSION} ${getUserAgent()}`,\n  };\n\n  static withPlugins(newPlugins) {\n    const currentPlugins = this.PLUGINS;\n    return class extends this {\n      static PLUGINS = currentPlugins.concat(\n        newPlugins.filter((plugin) => !currentPlugins.includes(plugin))\n      );\n    };\n  }\n\n  static withDefaults(defaults) {\n    const newDefaultUserAgent = [defaults?.userAgent, this.DEFAULTS.userAgent]\n      .filter(Boolean)\n      .join(\" \");\n\n    const newDefaults = {\n      ...this.DEFAULTS,\n      ...defaults,\n      userAgent: newDefaultUserAgent,\n      request: {\n        ...this.DEFAULTS.request,\n        ...defaults?.request,\n      },\n    };\n\n    return class extends this {\n      constructor(options) {\n        if (typeof defaults === \"function\") {\n          super(defaults(options, newDefaults));\n          return;\n        }\n\n        super(options);\n      }\n\n      static DEFAULTS = newDefaults;\n    };\n  }\n\n  static PLUGINS = [];\n\n  constructor(options = {}) {\n    this.options = {\n      ...this.constructor.DEFAULTS,\n      ...options,\n      request: {\n        ...this.constructor.DEFAULTS.request,\n        ...options?.request,\n      },\n    };\n\n    const hook = new Hook.Collection();\n\n    const requestDefaults = {\n      baseUrl: this.options.baseUrl,\n      headers: {},\n      request: {\n        ...this.options.request,\n        hook: hook.bind(null, \"request\"),\n      },\n      mediaType: {\n        previews: [],\n        format: \"\",\n      },\n    };\n\n    // prepend default user agent with `options.userAgent` if set\n    const userAgent = [options?.userAgent, this.constructor.DEFAULTS.userAgent]\n      .filter(Boolean)\n      .join(\" \");\n\n    requestDefaults.headers[\"user-agent\"] = userAgent;\n\n    if (this.options.previews) {\n      requestDefaults.mediaType.previews = this.options.previews;\n    }\n\n    if (this.options.timeZone) {\n      requestDefaults.headers[\"time-zone\"] = this.options.timeZone;\n    }\n\n    // Apply plugins\n    this.constructor.PLUGINS.forEach((plugin) => {\n      Object.assign(this, plugin(this, this.options));\n    });\n\n    // API\n    this.request = request.defaults(requestDefaults);\n    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);\n    this.log = Object.assign(\n      {\n        debug: () => {},\n        info: () => {},\n        warn: console.warn.bind(console),\n        error: console.error.bind(console),\n      },\n      this.options.log\n    );\n    this.hook = hook;\n\n    // Auth\n    // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance\n    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.\n    // (2) If only `options.auth` is set, use the default token authentication strategy.\n    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.\n    if (!this.options.authStrategy) {\n      if (!this.options.auth) {\n        // (1)\n        this.auth = async () => ({\n          type: \"unauthenticated\",\n        });\n      } else {\n        // (2)\n        const auth = createTokenAuth({ token: this.options.auth });\n        hook.wrap(\"request\", auth.hook);\n        this.auth = auth;\n      }\n    } else {\n      // (3)\n      const { authStrategy, ...otherOptions } = this.options;\n      const auth = authStrategy(\n        Object.assign(\n          {\n            request: this.request,\n            log: this.log,\n            // we pass the current octokit instance as well as its constructor options\n            // to allow for authentication strategies that return a new octokit instance\n            // that shares the same internal state as the current one. The original\n            // requirement for this was the \"event-octokit\" authentication strategy\n            // of https://github.com/probot/octokit-auth-probot.\n            octokit: this,\n            octokitOptions: otherOptions,\n          },\n          this.options.auth\n        )\n      );\n      hook.wrap(\"request\", auth.hook);\n      this.auth = auth;\n    }\n  }\n}\n", "import type {PaginatingEndpoints} from '@octokit/plugin-paginate-rest'\n\nimport {Octokit} from '@octokit-next/core'\nimport {paginateRest} from '@octokit/plugin-paginate-rest'\nimport {getInput} from '@unlike/github-actions-core'\n\nimport {ACTION_INPUT_GITHUB_TOKEN} from '@/src/constants.js'\n\n/**\n * @see {@link https://github.com/octokit/plugin-paginate-rest.js/blob/44d8b933b8fb495fb7b8d95661452f23b482ea55/src/types.ts#L55}\n */\ntype DataType<T> = 'data' extends keyof T ? T['data'] : unknown\n\nexport type PaginateResponse<T extends keyof PaginatingEndpoints> = DataType<\n  PaginatingEndpoints[T]['response']\n>\n\nexport const paginate = async <T extends keyof PaginatingEndpoints>(\n  endpoint: T,\n  options: PaginatingEndpoints[T]['parameters']\n): Promise<PaginateResponse<T>> => {\n  const token = getInput(ACTION_INPUT_GITHUB_TOKEN, {required: true})\n\n  // TODO:@andykenward #32 fix types in @octokit-next/core or @octokit/plugin-paginate-rest . Can then remove the ts-expect-error & as Promise<PaginateResponse<T>>\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  return new (Octokit.withPlugins([paginateRest]))({auth: token}).paginate(\n    endpoint,\n    options\n  ) as Promise<PaginateResponse<T>>\n}\n", "import type {PaginateResponse} from './api/paginate.js'\nimport {paginate} from './api/paginate.js'\nimport {useContext} from './context.js'\n\n/**\n * Get all github deployments from the current repo ref\n */\nexport const getDeployments = async (): Promise<\n  PaginateResponse<'GET /repos/{owner}/{repo}/deployments'>\n> => {\n  const {repo, ref} = useContext()\n\n  const deployments = await paginate('GET /repos/{owner}/{repo}/deployments', {\n    owner: repo.owner,\n    repo: repo.repo,\n    ref: ref,\n    per_page: 100\n  })\n\n  return deployments\n}\n", "import {info, warning} from '@unlike/github-actions-core'\n\nimport {graphql} from '@/gql/gql.js'\nimport {DeploymentStatusState} from '@/gql/graphql.js'\n\nimport type {\n  CreateDeploymentStatusMutation,\n  CreateDeploymentStatusMutationVariables,\n  DeploymentPayload\n} from './github/index.js'\nimport {getCloudflareLogEndpoint} from './cloudflare/api/endpoints.js'\nimport {deleteDeployment} from './cloudflare/deployments.js'\nimport {\n  getDeployments,\n  MutationCreateDeploymentStatus,\n  request,\n  useContextEvent\n} from './github/index.js'\n\nconst idDeploymentPayload = (\n  payload:\n    | string\n    | {\n        [key: string]: unknown\n      }\n): payload is DeploymentPayload => {\n  const parsedPayload =\n    typeof payload === 'string' ? JSON.parse(payload) : payload\n  if (!parsedPayload || typeof parsedPayload !== 'object') return false\n  return 'cloudflareId' in parsedPayload && 'url' in parsedPayload\n}\n\nconst MutationDeleteDeployment = graphql(/* GraphQL */ `\n  mutation DeleteDeployment($deploymentId: ID!) {\n    deleteDeployment(input: {id: $deploymentId}) {\n      clientMutationId\n    }\n  }\n`)\n\nconst MutationDeleteDeploymentAndComment = graphql(/* GraphQL */ `\n  mutation DeleteDeploymentAndComment($deploymentId: ID!, $commentId: ID!) {\n    deleteDeployment(input: {id: $deploymentId}) {\n      clientMutationId\n    }\n    deleteIssueComment(input: {id: $commentId}) {\n      clientMutationId\n    }\n  }\n`)\n\nexport const deleteDeployments = async () => {\n  /**\n   * Check if event is pull_request and is closed\n   */\n  const {eventName, payload} = useContextEvent()\n\n  if (eventName !== 'pull_request') return\n  if (payload.action !== 'closed') return\n\n  const deployments = await getDeployments()\n\n  if (deployments.length === 0) {\n    info('No deployments found to delete')\n    return\n  }\n  for (const deployment of deployments) {\n    const payload = deployment.payload\n\n    if (!idDeploymentPayload(payload)) {\n      info(`Deployment ${deployment.id} has no payload`)\n      continue\n    }\n\n    const {cloudflareId, commentId, url} = payload\n\n    /**\n     * Delete Cloudflare deployment\n     */\n    const deletedCloudflareDeployment = await deleteDeployment(cloudflareId)\n    if (!deletedCloudflareDeployment) continue\n    info(`Cloudflare Deployment Deleted: ${cloudflareId}`)\n    /**\n     * On success of Cloudflare deployment delete GitHub deployment & and comment.\n     */\n\n    const updateStatusGitHubDeployment = await request<\n      CreateDeploymentStatusMutation,\n      CreateDeploymentStatusMutationVariables\n    >({\n      query: MutationCreateDeploymentStatus,\n      variables: {\n        environment: deployment.environment,\n        deploymentId: deployment.node_id,\n        environmentUrl: url,\n        logUrl: getCloudflareLogEndpoint(cloudflareId),\n        state: DeploymentStatusState.Inactive\n      },\n      options: {\n        errorThrows: false\n      }\n    })\n\n    if (updateStatusGitHubDeployment.errors) {\n      warning(\n        `Error updating GitHub deployment status: ${JSON.stringify(\n          updateStatusGitHubDeployment.errors\n        )}`\n      )\n      continue\n    }\n\n    const deletedGitHubDeployment = commentId\n      ? await request({\n          query: MutationDeleteDeploymentAndComment,\n          variables: {\n            deploymentId: deployment.node_id,\n            commentId: commentId\n          },\n          options: {\n            errorThrows: false\n          }\n        })\n      : await request({\n          query: MutationDeleteDeployment,\n          variables: {\n            deploymentId: deployment.node_id\n          },\n          options: {\n            errorThrows: false\n          }\n        })\n\n    if (deletedGitHubDeployment.errors) {\n      warning(\n        `Error deleting GitHub deployment: ${JSON.stringify(\n          deletedGitHubDeployment.errors\n        )}`\n      )\n    }\n    info(`GitHub Deployment Deleted: ${deployment.node_id}`)\n    /**\n     * Add comment with summary of deleted deployments etc?\n     */\n  }\n}\n", "/* eslint-disable no-console */\n\nimport {createDeployment} from './cloudflare/deployments.js'\nimport {getProject} from './cloudflare/project/get-project.js'\nimport {deleteDeployments} from './delete.js'\nimport {\n  addComment,\n  createGitHubDeployment,\n  useContextEvent\n} from './github/index.js'\n\nexport async function run() {\n  const {eventName, payload} = useContextEvent()\n\n  /**\n   * Only support eventName push & pull_request.\n   */\n  if (eventName !== 'push' && eventName !== 'pull_request') return\n\n  /**\n   * Validate Cloudflare project\n   */\n  await getProject()\n\n  if (eventName === 'pull_request' && payload.action === 'closed') {\n    await deleteDeployments()\n    return\n  }\n\n  const cloudflareDeployment = await createDeployment()\n  const commentId = await addComment(cloudflareDeployment)\n  await createGitHubDeployment(cloudflareDeployment, commentId)\n}\n", "import {setFailed} from '@unlike/github-actions-core'\n\nimport {run} from './main.js'\n\ntry {\n  void run()\n} catch (error) {\n  // TODO: check setFailed\n  if (error instanceof Error) setFailed(error.message)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU;AACjB,UAAM,OAAO;AAEb,QAAI,KAAK,UAAQ,IAAI;AAErB,aAAS,aAAcA,OAAM,SAAS;AACpC,UAAI,UAAU,QAAQ,YAAY,SAChC,QAAQ,UAAU,QAAQ,IAAI;AAEhC,UAAI,CAAC,SAAS;AACZ,eAAO;AAAA,MACT;AAEA,gBAAU,QAAQ,MAAM,GAAG;AAC3B,UAAI,QAAQ,QAAQ,EAAE,MAAM,IAAI;AAC9B,eAAO;AAAA,MACT;AACA,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAI,IAAI,QAAQ,CAAC,EAAE,YAAY;AAC/B,YAAI,KAAKA,MAAK,OAAO,CAAC,EAAE,MAAM,EAAE,YAAY,MAAM,GAAG;AACnD,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAnBS;AAqBT,aAAS,UAAW,MAAMA,OAAM,SAAS;AACvC,UAAI,CAAC,KAAK,eAAe,KAAK,CAAC,KAAK,OAAO,GAAG;AAC5C,eAAO;AAAA,MACT;AACA,aAAO,aAAaA,OAAM,OAAO;AAAA,IACnC;AALS;AAOT,aAAS,MAAOA,OAAM,SAAS,IAAI;AACjC,SAAG,KAAKA,OAAM,SAAU,IAAI,MAAM;AAChC,WAAG,IAAI,KAAK,QAAQ,UAAU,MAAMA,OAAM,OAAO,CAAC;AAAA,MACpD,CAAC;AAAA,IACH;AAJS;AAMT,aAAS,KAAMA,OAAM,SAAS;AAC5B,aAAO,UAAU,GAAG,SAASA,KAAI,GAAGA,OAAM,OAAO;AAAA,IACnD;AAFS;AAAA;AAAA;;;ACvCT;AAAA;AAAA,WAAO,UAAU;AACjB,UAAM,OAAO;AAEb,QAAI,KAAK,UAAQ,IAAI;AAErB,aAAS,MAAOC,OAAM,SAAS,IAAI;AACjC,SAAG,KAAKA,OAAM,SAAU,IAAI,MAAM;AAChC,WAAG,IAAI,KAAK,QAAQ,UAAU,MAAM,OAAO,CAAC;AAAA,MAC9C,CAAC;AAAA,IACH;AAJS;AAMT,aAAS,KAAMA,OAAM,SAAS;AAC5B,aAAO,UAAU,GAAG,SAASA,KAAI,GAAG,OAAO;AAAA,IAC7C;AAFS;AAIT,aAAS,UAAW,MAAM,SAAS;AACjC,aAAO,KAAK,OAAO,KAAK,UAAU,MAAM,OAAO;AAAA,IACjD;AAFS;AAIT,aAAS,UAAW,MAAM,SAAS;AACjC,UAAI,MAAM,KAAK;AACf,UAAI,MAAM,KAAK;AACf,UAAI,MAAM,KAAK;AAEf,UAAI,QAAQ,QAAQ,QAAQ,SAC1B,QAAQ,MAAM,QAAQ,UAAU,QAAQ,OAAO;AACjD,UAAI,QAAQ,QAAQ,QAAQ,SAC1B,QAAQ,MAAM,QAAQ,UAAU,QAAQ,OAAO;AAEjD,UAAI,IAAI,SAAS,OAAO,CAAC;AACzB,UAAI,IAAI,SAAS,OAAO,CAAC;AACzB,UAAI,IAAI,SAAS,OAAO,CAAC;AACzB,UAAI,KAAK,IAAI;AAEb,UAAI,MAAO,MAAM,KACd,MAAM,KAAM,QAAQ,SACpB,MAAM,KAAM,QAAQ,SACpB,MAAM,MAAO,UAAU;AAE1B,aAAO;AAAA,IACT;AArBS;AAAA;AAAA;;;ACnBT;AAAA;AAAA,QAAI,KAAK,UAAQ,IAAI;AACrB,QAAI;AACJ,QAAI,QAAQ,aAAa,WAAW,OAAO,iBAAiB;AAC1D,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAEA,WAAO,UAAU;AACjB,UAAM,OAAO;AAEb,aAAS,MAAOC,OAAM,SAAS,IAAI;AACjC,UAAI,OAAO,YAAY,YAAY;AACjC,aAAK;AACL,kBAAU,CAAC;AAAA,MACb;AAEA,UAAI,CAAC,IAAI;AACP,YAAI,OAAO,YAAY,YAAY;AACjC,gBAAM,IAAI,UAAU,uBAAuB;AAAA,QAC7C;AAEA,eAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,gBAAMA,OAAM,WAAW,CAAC,GAAG,SAAU,IAAI,IAAI;AAC3C,gBAAI,IAAI;AACN,qBAAO,EAAE;AAAA,YACX,OAAO;AACL,sBAAQ,EAAE;AAAA,YACZ;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAEA,WAAKA,OAAM,WAAW,CAAC,GAAG,SAAU,IAAI,IAAI;AAE1C,YAAI,IAAI;AACN,cAAI,GAAG,SAAS,YAAY,WAAW,QAAQ,cAAc;AAC3D,iBAAK;AACL,iBAAK;AAAA,UACP;AAAA,QACF;AACA,WAAG,IAAI,EAAE;AAAA,MACX,CAAC;AAAA,IACH;AAhCS;AAkCT,aAAS,KAAMA,OAAM,SAAS;AAE5B,UAAI;AACF,eAAO,KAAK,KAAKA,OAAM,WAAW,CAAC,CAAC;AAAA,MACtC,SAAS,IAAI;AACX,YAAI,WAAW,QAAQ,gBAAgB,GAAG,SAAS,UAAU;AAC3D,iBAAO;AAAA,QACT,OAAO;AACL,gBAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAXS;AAAA;AAAA;;;AC7CT;AAAA;AAAA,QAAM,YAAY,QAAQ,aAAa,WACnC,QAAQ,IAAI,WAAW,YACvB,QAAQ,IAAI,WAAW;AAE3B,QAAMC,QAAO,UAAQ,MAAM;AAC3B,QAAM,QAAQ,YAAY,MAAM;AAChC,QAAM,QAAQ;AAEd,QAAM,mBAAmB,wBAAC,QACxB,OAAO,OAAO,IAAI,MAAM,cAAc,GAAG,EAAE,GAAG,EAAE,MAAM,SAAS,CAAC,GADzC;AAGzB,QAAM,cAAc,wBAAC,KAAK,QAAQ;AAChC,YAAM,QAAQ,IAAI,SAAS;AAI3B,YAAM,UAAU,IAAI,MAAM,IAAI,KAAK,aAAa,IAAI,MAAM,IAAI,IAAI,CAAC,EAAE,IAEjE;AAAA;AAAA,QAEE,GAAI,YAAY,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC;AAAA,QACnC,IAAI,IAAI,QAAQ,QAAQ,IAAI;AAAA,QACe,IAAI,MAAM,KAAK;AAAA,MAC5D;AAEJ,YAAM,aAAa,YACf,IAAI,WAAW,QAAQ,IAAI,WAAW,wBACtC;AACJ,YAAM,UAAU,YAAY,WAAW,MAAM,KAAK,IAAI,CAAC,EAAE;AAEzD,UAAI,WAAW;AACb,YAAI,IAAI,QAAQ,GAAG,MAAM,MAAM,QAAQ,CAAC,MAAM;AAC5C,kBAAQ,QAAQ,EAAE;AAAA,MACtB;AAEA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,GA7BoB;AA+BpB,QAAM,QAAQ,wBAAC,KAAK,KAAK,OAAO;AAC9B,UAAI,OAAO,QAAQ,YAAY;AAC7B,aAAK;AACL,cAAM,CAAC;AAAA,MACT;AACA,UAAI,CAAC;AACH,cAAM,CAAC;AAET,YAAM,EAAE,SAAS,SAAS,WAAW,IAAI,YAAY,KAAK,GAAG;AAC7D,YAAM,QAAQ,CAAC;AAEf,YAAM,OAAO,8BAAK,IAAI,QAAQ,CAAC,SAAS,WAAW;AACjD,YAAI,MAAM,QAAQ;AAChB,iBAAO,IAAI,OAAO,MAAM,SAAS,QAAQ,KAAK,IAC1C,OAAO,iBAAiB,GAAG,CAAC;AAElC,cAAM,QAAQ,QAAQ,CAAC;AACvB,cAAM,WAAW,SAAS,KAAK,KAAK,IAAI,MAAM,MAAM,GAAG,EAAE,IAAI;AAE7D,cAAM,OAAOA,MAAK,KAAK,UAAU,GAAG;AACpC,cAAM,IAAI,CAAC,YAAY,YAAY,KAAK,GAAG,IAAI,IAAI,MAAM,GAAG,CAAC,IAAI,OAC7D;AAEJ,gBAAQ,QAAQ,GAAG,GAAG,CAAC,CAAC;AAAA,MAC1B,CAAC,GAbY;AAeb,YAAM,UAAU,wBAAC,GAAG,GAAG,OAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC7D,YAAI,OAAO,QAAQ;AACjB,iBAAO,QAAQ,KAAK,IAAI,CAAC,CAAC;AAC5B,cAAM,MAAM,QAAQ,EAAE;AACtB,cAAM,IAAI,KAAK,EAAE,SAAS,WAAW,GAAG,CAAC,IAAI,OAAO;AAClD,cAAI,CAAC,MAAM,IAAI;AACb,gBAAI,IAAI;AACN,oBAAM,KAAK,IAAI,GAAG;AAAA;AAElB,qBAAO,QAAQ,IAAI,GAAG;AAAA,UAC1B;AACA,iBAAO,QAAQ,QAAQ,GAAG,GAAG,KAAK,CAAC,CAAC;AAAA,QACtC,CAAC;AAAA,MACH,CAAC,GAbe;AAehB,aAAO,KAAK,KAAK,CAAC,EAAE,KAAK,SAAO,GAAG,MAAM,GAAG,GAAG,EAAE,IAAI,KAAK,CAAC;AAAA,IAC7D,GA1Cc;AA4Cd,QAAM,YAAY,wBAAC,KAAK,QAAQ;AAC9B,YAAM,OAAO,CAAC;AAEd,YAAM,EAAE,SAAS,SAAS,WAAW,IAAI,YAAY,KAAK,GAAG;AAC7D,YAAM,QAAQ,CAAC;AAEf,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAM;AACxC,cAAM,QAAQ,QAAQ,CAAC;AACvB,cAAM,WAAW,SAAS,KAAK,KAAK,IAAI,MAAM,MAAM,GAAG,EAAE,IAAI;AAE7D,cAAM,OAAOA,MAAK,KAAK,UAAU,GAAG;AACpC,cAAM,IAAI,CAAC,YAAY,YAAY,KAAK,GAAG,IAAI,IAAI,MAAM,GAAG,CAAC,IAAI,OAC7D;AAEJ,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAM;AACxC,gBAAM,MAAM,IAAI,QAAQ,CAAC;AACzB,cAAI;AACF,kBAAM,KAAK,MAAM,KAAK,KAAK,EAAE,SAAS,WAAW,CAAC;AAClD,gBAAI,IAAI;AACN,kBAAI,IAAI;AACN,sBAAM,KAAK,GAAG;AAAA;AAEd,uBAAO;AAAA,YACX;AAAA,UACF,SAAS,IAAI;AAAA,UAAC;AAAA,QAChB;AAAA,MACF;AAEA,UAAI,IAAI,OAAO,MAAM;AACnB,eAAO;AAET,UAAI,IAAI;AACN,eAAO;AAET,YAAM,iBAAiB,GAAG;AAAA,IAC5B,GAnCkB;AAqClB,WAAO,UAAU;AACjB,UAAM,OAAO;AAAA;AAAA;;;AC5Hb;AAAA;AAAA;AAEA,QAAMC,WAAU,wBAAC,UAAU,CAAC,MAAM;AACjC,YAAM,cAAc,QAAQ,OAAO,QAAQ;AAC3C,YAAM,WAAW,QAAQ,YAAY,QAAQ;AAE7C,UAAI,aAAa,SAAS;AACzB,eAAO;AAAA,MACR;AAEA,aAAO,OAAO,KAAK,WAAW,EAAE,QAAQ,EAAE,KAAK,SAAO,IAAI,YAAY,MAAM,MAAM,KAAK;AAAA,IACxF,GATgB;AAWhB,WAAO,UAAUA;AAEjB,WAAO,QAAQ,UAAUA;AAAA;AAAA;;;ACfzB;AAAA;AAAA;AAEA,QAAMC,QAAO,UAAQ,MAAM;AAC3B,QAAM,QAAQ;AACd,QAAM,aAAa;AAEnB,aAAS,sBAAsB,QAAQ,gBAAgB;AACnD,YAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ;AAC1C,YAAM,MAAM,QAAQ,IAAI;AACxB,YAAM,eAAe,OAAO,QAAQ,OAAO;AAE3C,YAAM,kBAAkB,gBAAgB,QAAQ,UAAU,UAAa,CAAC,QAAQ,MAAM;AAItF,UAAI,iBAAiB;AACjB,YAAI;AACA,kBAAQ,MAAM,OAAO,QAAQ,GAAG;AAAA,QACpC,SAAS,KAAK;AAAA,QAEd;AAAA,MACJ;AAEA,UAAI;AAEJ,UAAI;AACA,mBAAW,MAAM,KAAK,OAAO,SAAS;AAAA,UAClC,MAAM,IAAI,WAAW,EAAE,IAAI,CAAC,CAAC;AAAA,UAC7B,SAAS,iBAAiBA,MAAK,YAAY;AAAA,QAC/C,CAAC;AAAA,MACL,SAAS,GAAG;AAAA,MAEZ,UAAE;AACE,YAAI,iBAAiB;AACjB,kBAAQ,MAAM,GAAG;AAAA,QACrB;AAAA,MACJ;AAIA,UAAI,UAAU;AACV,mBAAWA,MAAK,QAAQ,eAAe,OAAO,QAAQ,MAAM,IAAI,QAAQ;AAAA,MAC5E;AAEA,aAAO;AAAA,IACX;AAvCS;AAyCT,aAAS,eAAe,QAAQ;AAC5B,aAAO,sBAAsB,MAAM,KAAK,sBAAsB,QAAQ,IAAI;AAAA,IAC9E;AAFS;AAIT,WAAO,UAAU;AAAA;AAAA;;;ACnDjB;AAAA;AAAA;AAGA,QAAM,kBAAkB;AAExB,aAAS,cAAc,KAAK;AAExB,YAAM,IAAI,QAAQ,iBAAiB,KAAK;AAExC,aAAO;AAAA,IACX;AALS;AAOT,aAAS,eAAe,KAAK,uBAAuB;AAEhD,YAAM,GAAG,GAAG;AAMZ,YAAM,IAAI,QAAQ,WAAW,SAAS;AAKtC,YAAM,IAAI,QAAQ,UAAU,MAAM;AAKlC,YAAM,IAAI,GAAG;AAGb,YAAM,IAAI,QAAQ,iBAAiB,KAAK;AAGxC,UAAI,uBAAuB;AACvB,cAAM,IAAI,QAAQ,iBAAiB,KAAK;AAAA,MAC5C;AAEA,aAAO;AAAA,IACX;AA7BS;AA+BT,WAAO,QAAQ,UAAU;AACzB,WAAO,QAAQ,WAAW;AAAA;AAAA;;;AC5C1B;AAAA;AAAA;AACA,WAAO,UAAU;AAAA;AAAA;;;ACDjB;AAAA;AAAA;AACA,QAAM,eAAe;AAErB,WAAO,UAAU,CAAC,SAAS,OAAO;AACjC,YAAM,QAAQ,OAAO,MAAM,YAAY;AAEvC,UAAI,CAAC,OAAO;AACX,eAAO;AAAA,MACR;AAEA,YAAM,CAACC,OAAM,QAAQ,IAAI,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,MAAM,GAAG;AAC/D,YAAM,SAASA,MAAK,MAAM,GAAG,EAAE,IAAI;AAEnC,UAAI,WAAW,OAAO;AACrB,eAAO;AAAA,MACR;AAEA,aAAO,WAAW,GAAG,MAAM,IAAI,QAAQ,KAAK;AAAA,IAC7C;AAAA;AAAA;;;AClBA;AAAA;AAAA;AAEA,QAAM,KAAK,UAAQ,IAAI;AACvB,QAAM,iBAAiB;AAEvB,aAAS,YAAY,SAAS;AAE1B,YAAM,OAAO;AACb,YAAM,SAAS,OAAO,MAAM,IAAI;AAEhC,UAAI;AAEJ,UAAI;AACA,aAAK,GAAG,SAAS,SAAS,GAAG;AAC7B,WAAG,SAAS,IAAI,QAAQ,GAAG,MAAM,CAAC;AAClC,WAAG,UAAU,EAAE;AAAA,MACnB,SAAS,GAAG;AAAA,MAAc;AAG1B,aAAO,eAAe,OAAO,SAAS,CAAC;AAAA,IAC3C;AAfS;AAiBT,WAAO,UAAU;AAAA;AAAA;;;ACtBjB;AAAA;AAAA;AAEA,QAAMC,QAAO,UAAQ,MAAM;AAC3B,QAAM,iBAAiB;AACvB,QAAM,SAAS;AACf,QAAM,cAAc;AAEpB,QAAM,QAAQ,QAAQ,aAAa;AACnC,QAAM,qBAAqB;AAC3B,QAAM,kBAAkB;AAExB,aAAS,cAAc,QAAQ;AAC3B,aAAO,OAAO,eAAe,MAAM;AAEnC,YAAM,UAAU,OAAO,QAAQ,YAAY,OAAO,IAAI;AAEtD,UAAI,SAAS;AACT,eAAO,KAAK,QAAQ,OAAO,IAAI;AAC/B,eAAO,UAAU;AAEjB,eAAO,eAAe,MAAM;AAAA,MAChC;AAEA,aAAO,OAAO;AAAA,IAClB;AAbS;AAeT,aAAS,cAAc,QAAQ;AAC3B,UAAI,CAAC,OAAO;AACR,eAAO;AAAA,MACX;AAGA,YAAM,cAAc,cAAc,MAAM;AAGxC,YAAM,aAAa,CAAC,mBAAmB,KAAK,WAAW;AAIvD,UAAI,OAAO,QAAQ,cAAc,YAAY;AAKzC,cAAM,6BAA6B,gBAAgB,KAAK,WAAW;AAInE,eAAO,UAAUA,MAAK,UAAU,OAAO,OAAO;AAG9C,eAAO,UAAU,OAAO,QAAQ,OAAO,OAAO;AAC9C,eAAO,OAAO,OAAO,KAAK,IAAI,CAAC,QAAQ,OAAO,SAAS,KAAK,0BAA0B,CAAC;AAEvF,cAAM,eAAe,CAAC,OAAO,OAAO,EAAE,OAAO,OAAO,IAAI,EAAE,KAAK,GAAG;AAElE,eAAO,OAAO,CAAC,MAAM,MAAM,MAAM,IAAI,YAAY,GAAG;AACpD,eAAO,UAAU,QAAQ,IAAI,WAAW;AACxC,eAAO,QAAQ,2BAA2B;AAAA,MAC9C;AAEA,aAAO;AAAA,IACX;AApCS;AAsCT,aAASC,OAAM,SAAS,MAAM,SAAS;AAEnC,UAAI,QAAQ,CAAC,MAAM,QAAQ,IAAI,GAAG;AAC9B,kBAAU;AACV,eAAO;AAAA,MACX;AAEA,aAAO,OAAO,KAAK,MAAM,CAAC,IAAI,CAAC;AAC/B,gBAAU,OAAO,OAAO,CAAC,GAAG,OAAO;AAGnC,YAAM,SAAS;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN,UAAU;AAAA,UACN;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAGA,aAAO,QAAQ,QAAQ,SAAS,cAAc,MAAM;AAAA,IACxD;AAxBS,WAAAA,QAAA;AA0BT,WAAO,UAAUA;AAAA;AAAA;;;AC1FjB;AAAA;AAAA;AAEA,QAAM,QAAQ,QAAQ,aAAa;AAEnC,aAAS,cAAc,UAAU,SAAS;AACtC,aAAO,OAAO,OAAO,IAAI,MAAM,GAAG,OAAO,IAAI,SAAS,OAAO,SAAS,GAAG;AAAA,QACrE,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS,GAAG,OAAO,IAAI,SAAS,OAAO;AAAA,QACvC,MAAM,SAAS;AAAA,QACf,WAAW,SAAS;AAAA,MACxB,CAAC;AAAA,IACL;AARS;AAUT,aAAS,iBAAiB,IAAI,QAAQ;AAClC,UAAI,CAAC,OAAO;AACR;AAAA,MACJ;AAEA,YAAM,eAAe,GAAG;AAExB,SAAG,OAAO,SAAU,MAAM,MAAM;AAI5B,YAAI,SAAS,QAAQ;AACjB,gBAAM,MAAM,aAAa,MAAM,QAAQ,OAAO;AAE9C,cAAI,KAAK;AACL,mBAAO,aAAa,KAAK,IAAI,SAAS,GAAG;AAAA,UAC7C;AAAA,QACJ;AAEA,eAAO,aAAa,MAAM,IAAI,SAAS;AAAA,MAC3C;AAAA,IACJ;AArBS;AAuBT,aAAS,aAAa,QAAQ,QAAQ;AAClC,UAAI,SAAS,WAAW,KAAK,CAAC,OAAO,MAAM;AACvC,eAAO,cAAc,OAAO,UAAU,OAAO;AAAA,MACjD;AAEA,aAAO;AAAA,IACX;AANS;AAQT,aAAS,iBAAiB,QAAQ,QAAQ;AACtC,UAAI,SAAS,WAAW,KAAK,CAAC,OAAO,MAAM;AACvC,eAAO,cAAc,OAAO,UAAU,WAAW;AAAA,MACrD;AAEA,aAAO;AAAA,IACX;AANS;AAQT,WAAO,UAAU;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;AC1DA;AAAA;AAAA;AAEA,QAAM,KAAK,UAAQ,eAAe;AAClC,QAAMC,SAAQ;AACd,QAAM,SAAS;AAEf,aAAS,MAAM,SAAS,MAAM,SAAS;AAEnC,YAAM,SAASA,OAAM,SAAS,MAAM,OAAO;AAG3C,YAAM,UAAU,GAAG,MAAM,OAAO,SAAS,OAAO,MAAM,OAAO,OAAO;AAIpE,aAAO,iBAAiB,SAAS,MAAM;AAEvC,aAAO;AAAA,IACX;AAZS;AAcT,aAAS,UAAU,SAAS,MAAM,SAAS;AAEvC,YAAM,SAASA,OAAM,SAAS,MAAM,OAAO;AAG3C,YAAM,SAAS,GAAG,UAAU,OAAO,SAAS,OAAO,MAAM,OAAO,OAAO;AAGvE,aAAO,QAAQ,OAAO,SAAS,OAAO,iBAAiB,OAAO,QAAQ,MAAM;AAE5E,aAAO;AAAA,IACX;AAXS;AAaT,WAAO,UAAU;AACjB,WAAO,QAAQ,QAAQ;AACvB,WAAO,QAAQ,OAAO;AAEtB,WAAO,QAAQ,SAASA;AACxB,WAAO,QAAQ,UAAU;AAAA;AAAA;;;ACtCzB;AAAA;AAoBA,WAAO,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,QAAQ,aAAa,SAAS;AAChC,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA;AAAA,MAIF;AAAA,IACF;AAEA,QAAI,QAAQ,aAAa,SAAS;AAChC,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA;AAAA;;;ACpDA;AAAA;AAIA,QAAIC,WAAU,OAAO;AAErB,QAAM,YAAY,gCAAUA,UAAS;AACnC,aAAOA,YACL,OAAOA,aAAY,YACnB,OAAOA,SAAQ,mBAAmB,cAClC,OAAOA,SAAQ,SAAS,cACxB,OAAOA,SAAQ,eAAe,cAC9B,OAAOA,SAAQ,cAAc,cAC7B,OAAOA,SAAQ,SAAS,cACxB,OAAOA,SAAQ,QAAQ,YACvB,OAAOA,SAAQ,OAAO;AAAA,IAC1B,GAVkB;AAclB,QAAI,CAAC,UAAUA,QAAO,GAAG;AACvB,aAAO,UAAU,WAAY;AAC3B,eAAO,WAAY;AAAA,QAAC;AAAA,MACtB;AAAA,IACF,OAAO;AACD,MAAAC,UAAS,UAAQ,QAAQ;AACzB,gBAAU;AACV,cAAQ,QAAQ,KAAKD,SAAQ,QAAQ;AAErC,WAAK,UAAQ,QAAQ;AAEzB,UAAI,OAAO,OAAO,YAAY;AAC5B,aAAK,GAAG;AAAA,MACV;AAGA,UAAIA,SAAQ,yBAAyB;AACnC,kBAAUA,SAAQ;AAAA,MACpB,OAAO;AACL,kBAAUA,SAAQ,0BAA0B,IAAI,GAAG;AACnD,gBAAQ,QAAQ;AAChB,gBAAQ,UAAU,CAAC;AAAA,MACrB;AAMA,UAAI,CAAC,QAAQ,UAAU;AACrB,gBAAQ,gBAAgB,QAAQ;AAChC,gBAAQ,WAAW;AAAA,MACrB;AAEA,aAAO,UAAU,SAAU,IAAI,MAAM;AAEnC,YAAI,CAAC,UAAU,OAAO,OAAO,GAAG;AAC9B,iBAAO,WAAY;AAAA,UAAC;AAAA,QACtB;AACA,QAAAC,QAAO,MAAM,OAAO,IAAI,YAAY,8CAA8C;AAElF,YAAI,WAAW,OAAO;AACpB,eAAK;AAAA,QACP;AAEA,YAAI,KAAK;AACT,YAAI,QAAQ,KAAK,YAAY;AAC3B,eAAK;AAAA,QACP;AAEA,YAAI,SAAS,kCAAY;AACvB,kBAAQ,eAAe,IAAI,EAAE;AAC7B,cAAI,QAAQ,UAAU,MAAM,EAAE,WAAW,KACrC,QAAQ,UAAU,WAAW,EAAE,WAAW,GAAG;AAC/C,mBAAO;AAAA,UACT;AAAA,QACF,GANa;AAOb,gBAAQ,GAAG,IAAI,EAAE;AAEjB,eAAO;AAAA,MACT;AAEI,eAAS,gCAASC,UAAU;AAC9B,YAAI,CAAC,UAAU,CAAC,UAAU,OAAO,OAAO,GAAG;AACzC;AAAA,QACF;AACA,iBAAS;AAET,gBAAQ,QAAQ,SAAU,KAAK;AAC7B,cAAI;AACF,YAAAF,SAAQ,eAAe,KAAK,aAAa,GAAG,CAAC;AAAA,UAC/C,SAAS,IAAI;AAAA,UAAC;AAAA,QAChB,CAAC;AACD,QAAAA,SAAQ,OAAO;AACf,QAAAA,SAAQ,aAAa;AACrB,gBAAQ,SAAS;AAAA,MACnB,GAda;AAeb,aAAO,QAAQ,SAAS;AAEpB,aAAO,gCAASG,MAAM,OAAO,MAAM,QAAQ;AAE7C,YAAI,QAAQ,QAAQ,KAAK,GAAG;AAC1B;AAAA,QACF;AACA,gBAAQ,QAAQ,KAAK,IAAI;AACzB,gBAAQ,KAAK,OAAO,MAAM,MAAM;AAAA,MAClC,GAPW;AAUP,qBAAe,CAAC;AACpB,cAAQ,QAAQ,SAAU,KAAK;AAC7B,qBAAa,GAAG,IAAI,gCAAS,WAAY;AAEvC,cAAI,CAAC,UAAU,OAAO,OAAO,GAAG;AAC9B;AAAA,UACF;AAKA,cAAI,YAAYH,SAAQ,UAAU,GAAG;AACrC,cAAI,UAAU,WAAW,QAAQ,OAAO;AACtC,mBAAO;AACP,iBAAK,QAAQ,MAAM,GAAG;AAEtB,iBAAK,aAAa,MAAM,GAAG;AAE3B,gBAAI,SAAS,QAAQ,UAAU;AAG7B,oBAAM;AAAA,YACR;AAEA,YAAAA,SAAQ,KAAKA,SAAQ,KAAK,GAAG;AAAA,UAC/B;AAAA,QACF,GAxBoB;AAAA,MAyBtB,CAAC;AAED,aAAO,QAAQ,UAAU,WAAY;AACnC,eAAO;AAAA,MACT;AAEI,eAAS;AAET,aAAO,gCAASI,QAAQ;AAC1B,YAAI,UAAU,CAAC,UAAU,OAAO,OAAO,GAAG;AACxC;AAAA,QACF;AACA,iBAAS;AAMT,gBAAQ,SAAS;AAEjB,kBAAU,QAAQ,OAAO,SAAU,KAAK;AACtC,cAAI;AACF,YAAAJ,SAAQ,GAAG,KAAK,aAAa,GAAG,CAAC;AACjC,mBAAO;AAAA,UACT,SAAS,IAAI;AACX,mBAAO;AAAA,UACT;AAAA,QACF,CAAC;AAED,QAAAA,SAAQ,OAAO;AACf,QAAAA,SAAQ,aAAa;AAAA,MACvB,GAvBW;AAwBX,aAAO,QAAQ,OAAO;AAElB,kCAA4BA,SAAQ;AACpC,0BAAoB,gCAASK,mBAAmB,MAAM;AAExD,YAAI,CAAC,UAAU,OAAO,OAAO,GAAG;AAC9B;AAAA,QACF;AACA,QAAAL,SAAQ,WAAW;AAAA,QAAmC;AACtD,aAAK,QAAQA,SAAQ,UAAU,IAAI;AAEnC,aAAK,aAAaA,SAAQ,UAAU,IAAI;AAExC,kCAA0B,KAAKA,UAASA,SAAQ,QAAQ;AAAA,MAC1D,GAXwB;AAapB,4BAAsBA,SAAQ;AAC9B,oBAAc,gCAASM,aAAa,IAAI,KAAK;AAC/C,YAAI,OAAO,UAAU,UAAU,OAAO,OAAO,GAAG;AAE9C,cAAI,QAAQ,QAAW;AACrB,YAAAN,SAAQ,WAAW;AAAA,UACrB;AACA,cAAI,MAAM,oBAAoB,MAAM,MAAM,SAAS;AAEnD,eAAK,QAAQA,SAAQ,UAAU,IAAI;AAEnC,eAAK,aAAaA,SAAQ,UAAU,IAAI;AAExC,iBAAO;AAAA,QACT,OAAO;AACL,iBAAO,oBAAoB,MAAM,MAAM,SAAS;AAAA,QAClD;AAAA,MACF,GAhBkB;AAAA,IAiBpB;AAhLM,QAAAC;AACA;AACA;AAEA;AAMA;AA8CA;AAiBA;AAUA;AAiCA;AAEA;AA0BA;AACA;AAaA;AACA;AAAA;AAAA;;;ACxLN;AAAA;AAAA;AACA,QAAM,EAAC,aAAa,kBAAiB,IAAI,UAAQ,QAAQ;AAEzD,WAAO,UAAU,aAAW;AAC3B,gBAAU,EAAC,GAAG,QAAO;AAErB,YAAM,EAAC,MAAK,IAAI;AAChB,UAAI,EAAC,SAAQ,IAAI;AACjB,YAAM,WAAW,aAAa;AAC9B,UAAI,aAAa;AAEjB,UAAI,OAAO;AACV,qBAAa,EAAE,YAAY;AAAA,MAC5B,OAAO;AACN,mBAAW,YAAY;AAAA,MACxB;AAEA,UAAI,UAAU;AACb,mBAAW;AAAA,MACZ;AAEA,YAAM,SAAS,IAAI,kBAAkB,EAAC,WAAU,CAAC;AAEjD,UAAI,UAAU;AACb,eAAO,YAAY,QAAQ;AAAA,MAC5B;AAEA,UAAI,SAAS;AACb,YAAM,SAAS,CAAC;AAEhB,aAAO,GAAG,QAAQ,WAAS;AAC1B,eAAO,KAAK,KAAK;AAEjB,YAAI,YAAY;AACf,mBAAS,OAAO;AAAA,QACjB,OAAO;AACN,oBAAU,MAAM;AAAA,QACjB;AAAA,MACD,CAAC;AAED,aAAO,mBAAmB,MAAM;AAC/B,YAAI,OAAO;AACV,iBAAO;AAAA,QACR;AAEA,eAAO,WAAW,OAAO,OAAO,QAAQ,MAAM,IAAI,OAAO,KAAK,EAAE;AAAA,MACjE;AAEA,aAAO,oBAAoB,MAAM;AAEjC,aAAO;AAAA,IACR;AAAA;AAAA;;;ACnDA;AAAA;AAAA;AACA,QAAM,EAAC,WAAW,gBAAe,IAAI,UAAQ,QAAQ;AACrD,QAAM,SAAS,UAAQ,QAAQ;AAC/B,QAAM,EAAC,UAAS,IAAI,UAAQ,MAAM;AAClC,QAAM,eAAe;AAErB,QAAM,4BAA4B,UAAU,OAAO,QAAQ;AAE3D,QAAM,iBAAN,cAA6B,MAAM;AAAA,MARnC,OAQmC;AAAA;AAAA;AAAA,MAClC,cAAc;AACb,cAAM,oBAAoB;AAC1B,aAAK,OAAO;AAAA,MACb;AAAA,IACD;AAEA,mBAAeM,WAAU,aAAa,SAAS;AAC9C,UAAI,CAAC,aAAa;AACjB,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACpC;AAEA,gBAAU;AAAA,QACT,WAAW;AAAA,QACX,GAAG;AAAA,MACJ;AAEA,YAAM,EAAC,UAAS,IAAI;AACpB,YAAMC,UAAS,aAAa,OAAO;AAEnC,YAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,cAAM,gBAAgB,wBAAAC,WAAS;AAE9B,cAAIA,UAASD,QAAO,kBAAkB,KAAK,gBAAgB,YAAY;AACtE,YAAAC,OAAM,eAAeD,QAAO,iBAAiB;AAAA,UAC9C;AAEA,iBAAOC,MAAK;AAAA,QACb,GAPsB;AAStB,SAAC,YAAY;AACZ,cAAI;AACH,kBAAM,0BAA0B,aAAaD,OAAM;AACnD,oBAAQ;AAAA,UACT,SAASC,QAAO;AACf,0BAAcA,MAAK;AAAA,UACpB;AAAA,QACD,GAAG;AAEH,QAAAD,QAAO,GAAG,QAAQ,MAAM;AACvB,cAAIA,QAAO,kBAAkB,IAAI,WAAW;AAC3C,0BAAc,IAAI,eAAe,CAAC;AAAA,UACnC;AAAA,QACD,CAAC;AAAA,MACF,CAAC;AAED,aAAOA,QAAO,iBAAiB;AAAA,IAChC;AAxCe,WAAAD,YAAA;AA0Cf,WAAO,UAAUA;AACjB,WAAO,QAAQ,SAAS,CAACC,SAAQ,YAAYD,WAAUC,SAAQ,EAAC,GAAG,SAAS,UAAU,SAAQ,CAAC;AAC/F,WAAO,QAAQ,QAAQ,CAACA,SAAQ,YAAYD,WAAUC,SAAQ,EAAC,GAAG,SAAS,OAAO,KAAI,CAAC;AACvF,WAAO,QAAQ,iBAAiB;AAAA;AAAA;;;AC5DhC;AAAA;AAAA;AAEA,QAAM,EAAE,YAAY,IAAI,UAAQ,QAAQ;AAExC,WAAO,UAAU,WAA0B;AACzC,UAAI,UAAU,CAAC;AACf,UAAI,SAAU,IAAI,YAAY,EAAC,YAAY,KAAI,CAAC;AAEhD,aAAO,gBAAgB,CAAC;AAExB,aAAO,MAAM;AACb,aAAO,UAAU;AAEjB,aAAO,GAAG,UAAU,MAAM;AAE1B,YAAM,UAAU,MAAM,KAAK,SAAS,EAAE,QAAQ,GAAG;AAEjD,aAAO;AAEP,eAAS,IAAK,QAAQ;AACpB,YAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,iBAAO,QAAQ,GAAG;AAClB,iBAAO;AAAA,QACT;AAEA,gBAAQ,KAAK,MAAM;AACnB,eAAO,KAAK,OAAO,OAAO,KAAK,MAAM,MAAM,CAAC;AAC5C,eAAO,KAAK,SAAS,OAAO,KAAK,KAAK,QAAQ,OAAO,CAAC;AACtD,eAAO,KAAK,QAAQ,EAAC,KAAK,MAAK,CAAC;AAChC,eAAO;AAAA,MACT;AAXS;AAaT,eAAS,UAAW;AAClB,eAAO,QAAQ,UAAU;AAAA,MAC3B;AAFS;AAIT,eAAS,OAAQ,QAAQ;AACvB,kBAAU,QAAQ,OAAO,SAAU,IAAI;AAAE,iBAAO,OAAO;AAAA,QAAO,CAAC;AAC/D,YAAI,CAAC,QAAQ,UAAU,OAAO,UAAU;AAAE,iBAAO,IAAI;AAAA,QAAE;AAAA,MACzD;AAHS;AAAA,IAIX;AAAA;AAAA;;;ACxCA;AAAA;AAAA;AACA,QAAIE,aAAY,OAAO;AACvB,QAAIC,oBAAmB,OAAO;AAC9B,QAAIC,qBAAoB,OAAO;AAC/B,QAAIC,gBAAe,OAAO,UAAU;AACpC,QAAI,WAAW,wBAAC,QAAQ,QAAQ;AAC9B,eAAS,QAAQ;AACf,QAAAH,WAAU,QAAQ,MAAM,EAAE,KAAK,IAAI,IAAI,GAAG,YAAY,KAAK,CAAC;AAAA,IAChE,GAHe;AAIf,QAAII,eAAc,wBAAC,IAAI,MAAM,QAAQ,SAAS;AAC5C,UAAI,QAAQ,OAAO,SAAS,YAAY,OAAO,SAAS,YAAY;AAClE,iBAAS,OAAOF,mBAAkB,IAAI;AACpC,cAAI,CAACC,cAAa,KAAK,IAAI,GAAG,KAAK,QAAQ;AACzC,YAAAH,WAAU,IAAI,KAAK,EAAE,KAAK,MAAM,KAAK,GAAG,GAAG,YAAY,EAAE,OAAOC,kBAAiB,MAAM,GAAG,MAAM,KAAK,WAAW,CAAC;AAAA,MACvH;AACA,aAAO;AAAA,IACT,GAPkB;AAQlB,QAAI,eAAe,wBAAC,QAAQG,aAAYJ,WAAU,CAAC,GAAG,cAAc,EAAE,OAAO,KAAK,CAAC,GAAG,GAAG,GAAtE;AAGnB,QAAI,mBAAmB,CAAC;AACxB,aAAS,kBAAkB;AAAA,MACzB,qBAAqB,MAAM;AAAA,MAC3B,sBAAsB,MAAM;AAAA,MAC5B,cAAc,MAAMK;AAAA,MACpB,qBAAqB,MAAM;AAAA,IAC7B,CAAC;AACD,WAAO,UAAU,aAAa,gBAAgB;AAG9C,QAAIC,WAAU;AAGd,aAAS,+BAA+B,UAAU;AAChD,UAAI,CAAC,SAAS,MAAM;AAClB,eAAO;AAAA,UACL,GAAG;AAAA,UACH,MAAM,CAAC;AAAA,QACT;AAAA,MACF;AACA,YAAM,6BAA6B,iBAAiB,SAAS,QAAQ,EAAE,SAAS,SAAS;AACzF,UAAI,CAAC;AACH,eAAO;AACT,YAAM,oBAAoB,SAAS,KAAK;AACxC,YAAM,sBAAsB,SAAS,KAAK;AAC1C,YAAM,aAAa,SAAS,KAAK;AACjC,aAAO,SAAS,KAAK;AACrB,aAAO,SAAS,KAAK;AACrB,aAAO,SAAS,KAAK;AACrB,YAAM,eAAe,OAAO,KAAK,SAAS,IAAI,EAAE,CAAC;AACjD,YAAM,OAAO,SAAS,KAAK,YAAY;AACvC,eAAS,OAAO;AAChB,UAAI,OAAO,sBAAsB,aAAa;AAC5C,iBAAS,KAAK,qBAAqB;AAAA,MACrC;AACA,UAAI,OAAO,wBAAwB,aAAa;AAC9C,iBAAS,KAAK,uBAAuB;AAAA,MACvC;AACA,eAAS,KAAK,cAAc;AAC5B,aAAO;AAAA,IACT;AA3BS;AA8BT,aAAS,SAAS,SAAS,OAAO,YAAY;AAC5C,YAAM,UAAU,OAAO,UAAU,aAAa,MAAM,SAAS,UAAU,IAAI,QAAQ,QAAQ,SAAS,OAAO,UAAU;AACrH,YAAM,gBAAgB,OAAO,UAAU,aAAa,QAAQ,QAAQ;AACpE,YAAM,SAAS,QAAQ;AACvB,YAAM,UAAU,QAAQ;AACxB,UAAIC,OAAM,QAAQ;AAClB,aAAO;AAAA,QACL,CAAC,OAAO,aAAa,GAAG,OAAO;AAAA,UAC7B,MAAM,OAAO;AACX,gBAAI,CAACA;AACH,qBAAO,EAAE,MAAM,KAAK;AACtB,gBAAI;AACF,oBAAM,WAAW,MAAM,cAAc,EAAE,QAAQ,KAAAA,MAAK,QAAQ,CAAC;AAC7D,oBAAM,qBAAqB,+BAA+B,QAAQ;AAClE,cAAAA,SAAQ,mBAAmB,QAAQ,QAAQ,IAAI;AAAA,gBAC7C;AAAA,cACF,KAAK,CAAC,GAAG,CAAC;AACV,qBAAO,EAAE,OAAO,mBAAmB;AAAA,YACrC,SAASC,QAAO;AACd,kBAAIA,OAAM,WAAW;AACnB,sBAAMA;AACR,cAAAD,OAAM;AACN,qBAAO;AAAA,gBACL,OAAO;AAAA,kBACL,QAAQ;AAAA,kBACR,SAAS,CAAC;AAAA,kBACV,MAAM,CAAC;AAAA,gBACT;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAjCS;AAoCT,aAASE,UAAS,SAAS,OAAO,YAAY,OAAO;AACnD,UAAI,OAAO,eAAe,YAAY;AACpC,gBAAQ;AACR,qBAAa;AAAA,MACf;AACA,aAAO;AAAA,QACL;AAAA,QACA,CAAC;AAAA,QACD,SAAS,SAAS,OAAO,UAAU,EAAE,OAAO,aAAa,EAAE;AAAA,QAC3D;AAAA,MACF;AAAA,IACF;AAXS,WAAAA,WAAA;AAYT,aAAS,OAAO,SAAS,SAAS,WAAW,OAAO;AAClD,aAAO,UAAU,KAAK,EAAE,KAAK,CAAC,WAAW;AACvC,YAAI,OAAO,MAAM;AACf,iBAAO;AAAA,QACT;AACA,YAAI,YAAY;AAChB,iBAAS,OAAO;AACd,sBAAY;AAAA,QACd;AAFS;AAGT,kBAAU,QAAQ;AAAA,UAChB,QAAQ,MAAM,OAAO,OAAO,IAAI,IAAI,OAAO,MAAM;AAAA,QACnD;AACA,YAAI,WAAW;AACb,iBAAO;AAAA,QACT;AACA,eAAO,OAAO,SAAS,SAAS,WAAW,KAAK;AAAA,MAClD,CAAC;AAAA,IACH;AAjBS;AAoBT,QAAI,sBAAsB,OAAO,OAAOA,WAAU;AAAA,MAChD;AAAA,IACF,CAAC;AAGD,QAAI,sBAAsB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AA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",
  "names": ["path", "path", "path", "path", "pathKey", "path", "path", "path", "parse", "parse", "process", "assert", "unload", "emit", "load", "processReallyExit", "processEmit", "getStream", "stream", "error", "__defProp", "__getOwnPropDesc", "__getOwnPropNames", "__hasOwnProp", "__copyProps", "paginateRest", "VERSION", "url", "error", "paginate", "EOL", "__name", "__name", "__name", "EOL", "__name", "EOL", "__name", "__name", "EOL", "ExitCode", "__name", "EOL", "__name", "__name", "EOL", "EOL", "__name", "EOL", "Buffer", "path", "process", "process", "process", "path", "onetime", "constants", "constants", "constants", "constants", "error", "onExit", "getInput", "mergeStream", "error", "getStream", "error", "Buffer", "ChildProcess", "ChildProcess", "Buffer", "expression", "process", "process", "process", "crossSpawn", "path", "error", "Buffer", "$", "existsSync", "readFileSync", "EOL", "existsSync", "readFileSync", "path", "EOL", "repo", "ref", "path", "error", "response", "url", "deployment", "error", "url", "url", "url", "url", "url", "value", "url", "DEFAULTS", "endpoint", "VERSION", "isPlainObject", "isPlainObject", "url", "fetch", "error", "withDefaults", "endpoint", "request", "route", "parameters", "request", "withDefaults", "VERSION", "request", "endpoint", "VERSION", "request", "graphql", "request", "withDefaults", "graphql", "graphql", "withDefaults", "request", "VERSION", "name", "method", "hook", "error", "hook", "VERSION", "VERSION", "hook", "userAgent", "request", "auth", "endpoint", "getDeployments", "getDeployments", "payload", "url", "error"]
}
